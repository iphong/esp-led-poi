/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/js/action.js":
/*!**************************!*\
  !*** ./app/js/action.js ***!
  \**************************/
/*! exports provided: saveFile, openFile, startShow, endShow, pauseShow, resumeShow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveFile", function() { return saveFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openFile", function() { return openFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startShow", function() { return startShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endShow", function() { return endShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pauseShow", function() { return pauseShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resumeShow", function() { return resumeShow; });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./app/js/api.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./app/js/data.js");
/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ws */ "./app/js/ws.js");



async function saveFile() {
  const handle = await showSaveFilePicker();
  console.log(handle);
}
async function openFile() {
  const handle = await showOpenFilePicker();
  console.log(handle);
}
async function startShow() {
  Object(_ws__WEBPACK_IMPORTED_MODULE_2__["send"])('#>BEGIN');
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["call"])('#player', 'play');
}
async function endShow() {
  Object(_ws__WEBPACK_IMPORTED_MODULE_2__["send"])('#>END');
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["setProp"])('#player', 'currentTime', _data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].params.end / 1000);
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["call"])('#player', 'pause');
}
async function pauseShow() {
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["call"])('#player', 'pause');
}
async function resumeShow() {
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["call"])('#player', 'play');
}

/***/ }),

/***/ "./app/js/api.js":
/*!***********************!*\
  !*** ./app/js/api.js ***!
  \***********************/
/*! exports provided: constrain, map, rgbToHsl, hslToRgb, rgbToHsv, hsvToRgb, $, setText, setValue, setProp, setAttr, click, call, request, fetchFile, uploadFile, get, post, exec, formatBytes, formatTime, sendCommand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constrain", function() { return constrain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHsl", function() { return rgbToHsl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslToRgb", function() { return hslToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHsv", function() { return rgbToHsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsvToRgb", function() { return hsvToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$", function() { return $; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setText", function() { return setText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setValue", function() { return setValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setProp", function() { return setProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttr", function() { return setAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "call", function() { return call; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "request", function() { return request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "post", function() { return post; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exec", function() { return exec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBytes", function() { return formatBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTime", function() { return formatTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendCommand", function() { return sendCommand; });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./app/js/data.js");
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @return  Array           The HSL representation
 * @param r Number
 * @param g Number
 * @param b Number
 */

function constrain(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
function map(value, fromMin, fromMax, toMin, toMax) {
  return toMin + (toMax - toMin) * ((value - fromMin) / (fromMax - fromMin));
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  let max = Math.max(r, g, b),
      min = Math.min(r, g, b);
  let h,
      s,
      l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    let d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    l
  };
}
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @return  Object           The RGB representation
 * @param h
 * @param s
 * @param l
 */

function hslToRgb(h, s, l) {
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    global.hue2rgb = function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };

    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    let p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 *
 * @return  Array           The HSV representation
 * @param r
 * @param g
 * @param b
 */

function rgbToHsv(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  let max = Math.max(r, g, b),
      min = Math.min(r, g, b);
  let h,
      s,
      v = max;
  let d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    v
  };
}
/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @return  Object           The RGB representation
 * @param h
 * @param s
 * @param v
 */

function hsvToRgb(h, s, v) {
  let r, g, b;
  let i = Math.floor(h * 6);
  let f = h * 6 - i;
  let p = v * (1 - s);
  let q = v * (1 - f * s);
  let t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;

    case 1:
      r = q;
      g = v;
      b = p;
      break;

    case 2:
      r = p;
      g = v;
      b = t;
      break;

    case 3:
      r = p;
      g = q;
      b = v;
      break;

    case 4:
      r = t;
      g = p;
      b = v;
      break;

    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }

  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function $(selector) {
  return document.body.querySelectorAll(selector);
}
function setText(selector, text) {
  if (typeof text === 'undefined') return;
  $(selector).forEach(el => {
    el.innerHTML = text;
  });
}
function setValue(selector, value) {
  if (typeof value === 'undefined') return;
  $(selector).forEach(el => {
    el.value = value;
  });
}
function setProp(selector, prop, value) {
  if (typeof value === 'undefined') return;
  $(selector).forEach(el => {
    el[prop] = value;
  });
}
function setAttr(selector, attr, value) {
  if (typeof value === 'undefined') return;
  $(selector).forEach(el => {
    el.setAttribute(attr, value);
  });
}
function click(selector) {
  $(selector).forEach(el => {
    el.click();
  });
}
function call(selector, method, ...args) {
  $(selector).forEach(el => {
    if (typeof el[method] === 'function') {
      el[method].call(el, ...args);
    }
  });
}
function request(method = 'POST', path = '', args = {}, body = null) {
  return new Promise((resolve, reject) => {
    const req = new XMLHttpRequest();
    const params = Object.entries(args);
    const uri = path + (params.length ? '?' + params.map(([key, value]) => `${key}=${value}`).join('&') : '');
    const size = body ? ` [${body.size || body.length} Kb]` : '';
    const output = console.debug(`${method} ${uri} ${size}... `);
    req.open(method, uri, true);
    req.send(body);
    req.addEventListener('loadend', () => {
      if (output) {
        // output.innerHTML += `[${req.status} ${req.statusText}] ${req.responseText.split("\n")[0]}`
        output.innerHTML += `[${req.status} ${req.statusText}]`;
      } else {
        console.log('--', `[${req.status} ${req.statusText}]`);
      }

      if (req.status === 200) {
        if (req.getResponseHeader('Content-Type') === 'application/json') {
          resolve(JSON.parse(req.responseText), req);
        } else resolve(req.responseText, req);
      } else {
        reject();
      }
    });
    req.addEventListener('error', reject);
  });
}
function fetchFile(path, type = '') {
  const $progress = document.createElement('span');
  const $output = console.debug(`FETCH ${path} ... `);
  if ($output) $output.appendChild($progress);
  let canceled;
  let progress;
  let response;
  let stream;
  let bytesRead = 0;
  const data = [];
  const promise = new Promise(async (resolve, reject) => {
    response = await fetch(path);
    stream = response.body.getReader();

    async function next() {
      try {
        const {
          done,
          value
        } = await stream.read();

        if (!done) {
          if (canceled) {
            stream.cancel();
          } else {
            bytesRead += value.length;
            data.push(value);
            if (progress) progress(bytesRead);

            if ($progress) {
              $progress.innerText = `${formatBytes(bytesRead)}`;
            }
          }

          setTimeout(next);
        } else {
          if (canceled) {
            $progress.innerText += ' CANCELED';
            reject();
          } else {
            const file = new Blob(data, {
              type
            });
            $progress.innerText += ' OK';
            resolve(file);
          }
        }
      } catch (e) {
        console.log(e);
        reject();
      }
    }

    setTimeout(next);
  });

  promise.progress = callback => {
    progress = callback;
    return promise;
  };

  promise.cancel = () => {
    canceled = true; // if (stream) stream.cancel()

    return promise;
  };

  return promise;
}
async function uploadFile(path, body, sync = false, target = null, useSD = false) {
  const file = new Blob([body]);
  const output = console.debug(`UPLOAD ${path} [${(file.size / 1000).toFixed(2)} KB] ... `);
  return new Promise((resolve, reject) => {
    const form = new FormData();
    const req = new XMLHttpRequest();
    form.append('filename', path);
    form.append('file', file);
    req.open('POST', `edit?${sync ? 'sync' : 'nosync'}${target ? `&target=${target}` : ''}${useSD ? '&storage=sd' : ''}`, true);
    req.send(form);

    req.onloadend = e => {
      if (output) {
        output.innerHTML += `[${req.status} ${req.statusText}]`;
      } else {
        console.log('--', `[${req.status} ${req.statusText}]`);
      }

      if (req.status === 200) {
        resolve(req);
      } else {
        reject(req);
      }
    };
  });
}
function get(path, params) {
  return request('GET', path, params);
}
function post(path, params, body) {
  return request('POST', path, params, body);
}
function exec(cmd) {
  // console.log('execute ' + cmd)
  return request('POST', 'exec', {
    cmd
  });
}
function formatBytes(bytes) {
  if (bytes >= 1000000000) return (bytes / 1000000000).toPrecision(3) + ' GB';
  if (bytes >= 1000000) return (bytes / 1000000).toPrecision(3) + ' MB';
  if (bytes >= 1000) return (bytes / 1000).toPrecision(3) + ' KB';
  return '0.00 B';
}
function formatTime(duration, showHour = false) {
  const hour = Math.floor(duration / 3600);
  const hourLeft = duration % 3600;
  const minute = Math.floor(hourLeft / 60);
  const second = Math.floor(hourLeft % 60);
  const ms = Math.floor(duration % 1 * 100);
  if (showHour || hour) return [hour.toString().padStart(2, '0'), minute.toString().padStart(2, '0'), second.toString().padStart(2, '0'), ms.toString().padStart(2, '0')].join(':');else return [minute.toString().padStart(2, '0'), second.toString().padStart(2, '0'), ms.toString().padStart(2, '0')].join(':');
}
async function sendCommand(command = '', ...data) {
  console.log('SEND ' + command + ' ' + data.join(' '));
  let selected = _data__WEBPACK_IMPORTED_MODULE_0__["CONFIG"].nodes.filter(n => n.selected).map(n => n.id);
  if (!selected.length) selected = ['#'];

  for (let id of selected) {
    await send(id, command.toUpperCase(), ...data);
  }
}
Object.assign(global, {
  $,
  setText,
  setValue,
  setProp,
  setAttr,
  click,
  call,
  request,
  get,
  post,
  uploadFile,
  fetchFile,
  sendCommand
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./app/js/app.js":
/*!***********************!*\
  !*** ./app/js/app.js ***!
  \***********************/
/*! exports provided: renderHead, renderNodes, checkNodes, selectShow, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderHead", function() { return renderHead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderNodes", function() { return renderNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNodes", function() { return checkNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectShow", function() { return selectShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./app/js/api.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./app/js/data.js");
/* harmony import */ var _audio__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio */ "./app/js/audio.js");
/* harmony import */ var _light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./light */ "./app/js/light.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events */ "./app/js/events.js");





function renderHead() {
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["$"])('[data-show]').forEach(el => {
    if (parseInt(el.dataset.show) === _data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].show) {
      el.classList.add('selected');
    } else {
      el.classList.remove('selected');
    }
  });
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["$"])('#toolbar').forEach(el => {
    el.innerHTML = ``;

    if (_data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].running) {
      // el.innerHTML = `<button data-action="show-stop">STOP</button>`
      el.innerHTML += `<span id="time"></span>`;
      if (_data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].paused) el.innerHTML += `<button data-action="resumeShow">PLAY</button>`;else el.innerHTML += `<button data-action="pauseShow">PAUSE</button>`;
    } else if (_data__WEBPACK_IMPORTED_MODULE_1__["AUDIO"].file) {
      el.innerHTML += `<button data-action="startShow">START</button>`;
    } else {
      el.innerHTML += `<button data-action="openFile">UPLOAD</button>`;
    }
  }); // const { id, ip, mac, brightness, channel, show } = CONFIG
  // setText('#id', id)
  // setText('#ip', ip)
  // setText('#mac', mac)
}
function renderNodes() {
  Object(_api__WEBPACK_IMPORTED_MODULE_0__["$"])('section.nodes').forEach(section => {
    section.innerHTML = '';
    _data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].nodes.sort((a, b) => {
      if (a.name > b.name) return 1;
      if (a.name < b.name) return -1;
      return 0;
    }).forEach(node => {
      const $node = document.createElement('article');
      const vbat = node.hidden ? 0 : node.vbat / 1000;
      const percent = Object(_api__WEBPACK_IMPORTED_MODULE_0__["constrain"])(Object(_api__WEBPACK_IMPORTED_MODULE_0__["map"])(vbat, 3.0, 4.1, 0, 100), 0, 100);
      $node.classList.add('node');
      $node.dataset.droppable = true;
      if (node.selected) $node.classList.add('selected');
      if (node.hidden) $node.classList.add('hidden');
      $node.innerHTML = `
			<small>${node.id}</small>
			<div>${node.name}</div>
			<small>${vbat.toPrecision(2)}v ${percent.toFixed(0)}%</small>
			<progress value="${percent.toFixed(0)}" max="100"></progress>
			`;
      $node.dataset.device = node.id;
      $node.dataset.droppable = true;
      section.appendChild($node);
    });
  });
}
async function checkNodes() {
  try {
    const expired = Date.now() - 15000;
    let changed;
    _data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].nodes.forEach(node => {
      if (!node.hidden && node.lastUpdated < expired) {
        node.hidden = true;
        node.selected = false;
        changed = true;
      }
    });
    if (changed) renderNodes();
  } catch (e) {}
}
let fetchRequest;
async function selectShow(id) {
  if (fetchRequest) {
    fetchRequest.cancel();
  }

  Object(_events__WEBPACK_IMPORTED_MODULE_4__["handleEnd"])();
  _data__WEBPACK_IMPORTED_MODULE_1__["CONFIG"].show = id;
  Object.assign(_data__WEBPACK_IMPORTED_MODULE_1__["SHOW"], {
    map: {},
    tracks: [],
    params: {}
  });
  _data__WEBPACK_IMPORTED_MODULE_1__["AUDIO"].file = null;
  setText('.tracks', '');
  render();
  fetchRequest = fetchFile(`show?id=${id}`);
  fetchRequest.then(async file => {
    Object.assign(_data__WEBPACK_IMPORTED_MODULE_1__["SHOW"], JSON.parse(await file.text()));
    Object(_light__WEBPACK_IMPORTED_MODULE_3__["renderShow"])();
    fetchRequest = fetchFile(`show/${id}.mp3`);
    fetchRequest.then(async file => {
      fetchRequest = null;
      _data__WEBPACK_IMPORTED_MODULE_1__["AUDIO"].file = file;
      Object(_audio__WEBPACK_IMPORTED_MODULE_2__["renderAudio"])();
      renderHead();
    }).catch(e => {
      fetchRequest = null;
    });
  }).catch(e => {
    fetchRequest = null;
  });
}
async function render() {
  renderHead();
  renderNodes();
  Object(_light__WEBPACK_IMPORTED_MODULE_3__["renderShow"])();
  Object(_audio__WEBPACK_IMPORTED_MODULE_2__["renderAudio"])();
}
Object.assign(global, {
  render,
  renderAudio: _audio__WEBPACK_IMPORTED_MODULE_2__["renderAudio"],
  renderHead,
  renderNodes,
  renderShow: _light__WEBPACK_IMPORTED_MODULE_3__["renderShow"]
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./app/js/audio.js":
/*!*************************!*\
  !*** ./app/js/audio.js ***!
  \*************************/
/*! exports provided: parseAudio, renderAudio, renderWaveform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseAudio", function() { return parseAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderAudio", function() { return renderAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderWaveform", function() { return renderWaveform; });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./app/js/data.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./app/js/events.js");


const AudioContext = window['AudioContext'] || window['webkitAudioContext'];
async function parseAudio(file) {
  return new Promise(resolve => {
    const ctx = new AudioContext();
    const reader = new FileReader();
    reader.readAsArrayBuffer(file);
    reader.addEventListener('loadend', e => {
      console.log(`decoding ${file.type}...`);

      function handle(audio) {
        const {
          sampleRate,
          duration
        } = audio;
        const channels = [];

        for (let i = 0; i < audio.numberOfChannels; i++) {
          const data = audio.getChannelData(i);
          const {
            tempo,
            beats,
            peaks,
            spectralFlux: flux,
            ...other
          } = new MusicTempo(data);
          beats.forEach((t, i, b) => b[i] = Math.round(t * 1000));
          channels[i] = {
            data,
            beats,
            tempo
          };
        }

        resolve(Object.assign(_data__WEBPACK_IMPORTED_MODULE_0__["AUDIO"], {
          duration,
          channels
        }));
      }

      if ('chrome' in window) {
        ctx.decodeAudioData(reader.result).catch(_events__WEBPACK_IMPORTED_MODULE_1__["handleError"]).then(handle);
      } else {
        ctx.decodeAudioData(reader.result, handle, _events__WEBPACK_IMPORTED_MODULE_1__["handleError"]);
      }
    });
  });
}
async function renderAudio() {
  if (_data__WEBPACK_IMPORTED_MODULE_0__["AUDIO"].file) {
    setAttr('#player', 'src', URL.createObjectURL(_data__WEBPACK_IMPORTED_MODULE_0__["AUDIO"].file)); // $('.track.waveform').forEach(el => (el.innerHTML = '<div class="loading">Loading...</div>'))
    // renderWaveform(await parseAudio(AUDIO.file))
  } else {
    setAttr('#player', 'src', '');
    $('.track.waveform').forEach(el => el.innerHTML = '');
  }
}
async function renderWaveform() {
  $('.track.waveform').forEach((wrapper, index) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext("2d");
    const waveData = _data__WEBPACK_IMPORTED_MODULE_0__["AUDIO"].channels[index].data;
    const height = 80;
    const width = window.innerWidth;
    const halfHeight = height / 2;
    const length = waveData.length;
    const step = Math.round(length / width);
    wrapper.innerHTML = '';
    wrapper.appendChild(canvas);
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    canvas.style.left = Math.round(wrapper.clientWidth / 2) + "px";
    let x = 0,
        sumPositive = 0,
        sumNegative = 0,
        maxPositive = 0,
        maxNegative = 0,
        kNegative = 0,
        kPositive = 0,
        drawIdx = step;

    for (let i = 0; i < length; i++) {
      if (i == drawIdx) {
        const p1 = maxNegative * halfHeight + halfHeight;
        ctx.strokeStyle = '#333333';
        ctx.strokeRect(x, p1, 1, maxPositive * halfHeight + halfHeight - p1);
        const p2 = sumNegative / kNegative * halfHeight + halfHeight;
        ctx.strokeStyle = '#eeeeee';
        ctx.strokeRect(x, p2, 1, sumPositive / kPositive * halfHeight + halfHeight - p2);
        x++;
        drawIdx += step;
        sumPositive = 0;
        sumNegative = 0;
        maxPositive = 0;
        maxNegative = 0;
        kNegative = 0;
        kPositive = 0;
      } else {
        if (waveData[i] < 0) {
          sumNegative += waveData[i];
          kNegative++;
          if (maxNegative > waveData[i]) maxNegative = waveData[i];
        } else {
          sumPositive += waveData[i];
          kPositive++;
          if (maxPositive < waveData[i]) maxPositive = waveData[i];
        }
      }
    }
  });
} // let ab
// global.getWaveformData = function getWaveformData(audio) {
// 	const data = audio.getChannelData(0)
// 	const size = audio.sampleRate / 10
// 	const total = audio.duration * 10
// 	const array = new Int8Array(total * 2)
// 	for (let i = 0 ; i < total ; i++) {
// 		let min = 1, max = -1
// 		const offset = i * size
// 		for (let a = 0 ; a < size ; a++) {
// 			min = Math.min(min, data[offset + a])
// 			max = Math.max(max, data[offset + a])
// 		}
// 		array[offset * 2] = min * 127
// 		array[offset * 2 + 1] = max * 127
// 	}
// }
// global.parseAudio = function parseAudio(file) {
// 	AUDIO.filename = file.name
// 	renderAudio()
// 	return new Promise(resolve => {
// 		const ctx = new AudioContext()
// 		const reader = new FileReader()
// 		reader.readAsArrayBuffer(file)
// 		reader.addEventListener('loadend', e => {
// 			console.debug(`decoding ${file.type}...`)
// 			const handle = audio => {
// 				// getWaveformData(audio)
// 				console.append('OK')
// 				Object.assign(AUDIO, {
// 					id: CONFIG.show,
// 					url: URL.createObjectURL(file),
// 					filename: file.name,
// 					duration: Math.round(audio.duration * 1000) / 1000,
// 					sampleRate: audio.sampleRate,
// 					tempo: 0,
// 					beats: 0,
// 					channels: []
// 				})
// 				for (let i = 0 ; i < audio.numberOfChannels ; i++) {
// 					const { tempo, beats } = new MusicTempo(audio.getChannelData(i))
// 					beats.forEach((t, i, b) => {
// 						b[i] = Math.round(t*1000)
// 					})
// 					AUDIO.channels[i] = { 
// 						tempo,
// 						beats,
// 						delay: beats[0],
// 						end: beats[beats.length - 1]
// 					}
// 					AUDIO.tempo += parseInt((tempo))
// 					AUDIO.beats += beats.length
// 					console.info(`-- @${i + 1}: ${beats.length} beats, TEMPO: ${tempo} BPM`)
// 				}
// 				AUDIO.tempo /= audio.numberOfChannels
// 				AUDIO.beats /= audio.numberOfChannels
// 				renderAudio()
// 				saveAudioConfig().then(resolve)
// 			}
// 			if ('chrome' in window) {
// 				ctx.decodeAudioData(reader.result).catch(handleError).then(handle)
// 			} else {
// 				ctx.decodeAudioData(reader.result, handle, handleError)
// 			}
// 		})
// 	})
// }
// global.saveAudioConfig = function saveAudioConfig(id = CONFIG.show, data = AUDIO) {
// 	return uploadFile(`/show/${id}.json`, JSON.stringify(AUDIO))
// }
// global.loadAudioConfig = function loadAudioConfig(id = CONFIG.show, data = AUDIO) {
// 	return get(`show/${id}.json`)
// 		.then(res => {
// 			Object.assign(data, res)
// 			renderAudio()
// 		})
// 		.catch(() => {
// 			Object.assign(data, AUDIO_DEFAULT)
// 			renderAudio()
// 		})
// }
// global.saveLightShow = function saveLightShow(id = CONFIG.show, data = AUDIO) {
// 	return new Promise(resolve => {
// 		// SHOWS[0] = createLoop(0, AUDIO.channels[0], AUDIO.tempo)
// 		// SHOWS[1] = createLoop(1, AUDIO.channels[1], AUDIO.tempo)
// 		SHOWS[0] = createSequenceFromBeats(AUDIO.channels[0].beats, 0)
// 		SHOWS[1] = createSequenceFromBeats(AUDIO.channels[1].beats, 1)
// 		return uploadFile(`/show/${CONFIG.show}A.lsb`, SHOWS[0])
// 			.then(() => uploadFile(`/show/${CONFIG.show}B.lsb`, SHOWS[1]))
// 			.then(() => resolve(SHOWS))
// 	})
// }
// global.clearLightShow = function clearLightShow(id = CONFIG.show, data = AUDIO) {
// 	return new Promise(resolve => {
// 		return request('DELETE', `show/${CONFIG.show}.json`)
// 			.finally(() => request('DELETE', `/show/${CONFIG.show}A.lsb`))
// 			.finally(() => request('DELETE', `/show/${CONFIG.show}B.lsb`))
// 			.finally(resolve)
// 	})
// }
// global.createLoop = function createLoop(index, channel, tempo) {
// 	const delay = channel.delay
// 	const end = channel.end
// 	const dur = Math.ceil(1000 / (tempo / 60))
// 	const dur1 = Math.round(dur * AUDIO.ratio)
// 	const dur2 = dur - dur1
// 	const fade1 = Math.round(dur1 * 1)
// 	const fade2 = Math.round(dur2 * 1)
// 	let color1 = hexToIntString(AUDIO.color1)
// 	let color2 = hexToIntString(AUDIO.color2)
// 	if (AUDIO.swap && index % 2) {
// 		color1 = hexToIntString(AUDIO.color2)
// 		color2 = hexToIntString(AUDIO.color1)
// 	}
// 	return [
// 		`C 0 ${delay} 0 0 0 0`,
// 		`L ${delay} ${end - delay}`,
// 		`	C 0 ${dur1} ${fade1} ${color1}`,
// 		`	C ${dur1} ${dur2} ${fade2} ${color2}`,
// 		`	E ${dur}`,
// 		`E ${end}`
// 	].join('\n')
// }
// global.createSequenceFromBeats = function createSequenceFromBeats(beats, channel = 0) {
// 	let seq = `C 0 ${beats[0]} 0 0 0 0\n`
// 	seq += beats.map((time, index) => {
// 		if (index + 1 < beats.length) {
// 			const start = Math.round(time)
// 			const dur = Math.round((beats[index + 1] - time))
// 			const dur1 = Math.round(dur * AUDIO.ratio)
// 			const dur2 = dur - dur1
// 			const fade1 = Math.round(dur1 * 1)
// 			const fade2 = Math.round(dur2 * 1)
// 			let color1 = hexToIntString(AUDIO.color1)
// 			let color2 = hexToIntString(AUDIO.color2)
// 			if (AUDIO.swap && channel % 2) {
// 				return [
// 					`C ${start} ${dur1} ${fade1} ${color2}`,
// 					`C ${start + dur1} ${dur2} ${fade2} ${color1}`
// 				].join('\n')
// 			} else {
// 				return [
// 					`C ${start} ${dur1} ${fade1} ${color1}`,
// 					`C ${start + dur1} ${dur2} ${fade2} ${color2}`
// 				].join('\n')
// 			}
// 		}
// 	}).join('\n')
// 	seq += `E ${beats[beats.length-1]}`
// 	return seq
// }
// global.hexToIntString = function hexToIntString(hex) {
// 	hex = hex.replace(/[^0-9a-f]+/gi, '')
// 	return [
// 		parseInt(hex.slice(0, 2), 16),
// 		parseInt(hex.slice(2, 4), 16),
// 		parseInt(hex.slice(4, 6), 16)
// 	].join(' ')
// }

/***/ }),

/***/ "./app/js/color.js":
/*!*************************!*\
  !*** ./app/js/color.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./app/js/data.js":
/*!************************!*\
  !*** ./app/js/data.js ***!
  \************************/
/*! exports provided: CONFIG, AUDIO, LIGHT, SHOW, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUDIO", function() { return AUDIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LIGHT", function() { return LIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW", function() { return SHOW; });
// store hardware configs data
const CONFIG = {
  brightness: 255,
  channel: 0,
  show: 1,
  time: 0,
  running: 0,
  paused: 0,
  nodes: [],
  syncing: true
}; // store audio configs for current show

const AUDIO = {
  file: null,
  channels: [],
  duration: 0
};
const LIGHT = {
  file: null
};
const SHOW = {
  map: {},
  params: {},
  tracks: []
}; // store color data for current segment

global.color = {
  rgb: {
    r: 255,
    g: 0,
    b: 0
  },
  hsl: {
    h: 255,
    s: 0,
    l: 0
  }
};

global.updateRGB = function updateRGB() {
  const {
    h,
    s,
    l
  } = color.hsl;
  color.rgb = hslToRgb(h, s, l);
};

global.updateHSL = function updateHSL() {
  const {
    r,
    g,
    b
  } = color.rgb;
  color.hsl = rgbToHsl(r, g, b);
};

/* harmony default export */ __webpack_exports__["default"] = ({
  CONFIG,
  AUDIO,
  LIGHT,
  SHOW
});
Object.assign(global, {
  CONFIG,
  AUDIO,
  LIGHT,
  SHOW
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./app/js/events.js":
/*!**************************!*\
  !*** ./app/js/events.js ***!
  \**************************/
/*! exports provided: handleError, handleFile, handleChange, handleClick, handleDragDrop, handlePlay, handlePlaying, handlePause, handleStart, handleEnd, handleTimeSeeking, handleTimeSeeked, handleTimeUpdate, handleInit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleError", function() { return handleError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleFile", function() { return handleFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleChange", function() { return handleChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleClick", function() { return handleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleDragDrop", function() { return handleDragDrop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handlePlay", function() { return handlePlay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handlePlaying", function() { return handlePlaying; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handlePause", function() { return handlePause; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleStart", function() { return handleStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleEnd", function() { return handleEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleTimeSeeking", function() { return handleTimeSeeking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleTimeSeeked", function() { return handleTimeSeeked; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleTimeUpdate", function() { return handleTimeUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleInit", function() { return handleInit; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api */ "./app/js/api.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ "./app/js/app.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./app/js/data.js");
/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ "./app/js/ws.js");
/* harmony import */ var _action__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./action */ "./app/js/action.js");







const {
  parseAudio,
  renderAudio
} = __webpack_require__(/*! ./audio */ "./app/js/audio.js");

const {
  parseLSF,
  parseLTP,
  parseIPX,
  renderShow
} = __webpack_require__(/*! ./light */ "./app/js/light.js");

function handleError() {
  console.error(...arguments);
}
async function handleFile(file, event) {
  if (_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running) {
    Object(_api__WEBPACK_IMPORTED_MODULE_1__["call"])('#player', 'pause');
    Object(_api__WEBPACK_IMPORTED_MODULE_1__["setProp"])('#player', 'currentTime', 0);
    await handleEnd();
  }

  console.debug(`select file: ${file.name}`);

  if (file.name.endsWith('.bin')) {
    await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])('firmware/' + filename, file);
  } else if (file.name.endsWith('.ltp')) {
    const show = JSON.stringify(await parseLTP(file));
    await Object(_app__WEBPACK_IMPORTED_MODULE_2__["render"])();
    await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}.json`, show);
    await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}.mp3`, _data__WEBPACK_IMPORTED_MODULE_3__["AUDIO"].file);
  } else if (file.name.endsWith('.lsf')) {
    const data = await parseLSF(file);
    let target = event.target.closest('[data-device]');
    target && (target = target.dataset.device);

    if (target) {
      _data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].map[target] = file.name;
      await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`/show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}.json`, new Blob([JSON.stringify(_data__WEBPACK_IMPORTED_MODULE_3__["SHOW"])]));
    }

    for (let id in _data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].map) {
      if (_data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].map[id] == file.name) {
        if (data.length == 1) {
          await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`/show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}A.lsb`, new Blob(data[0]), true, id);
          await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`/show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}B.lsb`, new Blob(data[0]), true, id);
        } else if (data.length === 3) {
          await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`/show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}A.lsb`, new Blob(data[1]), true, id);
          await Object(_api__WEBPACK_IMPORTED_MODULE_1__["uploadFile"])(`/show/${_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show}B.lsb`, new Blob(data[2]), true, id);
        }
      }
    }
  } else if (file.name.endsWith('.ipx')) {
    await parseIPX(file);
  } else if (file.type.startsWith('audio')) {
    await parseAudio(file);
    await renderAudio();
  } else {
    console.error('unsupported file format');
  }
}
async function handleChange(e) {
  if (e.type === 'change' && e.target.id === 'select-file') {
    for (let file of e.target.files) {
      await handleFile(file);
    }
  }
}
async function handleClick(e) {
  const {
    show,
    action,
    command,
    bytes
  } = e.target.dataset;

  if (e.target.closest('[data-device]')) {
    const target = e.target.closest('[data-device]');
    _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].nodes.forEach(node => {
      if (node.id == target.dataset.device) {
        node.selected = !node.selected;
        if (node.selected) Object(_ws__WEBPACK_IMPORTED_MODULE_4__["send"])(node.id, 'BLINK', 5);else Object(_ws__WEBPACK_IMPORTED_MODULE_4__["send"])(node.id, 'BLINK', 0);
      }
    });
    Object(_app__WEBPACK_IMPORTED_MODULE_2__["renderNodes"])();
  }

  if (e.target.dataset.show) {
    Object(_app__WEBPACK_IMPORTED_MODULE_2__["selectShow"])(parseInt(e.target.dataset.show) || 0);
  }

  if (action) {
    if (typeof _action__WEBPACK_IMPORTED_MODULE_5__[action] !== 'function') {
      console.error(`ACTION ${action}() is undefined.`);
    } else {
      _action__WEBPACK_IMPORTED_MODULE_5__[action].call(e.target, e);
    }
  }

  if (e.target.dataset.command) {
    let rest = [];

    try {
      rest = eval(`[${e.target.dataset.body || ''}]`);
    } catch (e) {
      console.log(e);
    }

    Object(_api__WEBPACK_IMPORTED_MODULE_1__["sendCommand"])(e.target.dataset.command, ...rest);
  }
}

function handleDragOver(e) {
  e.preventDefault();
  const droppable = e.target.closest('[data-droppable]');

  if (droppable) {
    droppable.classList.add('active');
  }
}

function handleDragLeave(e) {
  e.preventDefault();
  const droppable = e.target.closest('[data-droppable]');

  if (droppable) {
    droppable.classList.remove('active');
  }
}

async function handleDragDrop(e) {
  e.preventDefault();

  for (let file of e.dataTransfer.files) {
    await handleFile(file, e);
  }
}
let scrolling = false;
let scrollEnded = 0;
const scrollStart = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
  if (Date.now() - scrollEnded > 10) {
    scrolling = true;
    if (_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running && !_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused) Object(_api__WEBPACK_IMPORTED_MODULE_1__["call"])('#player', 'pause');
  }
}, 300, {
  leading: true
});
const scrollEnd = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
  Object(_api__WEBPACK_IMPORTED_MODULE_1__["$"])('#player').forEach(player => {
    player.play();
  });
  scrolling = false;
  scrollEnded = Date.now();
}, 300, {
  trailing: true
});

function handleScroll(e) {
  if (_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running && e.target.closest('.timeline')) {
    scrollStart();
    Object(_api__WEBPACK_IMPORTED_MODULE_1__["$"])('.timeline').forEach(timeline => {
      const ratio = timeline.scrollLeft / (timeline.scrollWidth - timeline.offsetWidth);
      Object(_api__WEBPACK_IMPORTED_MODULE_1__["$"])('#player').forEach(player => {
        player.currentTime = _data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].params.end / 1000 * ratio;
      });
    });
    scrollEnd();
  }
}

let audio;
async function handlePlay(e) {
  // console.log('play')
  audio = e.target;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused = 0;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running = 1;
  Object(_app__WEBPACK_IMPORTED_MODULE_2__["renderHead"])();
  handleTimeUpdate(e);
}
async function handlePlaying(e) {
  console.log('playing');
  audio = e.target;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused = 0;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running = 1;
  Object(_app__WEBPACK_IMPORTED_MODULE_2__["renderHead"])();
  handleTimeUpdate(e);
}
async function handlePause(e) {
  console.log('paused');
  audio = e.target;

  if (e.target.currentTime === e.target.duration) {
    handleEnd(e);
  } else {
    _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused = 1;
    Object(_app__WEBPACK_IMPORTED_MODULE_2__["renderHead"])();
    handleTimeUpdate(e);
  }
}
async function handleStart() {
  console.log('start');
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running = 1;
  await Object(_api__WEBPACK_IMPORTED_MODULE_1__["sendCommand"])('begin');
  Object(_api__WEBPACK_IMPORTED_MODULE_1__["call"])('#player', 'play');
}
async function handleEnd() {
  console.log('ended');
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running = 0;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused = 0;
  _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].time = 0;
  Object(_api__WEBPACK_IMPORTED_MODULE_1__["sendCommand"])('end');
  Object(_app__WEBPACK_IMPORTED_MODULE_2__["renderHead"])();
  handleTimeUpdate();
}
async function handleTimeSeeking(e) {
  audio = e.target; // console.log('seeking')
}
async function handleTimeSeeked(e) {
  audio = e.target; // console.log('seeked')

  if (scrolling) return;
  const timeline = Object(_api__WEBPACK_IMPORTED_MODULE_1__["$"])('.timeline');

  if (timeline) {
    const ratio = e.currentTime / (_data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].params.end / 1000);
    $timeline.forEach(el => {
      el.scrollLeft = (el.scrollWidth - el.offsetWidth) * ratio;
      const $handle = el.querySelector('.handle');

      if ($handle) {
        $handle.style.left = Math.round(el.offsetWidth * ratio) + 'px';
        $handle.style.top = el.offsetTop + 'px';
        $handle.style.height = el.offsetHeight + 'px';
      }
    });
  }
}
async function handleTimeUpdate() {
  audio && Object(_api__WEBPACK_IMPORTED_MODULE_1__["setText"])('#time', Object(_api__WEBPACK_IMPORTED_MODULE_1__["formatTime"])(audio.currentTime));
}
setTimeout(async function sync() {
  if (audio && _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].syncing) {
    _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].time = Math.min(Math.round(audio.currentTime * 1000), _data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].params.end);
    await Object(_ws__WEBPACK_IMPORTED_MODULE_4__["sendSync"])();
  }

  setTimeout(sync, 100);
});
const $timeline = Object(_api__WEBPACK_IMPORTED_MODULE_1__["$"])('.timeline');
requestAnimationFrame(function draw() {
  if (audio && _data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].running && !_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].paused) {
    const ratio = audio.currentTime / (_data__WEBPACK_IMPORTED_MODULE_3__["SHOW"].params.end / 1000);
    handleTimeUpdate();
    $timeline.forEach(el => {
      el.scrollLeft = (el.scrollWidth - el.offsetWidth) * ratio;
      const $handle = el.querySelector('.handle');

      if ($handle) {
        $handle.style.left = Math.round(el.offsetWidth * ratio) + 'px';
        $handle.style.top = el.offsetTop + 'px';
        $handle.style.height = el.offsetHeight + 'px';
      } // el.style.transform = `translateX(-${ratio*100}%)`

    });
  }

  requestAnimationFrame(draw);
});
async function handleInit() {
  Object.assign(_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"], await Object(_api__WEBPACK_IMPORTED_MODULE_1__["get"])('stat'));
  setTimeout(() => Object(_app__WEBPACK_IMPORTED_MODULE_2__["selectShow"])(_data__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].show), 1000);
  setInterval(_app__WEBPACK_IMPORTED_MODULE_2__["checkNodes"], 1000);
}
window.addEventListener('mousewheel', handleScroll, true);
window.addEventListener('dragover', handleDragOver, true);
window.addEventListener('dragleave', handleDragLeave, true);
window.addEventListener('drop', handleDragDrop, true);
window.addEventListener('change', handleChange, true);
window.addEventListener('input', handleChange, true);
window.addEventListener('click', handleClick, true);
window.addEventListener('play', handlePlay, true);
window.addEventListener('pause', handlePause, true);
window.addEventListener('playing', handlePlaying, true);
window.addEventListener('timeupdate', handleTimeUpdate, true);
window.addEventListener('seeked', handleTimeSeeked, true);
window.addEventListener('seeking', handleTimeSeeking, true);
window.addEventListener('end', handleEnd, true);
window.addEventListener('touchstart', new Function(), true);
window.addEventListener('load', handleInit);

/***/ }),

/***/ "./app/js/index.js":
/*!*************************!*\
  !*** ./app/js/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log.js */ "./app/js/log.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_log_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./app/js/color.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_color_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ "./app/js/data.js");
/* harmony import */ var _app_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app.js */ "./app/js/app.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./api.js */ "./app/js/api.js");
/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./audio.js */ "./app/js/audio.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events.js */ "./app/js/events.js");








/***/ }),

/***/ "./app/js/light.js":
/*!*************************!*\
  !*** ./app/js/light.js ***!
  \*************************/
/*! exports provided: parseLTP, parseLSF, parseIPX, renderShow, renderLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseLTP", function() { return parseLTP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseLSF", function() { return parseLSF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseIPX", function() { return parseIPX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderShow", function() { return renderShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLight", function() { return renderLight; });
/* harmony import */ var unzip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unzip-js */ "./node_modules/unzip-js/src/index.js");
/* harmony import */ var unzip_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(unzip_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./app/js/data.js");


const led_nums = 36;
const rgbFrameRegex = /(\t+)?([0-9]+)ms: setrgb [AB]+ ([0-9]+)ms > ([0-9]+), ([0-9]+), ([0-9]+)/i;
const endFrameRegex = /(\t+)?([0-9]+)ms: end/i;
const loopFrameRegex = /([0-9]+)ms: loop ([0-9]+)ms/i;
async function parseLTP(file) {
  return new Promise(resolve => {
    $('.tracks').forEach(el => {
      el.width = '100%';
      el.innerHTML = '<div class="loading">loading...</div>';
    });
    unzip_js__WEBPACK_IMPORTED_MODULE_0___default()(file, (err, zip) => {
      if (err) reject(err);
      zip.readEntries((err, entries) => {
        if (err) reject(err);
        let ended = 0;
        entries.forEach(entry => {
          const {
            name
          } = entry;
          zip.readEntryData(entry, false, (err, stream) => {
            if (err) reject(err);
            let content = [];
            stream.on('data', data => {
              content.push(data);
            });
            stream.on('end', async () => {
              const file = new Blob(content);

              if (name == "project.lt3") {
                _data__WEBPACK_IMPORTED_MODULE_1__["LIGHT"].file = file;
                const reader = new FileReader();
                reader.readAsText(file);
                reader.addEventListener('loadend', () => {
                  const data = JSON.parse(reader.result);
                  SHOW.params = data.solution;
                  SHOW.tracks = data.tracks;
                });
              } else if (name.endsWith('.mp3')) {
                AUDIO.file = file;
              } else if (name.startsWith('images/')) {
                console.log(name);
              }

              if (++ended === entries.length) {
                resolve(SHOW);
              }
            });
          });
        });
      });
    });
  });
}
async function parseLSF(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.readAsText(file);

    reader.onload = () => {
      const output = {};
      const data = reader.result.match(/@?\w+[^@]+/mg).map(segment => {
        let id = 'AB';

        if (segment.startsWith('@')) {
          id = segment[1];
          segment = segment.substr(2);
        }

        return output[id] = segment.trim().split(/\r|\n|\r\n/).filter(line => {
          return !!line.match(/^[\t0-9]/);
        }).map(line => {
          let matched;

          if (matched = line.match(rgbFrameRegex)) {
            let [,, start, transition, r, g, b] = matched;
            return {
              type: 1,
              start,
              duration: 0,
              transition,
              r,
              g,
              b
            };
          } else if (matched = line.match(endFrameRegex)) {
            let [,, start] = matched;
            return {
              type: 2,
              start
            };
          } else if (matched = line.match(loopFrameRegex)) {
            let [, start, duration] = matched;
            return {
              type: 3,
              start,
              duration,
              frames: []
            };
          } else {
            return {};
          }
        }).map(({
          start = 0,
          duration = 0,
          transition = 0,
          type = 0,
          r = 0,
          g = 0,
          b = 0
        }, index, lines) => {
          const frame = new Uint8Array(16);
          const view = new DataView(frame.buffer);

          if (type === 1 && lines[index + 1]) {
            duration = lines[index + 1].start - start;
          }

          view.setUint8(0, type, true);
          view.setUint8(1, r, true);
          view.setUint8(2, g, true);
          view.setUint8(3, b, true);
          view.setUint32(4, start, true);
          view.setUint32(8, duration, true);
          view.setUint32(12, transition, true); // let hex = ''
          // frame.forEach(byte => (hex += (byte.toString(16).padStart(2, '0') + ' ')))
          // console.log(hex)

          return frame;
        });
      });
      resolve(data);
    };
  });
}
async function parseIPX(file) {
  const output = {
    images: [],
    sequences: []
  };
  const reader = new FileReader();
  reader.readAsText(file);

  reader.onload = () => {
    const frame = document.createElement('iframe');
    frame.srcdoc = reader.result.toString();

    frame.onload = () => {
      const doc = frame.contentDocument;
      doc.querySelectorAll('Item').forEach(item => {
        const index = parseInt(item.getAttribute('Index'));
        const type = item.getAttribute('Type');

        switch (type) {
          case 'Img':
            const data = item.childNodes[0].nodeValue.replace(/\[CDATA\[(.*)\]\]/, '$1');
            const uploadPath = `/img/${index}`;
            let img = output.images[index] = new Image();
            img.src = `data:img/png;base64,${data}`;

            img.onload = () => {
              // SCALE AND ROTATE IMAGE
              const scale = led_nums / img.height;
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              document.body.appendChild(canvas);
              canvas.width = img.height;
              canvas.height = img.width;
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = '#000000';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.save();
              ctx.translate(img.height / 2, img.width / 2);
              ctx.rotate(90 * Math.PI / 180);
              ctx.drawImage(img, -img.width / 2, -img.height / 2);
              ctx.restore();
              img = new Image();

              img.onload = () => {
                const width = canvas.width = led_nums;
                const height = canvas.height = canvas.height * scale;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const rgb = new Uint8ClampedArray(ctx.getImageData(0, 0, width, height).data.reduce((output, b, i) => {
                  if ((i + 1) % 4 !== 0) {
                    output.push(b);
                  }

                  return output;
                }, []));
                const blob = new Blob([rgb]); // UPLOAD ASSETS

                const form = new FormData();
                form.append('filename', uploadPath);
                form.append('file', blob);
                const req = new XMLHttpRequest();
                req.open('POST', 'edit', true);
                req.send(form);

                req.onloadend = e => {
                  console.debug('Upload completed.');
                };
              };

              img.src = canvas.toDataURL();
            };

            break;

          case 'Seq':
            const length = parseInt(item.getAttribute('Length'));
            output.sequences[index] = new Array(length);

            for (let i = 0; i < length; i++) {
              const child = item.querySelector(`Data${i}`);
              const image = parseInt(child.getAttribute('Index'));
              const duration = parseInt(child.getAttribute('Duration'));
              output.sequences[index][i] = {
                image,
                duration
              };
            }

            break;
        }
      });
      document.body.removeChild(frame);
    };

    document.body.appendChild(frame);
  };
}
function renderShow() {
  $('.tracks').forEach($tracks => {
    $tracks.innerHTML = '';
    $tracks.style.width = SHOW.params.end / 10 + 'px';
    SHOW.tracks.forEach(track => {
      const $track = document.createElement('div');
      const {
        elements,
        ...params
      } = track;
      $track.classList.add('track');
      Object.assign($track.dataset, params);
      $tracks.appendChild($track);
      renderLight($track, track);
    });
  });
}
function renderLight(container, track) {
  switch (track.device) {
    case 1:
      container.style.height = '15px';
      break;

    case 2:
      container.style.height = '15px';
      break;

    default:
      return console.log('unsupported device type:', track.device);
  }

  track.elements.forEach(el => {
    const $el = document.createElement('span');
    let {
      color,
      colorStart,
      colorEnd,
      ...params
    } = el;
    Object.assign($el.dataset, params);
    const start = params.startTime;
    const duration = params.endTime - el.startTime;
    if (color) color = convertColor(color);
    if (colorStart) colorStart = convertColor(colorStart);
    if (colorEnd) colorEnd = convertColor(colorEnd);
    $el.style.left = `${start / 10}px`;
    $el.style.width = `${duration / 10}px`;
    let color1, color2;

    switch (params.type) {
      case 2:
        // solid
        $el.style.backgroundColor = toCssColor(color);
        break;

      case 3:
        // gradient
        color1 = toCssColor(colorStart);
        color2 = toCssColor(colorEnd);
        $el.style.background = `linear-gradient(90deg, ${color1} 0%, ${color2} 100%)`;
        break;

      case 4:
        // flash
        color1 = toCssColor(colorStart);
        color2 = toCssColor(colorEnd);
        const {
          period,
          ratio
        } = params;
        $el.style.backgroundImage = `url(${drawFlash(color1, color2, period, ratio)})`; // $el.style.backgroundSize = '20%'

        break;

      case 5:
        // rainbow
        $el.style.backgroundImage = `url(${drawRainbow(params.period)})`; // $el.style.backgroundSize = '20%'
        // $el.style.backgroundImage = `linear-gradient(to right, red, orange , yellow, green, cyan, blue, violet)`

        break;

      case 6:
        // dots
        $el.style.backgroundImage = `url(${drawDots(toCssColor(color), params.spacing)})`; // $el.style.backgroundSize = '20%'

        break;

      case 7:
        // pulse
        $el.style.backgroundImage = `url(${drawPulse(toCssColor(color), params.period)})`; // $el.style.backgroundSize = '20%'

        break;

      default:
        console.log("unhandled light type:", params.type);
    }

    container.appendChild($el);
  });
}

function convertColor({
  r,
  g,
  b
}) {
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

function toCssColor({
  r,
  g,
  b
}) {
  return `rgb(${r}, ${g}, ${b})`;
}

function toCssHSL({
  h,
  s,
  l
}) {
  return `hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
}

const tmpCanvas = document.createElement('canvas');

function drawFlash(color1, color2, period, ratio) {
  tmpCanvas.width = period;
  tmpCanvas.height = 1;
  const ctx = tmpCanvas.getContext('2d');
  const len1 = period * (ratio / 100);
  const len2 = period * ((100 - ratio) / 100);
  ctx.fillStyle = color1;
  ctx.fillRect(0, 0, len1, 1);
  ctx.fillStyle = color2;
  ctx.fillRect(len1, 0, len2, 1);
  return tmpCanvas.toDataURL();
}

function drawDots(color, spacing) {
  tmpCanvas.width = spacing + 2;
  tmpCanvas.height = 1;
  const ctx = tmpCanvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, 1, 1);
  ctx.fillStyle = 'black';
  ctx.fillRect(1, 0, 1, 1);
  return tmpCanvas.toDataURL();
}

function drawPulse(color, period) {
  tmpCanvas.width = period;
  tmpCanvas.height = 1;
  const ctx = tmpCanvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, period, 1);
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, 24, 1);
  ctx.fillStyle = 'white';
  ctx.fillRect(12, 0, 2, 1);
  return tmpCanvas.toDataURL();
}

function drawRainbow(period) {
  tmpCanvas.width = period;
  tmpCanvas.height = 1;
  const ctx = tmpCanvas.getContext('2d');
  var gradient = ctx.createLinearGradient(0, 0, period, 0);
  gradient.addColorStop(1 / 6 * 0, 'red');
  gradient.addColorStop(1 / 6 * 1, 'orange');
  gradient.addColorStop(1 / 6 * 2, 'yellow');
  gradient.addColorStop(1 / 6 * 3, 'green');
  gradient.addColorStop(1 / 6 * 4, 'cyan');
  gradient.addColorStop(1 / 6 * 5, 'blue');
  gradient.addColorStop(1 / 6 * 6, 'violet');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, period, 1);
  return tmpCanvas.toDataURL();
}

/***/ }),

/***/ "./app/js/log.js":
/*!***********************!*\
  !*** ./app/js/log.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

document.head.innerHTML += `<style>

x-console main {
	padding: 0;
	margin: 0;
}
x-console {
	z-index: 2000;
	display: block;
	position: fixed;
	bottom: 0;
	right: 0;
	left: 0;
	
	background: #020202c9;
	border: 10px solid #020202c9;
	
	box-sizing: content-box;
	max-height: 50px;
	overflow: auto;
}
x-console input,
x-console output,
x-console span {
	user-select: text;
	font-family: menlo;
	font-size: 12px;
	line-height: 1.5em;
}
x-console input,
x-console span {
	height: 1.5em;
}
x-console input,
x-console output {
	display: block;
	margin: 0;
	padding: 0;
	border: none;
	background: none;
	outline: none;
	white-space: pre !important;
	color: #fff;
	text-align: left;
}
x-console line {
	display: grid;
	grid-template-columns: 20px auto;
}
x-console line span,
x-console line output {
	color: lightgrey;
}
x-console line.debug * {
	color: lightgreen;
}
x-console line.info * {
	color: skyblue;
}
x-console line.warn * {
	color: yellow;
}
x-console line.error * {
	color: orangered;
}
x-console line.input * {
	color: white;
}
x-console line.input {
	display: none;
}
</style>`;

class ConsoleElement {
  constructor() {
    this.el = document.createElement('x-console');
    this.el.innerHTML = `
		<main></main>
		<line class="input">
			<span>#</span>
			<input type="text" />
		</line>
		`;
    this.main = this.el.querySelector('main');
    this.input = this.el.querySelector('input');
    this.input.addEventListener('keydown', this.handleKeydown.bind(this));
  }

  handleKeydown(e) {
    if (e.key === 'Enter') {
      this.push('#', '', e.target.value);

      try {
        this.push('•', 'info', String(eval(e.target.value)));
      } catch (err) {
        this.push('•', 'error', err.stack);
      }

      e.target.value = '';
      e.target.focus();
    }
  }

  push(icon, type, ...args) {
    const line = document.createElement('line');
    type && line.classList.add(type);
    line.innerHTML = `<span>${icon}</span><output></output>`;
    const output = line.querySelector('output');
    output.innerText = args.join(' ');
    this.lastOutput = output;
    this.main.appendChild(line);
    this.el.scrollTop = this.el.scrollHeight;
    return output;
  }

}

const logger = new ConsoleElement();
document.body.appendChild(logger.el);
const original = {};

for (let key in console) {
  original[key] = console[key];
}

window.console.log = (...args) => {
  original.log(...args);
  return logger.push('•', 'log', ...args);
};

window.console.debug = (...args) => {
  original.debug(...args);
  return logger.push('•', 'debug', ...args);
};

window.console.info = (...args) => {
  original.info(...args);
  return logger.push('•', 'info', ...args);
};

window.console.warn = (...args) => {
  original.warn(...args);
  return logger.push('•', 'warn', ...args);
};

window.console.error = (...args) => {
  original.error(...args);
  return logger.push('•', 'error', ...args);
};

window.console.append = (...args) => {
  if (logger.lastOutput) {
    logger.lastOutput.innerHTML = `${logger.lastOutput.innerHTML}${args.join(' ')}`;
  }
};

/***/ }),

/***/ "./app/js/ws.js":
/*!**********************!*\
  !*** ./app/js/ws.js ***!
  \**********************/
/*! exports provided: sendFile, sendSync, equals, readStr, print, send */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendFile", function() { return sendFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendSync", function() { return sendSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readStr", function() { return readStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "send", function() { return send; });
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ "./app/js/app.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data */ "./app/js/data.js");



let socket;
let fsResponsed;

(function createSocket() {
  console.log('SOCKET initialize ...');
  socket = new WebSocket(`ws://${location.hostname}:81`);
  socket.binaryType = 'arraybuffer';
  socket.addEventListener('message', async e => {
    if (typeof e.data === 'string') {// handleMessage(e.data)
    }

    if (e.data instanceof ArrayBuffer) {
      let changed = false;
      let view = new DataView(e.data);
      const id = readStr(view, 6, 0);

      if (readStr(view, 1, 6) !== '<') {
        console.warn("wrong format XXXXXX<CMD...");
      } else if (equals('<PING', view, 6)) {
        const n1 = {
          id,
          type: view.getUint8(11),
          vbat: view.getUint16(12),
          name: readStr(view, 20, 14),
          hidden: false,
          lastUpdated: Date.now()
        };
        let exist = false;
        _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].nodes.forEach(n2 => {
          if (n1.id == n2.id) {
            if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(n1, n2)) {
              Object.assign(n2, n1);
              changed = true;
            }

            exist = true;
          }
        });
        if (!exist) _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].nodes.push(n1);
      } else {
        _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].nodes.forEach(node => {
          if (id == node.id) {
            view = new DataView(e.data.slice(7));

            if (equals('SELECT', view)) {
              node.selected = !node.selected;
              node.lastUpdated = Date.now();
              changed = true;
              if (node.selected) send(node.id, 'BLINK', 5);else send(node.id, 'BLINK', 0);
            }
          }
        });
      }

      if (changed) Object(_app__WEBPACK_IMPORTED_MODULE_1__["renderNodes"])();
    }
  });
  socket.addEventListener('close', () => {
    setTimeout(createSocket, 1000);
  });
  socket.addEventListener('open', () => {});
  window.socket = socket;
})();

async function waitFileResponse(timeout = 1000) {
  const expired = Date.now + 1000;
  fsResponsed = false;
  return new Promise((resolve, reject) => {
    setTimeout(function check() {
      if (fsResponsed) resolve();else if (Date.now() > expired) reject();else setTimeout(check, 1);
    });
  });
}

async function sendFile(target, path, file) {
  await send(target, 'FS1' + path);
  await waitFileResponse();
  console.log('file send open');
  const reader = new FileReader();
  reader.readAsArrayBuffer(file);
  reader.addEventListener('loadend', async e => {
    let offset = 0;
    const buf = e.target.result;

    while (offset < buf.byteLength) {
      console.log('file sent chunk');
      const size = Math.min(buf.byteLength - offset, 240);
      await send(target, 'FS2', ...new Uint8Array(buf.slice(offset, size)));
      await waitFileResponse();
      offset += 240;
    }

    await send(target, 'FS3');
    await waitFileResponse();
    console.log('file send done');
  });
}
async function sendSync() {
  const payload = new Uint8Array(13);
  const view = new DataView(payload.buffer);
  print(view, '#>SYNC', 0);
  view.setUint8(6, _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].show);
  view.setUint8(7, _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].running);
  view.setUint8(8, _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].paused);
  view.setUint32(9, _data__WEBPACK_IMPORTED_MODULE_2__["CONFIG"].time);
  socket.send(payload.buffer);
}
function equals(text = '', view, offset = 0) {
  return text.split('').every((c, i) => {
    return c == String.fromCharCode(view.getUint8(i + offset));
  });
}
function readStr(view, size, offset = 0) {
  let output = '';
  let byte;

  for (let i = 0; i < size; i++) {
    byte = view.getUint8(i + offset);

    if (byte >= 30 && byte < 127) {
      output += String.fromCharCode(byte);
    }
  }

  return output;
}
function print(view, str, pos = 0) {
  let offset = pos;
  str.split('').map((c, i) => {
    offset = i + pos;
    view.setUint8(offset, c.charCodeAt(0));
  });
  return offset + 1;
}
async function send(target = '#', header = '', ...payload) {
  const targetBytes = target.split('').map(c => c.charCodeAt(0));
  const headerBytes = header.split('').map(c => c.charCodeAt(0));
  socket.send(new Uint8Array([...targetBytes, 62, ...headerBytes, ...payload]));
} // const debounceGetNodes = debounce(async function () {
// 	CONFIG.nodes = await get('nodes')
// 	renderNodes()
// }, 100)
// let isRunning = false;
// let isPaused = false;
//  async function handleMessage(msg) {
// 	// console.log(`SOCKET:: `, msg)
// 	if (msg.startsWith('#<PING')) {
// 		debounceGetNodes()
// 	}
// 	else if (msg.startsWith('#>SYNC')) {
// 		const [, a, b, c] = msg.split(':')
// 		const time = parseInt(a) / 10
// 		const running = !!parseInt(b)
// 		const paused = !!parseInt(c)
// 		if (isPaused !== paused) {
// 			isPaused = paused
// 			if (paused) {
// 				setAttr('#pause', 'data-command', 'resume')
// 				setText('#pause', 'RESUME')
// 				call('#player', 'pause')
// 			} else {
// 				setAttr('#pause', 'data-command', 'pause')
// 				setText('#pause', 'PAUSE')
// 				call('#player', 'play')
// 			}
// 		}
// 		if (isRunning !== running) {
// 			isRunning = running
// 			if (running) {
// 				setAttr('#play', 'data-command', 'end')
// 				setText('#play', 'STOP')
// 				setProp('#player', 'currentTime', 0)
// 				call('#player', 'play')
// 			} else {
// 				setAttr('#play', 'data-command', 'start')
// 				setText('#play', 'PLAY')
// 				call('#player', 'pause')
// 				setProp('#player', 'currentTime', 0)
// 			}
// 		}
// 	}
// }
// export async function sendFile(file, receivers = []) {
// 	const reader = new FileReader
// 	reader.readAsArrayBuffer(file)
// 	reader.addEventListener('loadend', async e => {
// 		const buf = e.target.result
// 		const view = new DataView(buf)
// 		// Begin file stream
// 		if (!receivers.length) {
// 			await send('#>FILE^')
// 		} else {
// 			while (receivers.length) {
// 				let id = receivers.pop()
// 				await send('#>FILE^' + id)
// 			}
// 		}
// 		// file content stream
// 		let offset = 0
// 		while (offset < buf.byteLength) {
// 			let len = Math.min(buf.byteLength - offset, 240)
// 			let payload = buf.slice(offset, len)
// 			send(new Blob(['#>FILE+', payload]))
// 			offset += len
// 		}
// 		// file end
// 	})
// }

Object.assign(global, {
  send,
  sendSync
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js"); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }

  return !!(b != null && b._isBuffer);
} // based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


var util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");

var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;

var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


var assert = module.exports = ok; // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}; // assert.AssertionError instanceof Error


util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}

assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
}; // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
}; // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
}; // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
}; // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
}; // Expose a strict only variant of assert


function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/blob-slicer/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/blob-slicer/src/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var ReadStream = __webpack_require__(/*! ./read-stream */ "./node_modules/blob-slicer/src/read-stream.js");

module.exports = BlobSlicer;

function BlobSlicer(blob) {
  if (!(this instanceof BlobSlicer)) return new BlobSlicer(blob);
  if (!(blob instanceof Blob || ['[object Blob]', '[object File]'].indexOf(Object.prototype.toString.call(blob)) !== -1)) throw new TypeError('"blob" argument must be an instance of Blob or File');
  this._blob = blob;
}

BlobSlicer.prototype.read = function (start, end, cb) {
  if (typeof start === 'function') cb = start;else if (typeof end === 'function') {
    cb = end;
    end = this._blob.size;
  }
  if (typeof cb !== 'function') throw new TypeError('"callback" argument must be a function');
  start = ~~start;
  end = end === undefined ? this._blob.size : ~~end;
  var reader = new FileReader();
  reader.addEventListener('loadend', function onLoadend() {
    this.removeEventListener('loadend', onLoadend);
    cb(this.error, this.result ? Buffer.from(this.result) : null);
  });
  reader.readAsArrayBuffer(this._blob.slice(start, end));
};

BlobSlicer.prototype.createReadStream = function (options) {
  return new ReadStream(this._blob, options);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/blob-slicer/src/read-stream.js":
/*!*****************************************************!*\
  !*** ./node_modules/blob-slicer/src/read-stream.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var Readable = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js").Readable;

module.exports = ReadStream;

function ReadStream(blob, options) {
  if (!options) options = {};
  if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
  Readable.call(this, options);
  var start = ~~options.start;
  var end = options.end === undefined ? blob.size : ~~options.end;
  this._blob = blob.slice(start, end);
  this._end = this._blob.size;
  this._pos = 0;
  this._reader = new FileReader();
  var self = this;

  this._loadendListener = function () {
    if (this.error) {
      self.destroy(this.error);
      return;
    }

    self._pos += this.result.byteLength;
    self.push(Buffer.from(this.result));
  };

  this._reader.addEventListener('loadend', this._loadendListener);

  this.on('end', function () {
    this.destroy();
  });
}

ReadStream.prototype = Object.create(Readable.prototype);
ReadStream.prototype.constructor = ReadStream;
Object.defineProperties(ReadStream.prototype, {
  readableLength: {
    get: function () {
      return this._readableState.length;
    }
  },
  ended: {
    get: function () {
      return this._pos >= this._end;
    }
  }
});

ReadStream.prototype._read = function (n) {
  if (this.destroyed) return;

  if (this.ended) {
    this.push(null);
    return;
  }

  this._reader.readAsArrayBuffer(this._blob.slice(this._pos, this._pos + n));
};

ReadStream.prototype._destroy = function (err, cb) {
  cb(err);
  if (this._reader.readyState === FileReader.LOADING) this._reader.abort();

  this._reader.removeEventListener('loadend', this._loadendListener);

  this._reader = null;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-zlib/lib/binding.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-zlib/lib/binding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, process) {
/* eslint camelcase: "off" */

var assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");

var Zstream = __webpack_require__(/*! pako/lib/zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var zlib_deflate = __webpack_require__(/*! pako/lib/zlib/deflate.js */ "./node_modules/pako/lib/zlib/deflate.js");

var zlib_inflate = __webpack_require__(/*! pako/lib/zlib/inflate.js */ "./node_modules/pako/lib/zlib/inflate.js");

var constants = __webpack_require__(/*! pako/lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

for (var key in constants) {
  exports[key] = constants[key];
} // zlib modes


exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;
var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;
/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */

function Zlib(mode) {
  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;
  assert(this.init_done, 'close before init');
  assert(this.mode <= exports.UNZIP);

  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
    zlib_inflate.inflateEnd(this.strm);
  }

  this.mode = exports.NONE;
  this.dictionary = null;
};

Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  assert.equal(arguments.length, 8);
  assert(this.init_done, 'write before init');
  assert(this.mode !== exports.NONE, 'already finalized');
  assert.equal(false, this.write_in_progress, 'write already in progress');
  assert.equal(false, this.pending_close, 'close is pending');
  this.write_in_progress = true;
  assert.equal(false, flush === undefined, 'must provide flush value');
  this.write_in_progress = true;

  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }

    return;
  } // async version


  var self = this;
  process.nextTick(function () {
    self._process();

    self._after();
  });
  return this;
};

Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false;
  return [avail_in, avail_out];
};

Zlib.prototype._process = function () {
  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflate(this.strm, this.flush);
      break;

    case exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = exports.INFLATE;
            break;
          }

        // fallthrough

        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = exports.INFLATE;
          }

          break;

        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      this.err = zlib_inflate.inflate(this.strm, this.flush // If data was encoded with dictionary
      );

      if (this.err === exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);

        if (this.err === exports.Z_OK) {
          // And try to decode again
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        } else if (this.err === exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = exports.Z_NEED_DICT;
        }
      }

      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.
        this.reset();
        this.err = zlib_inflate.inflate(this.strm, this.flush);
      }

      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case exports.Z_OK:
    case exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
        this._error('unexpected end of file');

        return false;
      }

      break;

    case exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;

    case exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }

      return false;

    default:
      // something else.
      this._error('Zlib error');

      return false;
  }

  return true;
};

Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false; // call the write() cb

  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }

  this.onerror(message, this.err // no hope of rescue.
  );
  this.write_in_progress = false;

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');
  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  assert(level >= -1 && level <= 9, 'invalid compression level');
  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');
  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);

  this._setDictionary();
};

Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

Zlib.prototype.reset = function () {
  this._reset();

  this._setDictionary();
};

Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;
  this.flush = exports.Z_NO_FLUSH;
  this.err = exports.Z_OK;

  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new Zstream();

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

Zlib.prototype._reset = function () {
  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
    case exports.GZIP:
      this.err = zlib_deflate.deflateReset(this.strm);
      break;

    case exports.INFLATE:
    case exports.INFLATERAW:
    case exports.GUNZIP:
      this.err = zlib_inflate.inflateReset(this.strm);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

exports.Zlib = Zlib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/browserify-zlib/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-zlib/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform;

var binding = __webpack_require__(/*! ./binding */ "./node_modules/browserify-zlib/lib/binding.js");

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js").ok;

var kMaxLength = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").kMaxLength;

var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.

binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.

binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = 16 * 1024;
binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;
binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants

var bkeys = Object.keys(binding);

for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];

  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true,
      value: binding[bkey],
      writable: false
    });
  }
} // translation table for return codes.


var codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};
var ckeys = Object.keys(codes);

for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, 'codes', {
  enumerable: true,
  value: Object.freeze(codes),
  writable: false
});
exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function (o) {
  return new Deflate(o);
};

exports.createInflate = function (o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function (o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function (o) {
  return new InflateRaw(o);
};

exports.createGzip = function (o) {
  return new Gzip(o);
};

exports.createGunzip = function (o) {
  return new Gunzip(o);
};

exports.createUnzip = function (o) {
  return new Unzip(o);
}; // Convenience methods.
// compress/decompress a string or buffer in one step.


exports.deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();

  function flow() {
    var chunk;

    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }

    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = Buffer.from(buffer);
  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
  var flushFlag = engine._finishFlushFlag;
  return engine._processChunk(buffer, flushFlag);
} // generic zlib
// minimal 2-byte header


function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
} // gzip - bigger header, same deflate compression


function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
} // raw - no header


function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
} // auto-detect header.


function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}

function isValidFlushFlag(flag) {
  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
} // the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.


function Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
  Transform.call(this, opts);

  if (opts.flush && !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }

  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);
  var self = this;
  this._hadError = false;

  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);

    self._hadError = true;
    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;
  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;
  this.once('end', this.close);
  Object.defineProperty(this, '_closed', {
    get: function () {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function (level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }

  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function () {
      assert(self._handle, 'zlib binding closed');

      self._handle.params(level, strategy);

      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
}; // This is the _flush function called by the transform class,
// internally, when the last chunk has been written.


Zlib.prototype._flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
};

Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
};

Zlib.prototype.close = function (callback) {
  _close(this, callback);

  process.nextTick(emitCloseNT, this);
};

function _close(engine, callback) {
  if (callback) process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).

  if (!engine._handle) return;

  engine._handle.close();

  engine._handle = null;
}

function emitCloseNT(self) {
  self.emit('close');
}

Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);
  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));
  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.

  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.

    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;
  var self = this;
  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;
    var error;
    this.on('error', function (er) {
      error = er;
    });
    assert(this._handle, 'zlib binding closed');

    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len

    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= kMaxLength) {
      _close(this);

      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);

    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');

  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len


  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;
    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);

      self._offset += have; // serve some output to the consumer.

      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    } // exhausted the output buffer, or used all the input create a new one.


    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;
      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);

      newReq.callback = callback; // this same function

      newReq.buffer = chunk;
      return;
    }

    if (!async) return false; // finished with the chunk.

    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/buffer-crc32/index.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-crc32/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

var CRC_TABLE = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI = typeof Buffer.alloc === "function" && typeof Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);

  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }

  var crc = ~~previous ^ -1;

  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ crc >>> 8;
  }

  return crc ^ -1;
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}

crc32.signed = function () {
  return _crc32.apply(null, arguments);
};

crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEqual.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEqual.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */


function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */


var now = function () {
  return root.Date.now();
};

module.exports = now;

/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}; // reduce buffer size, avoiding mem copy


exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var trees = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var msg = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */


var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/* The deflate compression method */

var Z_DEFLATED = 8;
/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

var BS_BLOCK_DONE = 2;
/* block flush performed */

var BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

var BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


function flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  utils.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  var scan = s.strstart;
  /* current string */

  var match;
  /* matched string */

  var len;
  /* length of current match */

  var best_len = s.prev_length;
  /* best match length so far */

  var nice_match = s.nice_match;
  /* stop if match long enough */

  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      fill_window(s);

      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


function deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    if (hash_head !== 0
    /*NIL*/
    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


function deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  var bflush;
  /* set if current block must be flushed */

  var max_insert;
  /* Process the input block. */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    ) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


function deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  var prev;
  /* byte at distance one to match */

  var scan, strend;
  /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);

      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    s.match_length = 0;

    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


function deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);

      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;
configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored),
/* 0 store only */
new Config(4, 4, 8, 4, deflate_fast),
/* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast),
/* 2 */
new Config(4, 6, 32, 32, deflate_fast),
/* 3 */
new Config(4, 4, 16, 16, deflate_slow),
/* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow),
/* 5 */
new Config(8, 16, 128, 128, deflate_slow),
/* 6 */
new Config(8, 32, 128, 256, deflate_slow),
/* 7 */
new Config(32, 128, 258, 1024, deflate_slow),
/* 8 */
new Config(32, 258, 258, 4096, deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

function lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  this.status = 0;
  /* as the name implies */

  this.pending_buf = null;
  /* output still pending */

  this.pending_buf_size = 0;
  /* size of pending_buf */

  this.pending_out = 0;
  /* next pending byte to output to the stream */

  this.pending = 0;
  /* nb of bytes in the pending buffer */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.gzhead = null;
  /* gzip header information to write */

  this.gzindex = 0;
  /* where in extra, name, or comment */

  this.method = Z_DEFLATED;
  /* can only be DEFLATED */

  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  this.w_mask = 0;
  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;
  /* Heads of the hash chains or NIL. */

  this.ins_h = 0;
  /* hash index of string to be inserted */

  this.hash_size = 0;
  /* number of elements in hash table */

  this.hash_bits = 0;
  /* log2(hash_size) */

  this.hash_mask = 0;
  /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;
  /* length of best match */

  this.prev_match = 0;
  /* previous match */

  this.match_available = 0;
  /* set if previous match exists */

  this.strstart = 0;
  /* start of string to insert */

  this.match_start = 0;
  /* start of matching string */

  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;
  /* compression level (1..9) */

  this.strategy = 0;
  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  this.d_desc = null;
  /* desc. for distance tree */

  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  this.heap = new utils.Buf16(2 * L_CODES + 1);
  /* heap used to build the Huffman trees */

  zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;
  /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;
  /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  this.static_len = 0;
  /* bit length of current block with static trees */

  this.matches = 0;
  /* number of string matches in current block */

  this.insert = 0;
  /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)

  s.last_flush = Z_NO_FLUSH;

  trees._tr_init(s);

  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);

  if (ret === Z_OK) {
    lm_init(strm.state);
  }

  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }

  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }

  if (s.status === NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }

  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }

  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  if (s.pending !== 0) {
    flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }

    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */


        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        return Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  if (flush !== Z_FINISH) {
    return Z_OK;
  }

  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  /* Write the trailer */


  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);

  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';
/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js

var BAD = 30;
/* got a data error -- remain here until reset */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

module.exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  var last;
  /* have enough input while in < last */

  var _out;
  /* local strm.output */


  var beg;
  /* inflate()'s initial strm.output */

  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  var dmax;
  /* maximum distance from zlib header */
  //#endif

  var wsize;
  /* window size or zero if not using window */

  var whave;
  /* valid bytes in the window */

  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  var s_window;
  /* allocated sliding window, if wsize != 0 */

  var hold;
  /* local strm.hold */

  var bits;
  /* local strm.bits */

  var lcode;
  /* local strm.lencode */

  var dcode;
  /* local strm.distcode */

  var lmask;
  /* mask for first level of length codes */

  var dmask;
  /* mask for first level of distance codes */

  var here;
  /* retrieved table entry */

  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  var len;
  /* match length, unused bytes */

  var dist;
  /* match distance */

  var from;
  /* where to copy match from */

  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  state = strm.state; //here = state.here;

  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  dmax = state.dmax; //#endif

  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            } //#endif


            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            op = _out - beg;
            /* max distance in output */

            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var inflate_fast = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");

var inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

var Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

var HEAD = 1;
/* i: waiting for magic header */

var FLAGS = 2;
/* i: waiting for method and flags (gzip) */

var TIME = 3;
/* i: waiting for modification time (gzip) */

var OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

var EXLEN = 5;
/* i: waiting for extra length (gzip) */

var EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

var NAME = 7;
/* i: waiting for end of file name (gzip) */

var COMMENT = 8;
/* i: waiting for end of comment (gzip) */

var HCRC = 9;
/* i: waiting for header crc (gzip) */

var DICTID = 10;
/* i: waiting for dictionary check value */

var DICT = 11;
/* waiting for inflateSetDictionary() call */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

var TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

var STORED = 14;
/* i: waiting for stored size (length and complement) */

var COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

var COPY = 16;
/* i/o: waiting for input or output to copy stored block */

var TABLE = 17;
/* i: waiting for dynamic block table lengths */

var LENLENS = 18;
/* i: waiting for code length code lengths */

var CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

var LEN_ = 20;
/* i: same as LEN below, but only first time in */

var LEN = 21;
/* i: waiting for length/lit/eob code */

var LENEXT = 22;
/* i: waiting for length extra bits */

var DIST = 23;
/* i: waiting for distance code */

var DISTEXT = 24;
/* i: waiting for distance extra bits */

var MATCH = 25;
/* o: waiting for output space to copy string */

var LIT = 26;
/* o: waiting for output space to write literal */

var CHECK = 27;
/* i: waiting for 32-bit check value */

var LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

var DONE = 29;
/* finished check, done -- remain here until reset */

var BAD = 30;
/* got a data error -- remain here until reset */

var MEM = 31;
/* got an inflate() memory error -- remain here until reset */

var SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0;
  /* current inflate mode */

  this.last = false;
  /* true if processing last block */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.havedict = false;
  /* true if dictionary provided */

  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  this.check = 0;
  /* protected copy of check value */

  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  this.wbits = 0;
  /* log base 2 of requested window size */

  this.wsize = 0;
  /* window size or zero if not using window */

  this.whave = 0;
  /* valid bytes in the window */

  this.wnext = 0;
  /* window write index */

  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  this.hold = 0;
  /* input bit accumulator */

  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  this.length = 0;
  /* literal or length of data to copy */

  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  this.lencode = null;
  /* starting table for length/literal codes */

  this.distcode = null;
  /* starting table for distance codes */

  this.lenbits = 0;
  /* index bits for lencode */

  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  this.ncode = 0;
  /* number of code length code lengths */

  this.nlen = 0;
  /* number of length code lengths */

  this.ndist = 0;
  /* number of distance code lengths */

  this.have = 0;
  /* number of code lengths in lens[] */

  this.next = null;
  /* next available space in codes[] */

  this.lens = new utils.Buf16(320);
  /* temporary storage for code lengths */

  this.work = new utils.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  this.sane = 0;
  /* if false, allow invalid distance too far */

  this.back = 0;
  /* bits back of last unprocessed length/lit */

  this.was = 0;
  /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = inflateReset2(strm, windowBits);

  if (ret !== Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */


var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    /* literal/length table */

    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  var next;
  /* next input INDEX */

  var put;
  /* next output INDEX */

  var have, left;
  /* available input and output */

  var hold;
  /* bit buffer */

  var bits;
  /* bits in bit buffer */

  var _in, _out;
  /* save starting available input and output */


  var copy;
  /* number of stored or match bytes to copy */

  var from;
  /* where to copy match bytes from */

  var from_source;
  var here = 0;
  /* current decoding table entry */

  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  var len;
  /* length to copy for repeats, bits to drop */

  var ret;
  /* return code */

  var hbuf = new utils.Buf8(4);
  /* buffer for gzip header crc calculation */

  var opts;
  var n; // temporary var for NEED_BITS

  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        } //=== NEEDBITS(16);


        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        } //--- DROPBITS(4) ---//


        hold >>>= 4;
        bits -= 4; //---//

        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        break;

      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.flags = hold;

        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = TIME;

      /* falls through */

      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = OS;

      /* falls through */

      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = EXLEN;

      /* falls through */

      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = EXTRA;

      /* falls through */

      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = NAME;

      /* falls through */

      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = COMMENT;

      /* falls through */

      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = HCRC;

      /* falls through */

      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;

      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        strm.adler = state.check = zswap32(hold); //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = DICT;

      /* falls through */

      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          return Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = TYPE;

      /* falls through */

      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          state.mode = CHECK;
          break;
        } //=== NEEDBITS(3); */


        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        hold >>>= 1;
        bits -= 1; //---//

        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;

          case 1:
            /* fixed block */
            fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            state.mode = LEN_;
            /* decode codes */

            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        } //--- DROPBITS(2) ---//


        hold >>>= 2;
        bits -= 2; //---//

        break;

      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = COPY_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case COPY_:
        state.mode = COPY;

      /* falls through */

      case COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          utils.arraySet(output, input, next, copy, put); //---//

          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        state.mode = TYPE;
        break;

      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        state.have = 0;
        state.mode = LENLENS;

      /* falls through */

      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        state.have = 0;
        state.mode = CODELENS;

      /* falls through */

      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        if (state.mode === BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.lenbits = opts.bits; // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.distbits = opts.bits; // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        state.mode = LEN_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case LEN_:
        state.mode = LEN;

      /* falls through */

      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          inflate_fast(strm, _out); //--- LOAD() ---

          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          if (state.mode === TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = LENEXT;

      /* falls through */

      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        state.was = state.length;
        state.mode = DIST;

      /* falls through */

      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;

      /* falls through */

      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        state.mode = MATCH;

      /* falls through */

      case MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = LEN;
        }

        break;

      case LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;

      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = LENGTH;

      /* falls through */

      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = DONE;

      /* falls through */

      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;

      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;

      case MEM:
        return Z_MEM_ERROR;

      case SYNC:
      /* falls through */

      default:
        return Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }

  return ret;
}

function inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  ) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;
  /* check state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  /* save header structure */


  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  if (!strm
  /* == Z_NULL */
  || !strm.state
  /* == Z_NULL */
  ) {
      return Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  if (state.mode === DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    dictid = adler32(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  ret = updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';
/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  var len = 0;
  /* a code's length in bits */

  var sym = 0;
  /* index of code symbols */

  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  var root = 0;
  /* number of index bits for root table */

  var curr = 0;
  /* number of index bits for current table */

  var drop = 0;
  /* code bits to drop for sub-table */

  var left = 0;
  /* number of prefix codes available */

  var used = 0;
  /* code entries in table used */

  var huff = 0;
  /* Huffman code */

  var incr;
  /* for incrementing code, index */

  var fill;
  /* index for replicating entries */

  var low;
  /* low bits for current root entry */

  var mask;
  /* mask for low root bits */

  var next;
  /* next available space in table */

  var base = null;
  /* base value table to use */

  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  var end;
  /* use base and extra for symbol > end */

  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  root = bits;

  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  left = 1;

  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  offs[1] = 0;

  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  if (type === CODES) {
    base = extra = work;
    /* dummy value--not used */

    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }
  /* initialize opts for loop */


  huff = 0;
  /* starting code */

  sym = 0;
  /* starting code symbol */

  len = min;
  /* starting code length */

  next = table_index;
  /* current table to fill in */

  curr = root;
  /* current table index bits */

  drop = 0;
  /* current bits to drop from code for index */

  low = -1;
  /* trigger new sub-table when len > root */

  used = 1 << root;
  /* use root table entries */

  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      used += 1 << curr;

      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;


var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

var Z_BINARY = 0;
var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/*============================================================================*/

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

var extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);

zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  this.extra_base = extra_base;
  /* base index for extra_bits */

  this.elems = elems;
  /* max number of elements in the tree */

  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  this.max_code = 0;
  /* largest code with non zero frequency */

  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]
  /*.Code*/
  , tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


function bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  var n, m;
  /* iterate over the tree elements */

  var bits;
  /* bit length */

  var xbits;
  /* extra bits */

  var f;
  /* frequency */

  var overflow = 0;
  /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  = 0;
  /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    * 2 + 1]
    /*.Len*/
    + 1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      + xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) * tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        = bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1);
  /* next code value for each bit length */

  var code = 0;
  /* running code value */

  var bits;
  /* bit index */

  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    tree[n * 2]
    /*.Code*/
    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


function tr_static_init() {
  var n;
  /* iterates over tree elements */

  var bits;
  /* bit counter */

  var length;
  /* length value */

  var code;
  /* code value */

  var dist;
  /* distance index */

  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  length = 0;

  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;

    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  _length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  dist = 0;

  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;

    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;

    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  gen_codes(static_ltree, L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]
    /*.Len*/
    = 5;
    static_dtree[n * 2]
    /*.Code*/
    = bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


function init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    = 0;
  }

  s.dyn_ltree[END_BLOCK * 2]
  /*.Freq*/
  = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);
  /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


function smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  < tree[_m2]
  /*.Freq*/
  || tree[_n2]
  /*.Freq*/
  === tree[_m2]
  /*.Freq*/
  && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  var lc;
  /* match length or unmatched char (if dist == 0) */

  var lx = 0;
  /* running index in l_buf */

  var code;
  /* the code to send */

  var extra;
  /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        /* send the length code */

        extra = extra_lbits[code];

        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);
        /* send the distance code */

        extra = extra_dbits[code];

        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  var max_code = -1;
  /* largest code with non zero frequency */

  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      = 0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  node = elems;
  /* next internal node of the tree */

  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    tree[node * 2]
    /*.Freq*/
    = tree[n * 2]
    /*.Freq*/
    + tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    = tree[m * 2 + 1]
    /*.Dad*/
    = node;
    /* and insert the new node in the heap */

    s.heap[1
    /*SMALLEST*/
    ] = node++;
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  = 0xffff;
  /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


function build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
    /*.Len*/
    , 3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !== 0) {
    return Z_TEXT;
  }

  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  return Z_BINARY;
}

var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    max_blindex = build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  init_block(s);

  if (last) {
    bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  this.next_in = 0;
  /* number of bytes available at input */

  this.avail_in = 0;
  /* total number of input bytes read so far */

  this.total_in = 0;
  /* next output byte should be put there */

  this.output = null; // JS specific, because we have no pointers

  this.next_out = 0;
  /* remaining free space at output */

  this.avail_out = 0;
  /* total number of bytes output so far */

  this.total_out = 0;
  /* last error message, NULL if no error */

  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  this.state = null;
  /* best guess about the data type: binary or text */

  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");
/*<replacement>*/


var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(/*! util */ 0);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
/*<replacement>*/


var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;

var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/node_modules/safe-buffer/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/readable-stream/node_modules/safe-buffer/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform;

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/unzip-js/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/unzip-js/src/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BlobSlicer = __webpack_require__(/*! blob-slicer */ "./node_modules/blob-slicer/src/index.js");

var ZipFile = __webpack_require__(/*! ./zip-file */ "./node_modules/unzip-js/src/zip-file.js");

var Utils = __webpack_require__(/*! ./utils */ "./node_modules/unzip-js/src/utils.js");

module.exports = function unzip(source, callback) {
  if (typeof source === 'string') {
    var xhr = new XMLHttpRequest();
    xhr.addEventListener('readystatechange', function () {
      if (this.readyState === 4) {
        if (this.status === 200) createZipFile(this.response, callback);else callback(Utils.E('network error: {0} {1}', this.status, this.statusText));
      }
    });

    try {
      xhr.open('GET', source);
      xhr.responseType = 'blob';
      xhr.send();
    } catch (err) {
      callback(err);
    }
  } else {
    createZipFile(source, callback);
  }
};

function createZipFile(source, callback) {
  try {
    var reader = new BlobSlicer(source);
    Utils.readEOCDRecord(reader, function (err, eocdr) {
      callback(err, err ? null : new ZipFile(reader, eocdr));
    });
  } catch (err) {
    callback(err);
  }
}

/***/ }),

/***/ "./node_modules/unzip-js/src/utils.js":
/*!********************************************!*\
  !*** ./node_modules/unzip-js/src/utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readEOCDRecord = readEOCDRecord;
exports.readUInt64LE = readUInt64LE;
exports.E = E;
exports.cp437ToUnicode = cp437ToUnicode;

function readEOCDRecord(reader, callback) {
  var fixedFieldsSize = 22;
  var maxRecordSize = fixedFieldsSize + 0xffff;
  reader.read(-maxRecordSize, function (err, buf) {
    if (err) return callback(err);

    if (buf.length < fixedFieldsSize) {
      return callback(E('expected at least 22 bytes for End Of Central Directory got {0}', buf.length));
    }

    var eocdr = {}; // end of central dir signature    4 bytes  (0x06054b50)

    var offset = buf.lastIndexOf('PK\x05\x06');
    if (offset === -1) return callback(E('End Of Central Directory not found'));
    var recordBuffer = buf.slice(offset); // number of this disk             2 bytes

    if (recordBuffer.readUInt16LE(4) !== 0) {
      return callback(E('spanned zip files are not supported'));
    } // number of the disk with the
    // start of the central directory  2 bytes
    // total number of entries in the
    // central directory on this disk  2 bytes
    // total number of entries in
    // the central directory           2 bytes


    eocdr.entryCount = recordBuffer.readUInt16LE(10); // size of the central directory   4 bytes

    eocdr.cdSize = recordBuffer.readUInt32LE(12); // offset of start of central
    // directory with respect to
    // the starting disk number        4 bytes

    eocdr.cdOffset = recordBuffer.readUInt32LE(16); // .ZIP file comment length        2 bytes

    var commentLength = recordBuffer.readUInt16LE(20); // .ZIP file comment       (variable size)

    eocdr.comment = recordBuffer.toString('utf-8', 22, 22 + commentLength);
    console.assert(eocdr.comment.length === commentLength, 'expected ' + commentLength + ' bytes for zip file comment got ' + eocdr.comment.length);

    if (eocdr.entryCount === 0xffff || eocdr.cdSize === 0xffffffff || eocdr.cdOffset === 0xffffffff) {
      readEOCD64Record(reader, offset, function (err, eocd64r) {
        if (eocd64r) eocd64r.comment = eocdr.comment;
        callback(err, eocd64r);
      });
    } else callback(null, eocdr);
  });
}

function readEOCD64Record(reader, eocdOffset, callback) {
  var fixedFieldsSize = 56;
  readEOCDLocator(reader, eocdOffset, function (err, eocd64Offset) {
    if (err) return callback(err);
    reader.read(eocd64Offset, eocd64Offset + fixedFieldsSize, function (err, buf) {
      if (err) return callback(err);

      if (buf.length < fixedFieldsSize) {
        return callback(E('expected at least 56 bytes for Zip64 End Of Central Directory got {0}', buf.length));
      }

      var eocd64r = {}; // zip64 end of central dir
      // signature                       4 bytes  (0x06064b50)

      if (buf.readUInt32LE(0) !== 0x06064b50) {
        return callback(E('Zip64 End Of Central Directory not found'));
      } // size of zip64 end of central
      // directory record                8 bytes
      // version made by                 2 bytes
      // version needed to extract       2 bytes
      // number of this disk             4 bytes
      // number of the disk with the
      // start of the central directory  4 bytes
      // total number of entries in the
      // central directory on this disk  8 bytes
      // total number of entries in the
      // central directory               8 bytes


      eocd64r.entryCount = readUInt64LE(buf, 32); // size of the central directory   8 bytes

      eocd64r.cdSize = readUInt64LE(buf, 40); // offset of start of central
      // directory with respect to
      // the starting disk number        8 bytes

      eocd64r.cdOffset = readUInt64LE(buf, 48); // zip64 extensible data sector    (variable size)

      callback(null, eocd64r);
    });
  });
}

function readEOCDLocator(reader, eocdOffset, callback) {
  var locatorRecordSize = 20;
  reader.read(eocdOffset - locatorRecordSize, eocdOffset, function (err, buf) {
    if (err) return callback(err);

    if (buf.length < locatorRecordSize) {
      return callback(E('expected at least 20 bytes for Zip64 End Of Central Directory Locator got {0}', buf.length));
    } // zip64 end of central dir locator
    // signature                       4 bytes  (0x07064b50)


    if (buf.readUInt32LE(0) !== 0x07064b50) {
      return callback(E('Zip64 End Of Central Directory Locator not found'));
    } // number of the disk with the
    // start of the zip64 end of
    // central directory               4 bytes
    // relative offset of the zip64
    // end of central directory record 8 bytes


    var eocd64Offset = readUInt64LE(buf, 8); // total number of disks           4 bytes

    if (buf.readUInt32LE(16) !== 1) {
      return callback(E('spanned zip files are not supported'));
    }

    callback(null, eocd64Offset);
  });
}

function readUInt64LE(buffer, offset) {
  return buffer.readUInt32LE(offset) + buffer.readUInt32LE(offset + 4) * 0x100000000;
}

function E(message) {
  var args = arguments;
  return new Error(message.replace(/{(\d+)}/g, function (match, p) {
    var r = args[+p + 1];
    return r === undefined ? match : r;
  }));
}

function cp437ToUnicode(buffer) {
  var table = [0x0000, 0x263A, 0x263B, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022, 0x25D8, 0x25CB, 0x25D9, 0x2642, 0x2640, 0x266A, 0x266B, 0x263C, 0x25BA, 0x25C4, 0x2195, 0x203C, 0x00B6, 0x00A7, 0x25AC, 0x21A8, 0x2191, 0x2193, 0x2192, 0x2190, 0x221F, 0x2194, 0x25B2, 0x25BC, 0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x2302, 0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5, 0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB, 0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580, 0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0];
  var convertedBuffer = new Array(buffer.length);
  var len = convertedBuffer.length;
  var i;

  for (i = 0; i < len; i++) {
    convertedBuffer[i] = table[buffer[i]];
  }

  var MAX_CHUNK_SIZE = 32767;
  var str = '';

  for (i = 0; i < len; i += MAX_CHUNK_SIZE) {
    str += String.fromCharCode.apply(null, convertedBuffer.slice(i, i + MAX_CHUNK_SIZE));
  }

  return str;
}

/***/ }),

/***/ "./node_modules/unzip-js/src/zip-file.js":
/*!***********************************************!*\
  !*** ./node_modules/unzip-js/src/zip-file.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var crc32 = __webpack_require__(/*! buffer-crc32 */ "./node_modules/buffer-crc32/index.js");

var createInflateRaw = __webpack_require__(/*! zlib */ "./node_modules/browserify-zlib/lib/index.js").createInflateRaw;

var Transform = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js").Transform;

var Utils = __webpack_require__(/*! ./utils */ "./node_modules/unzip-js/src/utils.js");

var E = Utils.E;
var readUInt64LE = Utils.readUInt64LE;
var cp437ToUnicode = Utils.cp437ToUnicode;
module.exports = ZipFile;

function ZipFile(reader, eocdr) {
  this.entries = [];
  this.entryCount = eocdr.entryCount;
  this.comment = eocdr.comment;
  this._cdSize = eocdr.cdSize;
  this._cdOffset = eocdr.cdOffset;
  this._reader = reader;
}

ZipFile.prototype.readEntries = function (callback) {
  var fixedFieldsSize = 46;
  var self = this;

  callback = function (fn) {
    var called = false;
    return function (err, entries) {
      if (called) return;
      called = true;
      fn(err, entries);
    };
  }(callback);

  var readStream = this._reader.createReadStream({
    start: this._cdOffset,
    end: this._cdOffset + this._cdSize
  });

  readStream.on('error', callback);
  readStream.on('end', function () {
    callback(self.entries.length === self.entryCount ? null : E('expected {0} entries got {1}', self.entryCount, self.entries.length), self.entries);
  });
  readStream.on('readable', onReadable);

  function destroyAndDrain(error) {
    readStream.destroy(error);
    readStream.read();
  }

  function onReadable() {
    while (this.readableLength > 0) {
      if (this.readableLength < fixedFieldsSize) {
        if (this.ended) {
          return destroyAndDrain(E('expected at least 46 bytes for Central File Header got {0}', this.readableLength));
        }

        break;
      }

      var fixedFieldsBuffer = this.read(fixedFieldsSize);
      var entry = new Entry(); // central file header signature   4 bytes  (0x02014b50)

      if (fixedFieldsBuffer.readUInt32LE(0) !== 0x02014b50) {
        return destroyAndDrain(E('invalide Central File Header signature'));
      } // version made by                 2 bytes


      entry.versionMadeBy = fixedFieldsBuffer.readUInt16LE(4); // version needed to extract       2 bytes

      entry.versionNeededToExtract = fixedFieldsBuffer.readUInt16LE(6); // general purpose bit flag        2 bytes

      entry.generalPurposeBitFlag = fixedFieldsBuffer.readUInt16LE(8); // compression method              2 bytes

      entry.compressionMethod = fixedFieldsBuffer.readUInt16LE(10); // last mod file time              2 bytes

      entry.lastModTime = fixedFieldsBuffer.readUInt16LE(12); // last mod file date              2 bytes

      entry.lastModDate = fixedFieldsBuffer.readUInt16LE(14); // crc-32                          4 bytes

      entry.crc32 = fixedFieldsBuffer.readUInt32LE(16); // compressed size                 4 bytes

      entry.compressedSize = fixedFieldsBuffer.readUInt32LE(20); // uncompressed size               4 bytes

      entry.uncompressedSize = fixedFieldsBuffer.readUInt32LE(24); // file name length                2 bytes

      var nameLength = fixedFieldsBuffer.readUInt16LE(28); // extra field length              2 bytes

      var extraFieldsLength = fixedFieldsBuffer.readUInt16LE(30); // file comment length             2 bytes

      var commentLength = fixedFieldsBuffer.readUInt16LE(32); // disk number start               2 bytes
      // internal file attributes        2 bytes

      entry.internalAttributes = fixedFieldsBuffer.readUInt16LE(36); // external file attributes        4 bytes

      entry.externalAttributes = fixedFieldsBuffer.readUInt32LE(38); // relative offset of local header 4 bytes

      entry.localHeaderOffset = fixedFieldsBuffer.readUInt32LE(42);
      var variableFieldsSize = nameLength + extraFieldsLength + commentLength;

      if (this.readableLength < variableFieldsSize) {
        if (this.ended) {
          return destroyAndDrain(E('expected at least {0} bytes for variable fields in Central File Header got {1}', variableFieldsSize, this.readableLength));
        }

        this.unshift(fixedFieldsBuffer);
        break;
      }

      var variableFieldsBuffer = this.read(variableFieldsSize); // file name (variable size)

      entry.name = variableFieldsBuffer.slice(0, nameLength); // extra field (variable size)

      var extraFieldsBuffer = variableFieldsBuffer.slice(nameLength, nameLength + extraFieldsLength);

      for (var i = 0, len = extraFieldsBuffer.length - 3; i < len;) {
        var headerId = extraFieldsBuffer.readUInt16LE(i);
        var dataSize = extraFieldsBuffer.readUInt16LE(i += 2);
        var data = Buffer.from(extraFieldsBuffer.slice(i += 2, i += dataSize));
        entry.extraFields.push({
          headerId: headerId,
          dataSize: dataSize,
          data: data
        });
      } // comment (variable size)


      entry.comment = variableFieldsBuffer.slice(nameLength + extraFieldsLength); // handle encoding

      var isUTF8 = (entry.generalPurposeBitFlag & 0x800) === 0x800;

      if (isUTF8) {
        entry.name = entry.name.toString();
        entry.comment = entry.comment.toString();
      } else {
        entry.name = cp437ToUnicode(entry.name);
        entry.comment = cp437ToUnicode(entry.comment);
      } // Info-ZIP Unicode Path/Comment Extra Field


      ;
      ['name', 'comment'].forEach(function (field) {
        var headerId;
        var oldData;

        if (field === 'name') {
          headerId = 0x7075;
          oldData = variableFieldsBuffer.slice(0, nameLength);
        } else {
          headerId = 0x6375;
          oldData = variableFieldsBuffer.slice(nameLength + extraFieldsLength);
        }

        var infoZipUEFs = entry.extraFields.filter(function (ef) {
          return ef.headerId === headerId;
        });
        infoZipUEFs.forEach(function (infoZipUEF) {
          var data = infoZipUEF.data;

          if (data.length > 6) {
            var versionRecognized = data.readUInt8(0) === 1;
            var crcCheckPassed = crc32.unsigned(oldData) === data.readUInt32LE(1);
            var str = data.toString('utf8', 5);
            if (versionRecognized && crcCheckPassed && str.length > 0) entry[field] = str;
          }
        });
      }); // handle zip64 format

      if (entry.compressedSize === 0xffffffff || entry.uncompressedSize === 0xffffffff || entry.localHeaderOffset === 0xffffffff) {
        var zip64EIEF = entry.extraFields.filter(function (ef) {
          return ef.headerId === 0x0001;
        })[0];

        if (zip64EIEF) {
          var offset = 0;
          var fields = ['uncompressedSize', 'compressedSize', 'localHeaderOffset'];

          for (var j in fields) {
            var field = fields[j];

            if (entry[field] === 0xffffffff) {
              try {
                entry[field] = readUInt64LE(zip64EIEF.data, offset);
                offset += 8;
              } catch (err) {
                return destroyAndDrain(E('invalid Zip64 Extended Information Extra Field: {0} not found', field));
              }
            }
          }
        } else {
          return destroyAndDrain(E('Zip64 Extended Information Extra Field not found'));
        }
      }

      self.entries.push(entry);
    }

    this.read(0);
  }
};

ZipFile.prototype.readEntryData = function (entry, checkCrc, callback) {
  if (entry.encrypted) {
    callback(E('encrypted files are not supported'));
    return;
  }

  if (entry.compressionMethod !== 0 && entry.compressionMethod !== 8) {
    callback(E('compression method is not supported'));
    return;
  }

  var fixedFieldsSize = 30;
  var self = this;

  this._reader.read(entry.localHeaderOffset, entry.localHeaderOffset + fixedFieldsSize, function (err, buf) {
    if (err) return callback(err);

    if (buf.length < fixedFieldsSize) {
      return callback(E('expected at least 30 bytes for Local File Header got {1}', buf.length));
    } // local file header signature     4 bytes  (0x04034b50)


    if (buf.readUInt32LE(0) !== 0x04034b50) {
      return callback(E('invalid Local File Header signature'));
    } // version needed to extract       2 bytes
    // general purpose bit flag        2 bytes
    // compression method              2 bytes
    // last mod file time              2 bytes
    // last mod file date              2 bytes
    // crc-32                          4 bytes
    // compressed size                 4 bytes
    // uncompressed size               4 bytes
    // file name length                2 bytes


    var nameLength = buf.readUInt16LE(26); // extra field length              2 bytes

    var extraFieldLength = buf.readUInt16LE(28);
    var dataStart = entry.localHeaderOffset + fixedFieldsSize + nameLength + extraFieldLength;

    var readStream = self._reader.createReadStream({
      start: dataStart,
      end: dataStart + entry.compressedSize
    });

    var outStream = readStream;

    if (entry.compressionMethod === 8) {
      var inflate = createInflateRaw();
      outStream = outStream.on('error', function (err) {
        inflate.destroy(err);
      }).pipe(inflate);
    }

    if (checkCrc) {
      var partialCrc;
      var crcTransform = new Transform({
        transform: function (chunk, encoding, callback) {
          partialCrc = crc32(chunk, partialCrc);
          callback(null, chunk);
        },
        flush: function (callback) {
          var finalCrc = partialCrc.readUInt32BE(0);
          callback(finalCrc === entry.crc32 ? null : E('corrupted file: crc check fails'));
        }
      });
      outStream = outStream.on('error', function (err) {
        crcTransform.destroy(err);
      }).pipe(crcTransform);
    }

    callback(null, outStream);
  });
};

function Entry() {
  this.extraFields = [];
}

Object.defineProperties(Entry.prototype, {
  encrypted: {
    get: function () {
      return (this.generalPurposeBitFlag & 0x0001) === 0x0001;
    }
  },
  lastModDateTime: {
    get: function () {
      return new Date((this.lastModDate >> 9 & 0x7f) + 1980, // year
      (this.lastModDate >> 5 & 0xf) - 1, // month
      this.lastModDate & 0x1f, // day
      this.lastModTime >> 11 & 0x1f, // hours
      this.lastModTime >> 5 & 0x3f, // minutes
      (this.lastModTime & 0x1f) * 2 // seconds
      );
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function () {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXBwL2pzL2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvanMvYXBpLmpzIiwid2VicGFjazovLy8uL2FwcC9qcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2pzL2F1ZGlvLmpzIiwid2VicGFjazovLy8uL2FwcC9qcy9kYXRhLmpzIiwid2VicGFjazovLy8uL2FwcC9qcy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2pzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2FwcC9qcy9saWdodC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvanMvbG9nLmpzIiwid2VicGFjazovLy8uL2FwcC9qcy93cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibG9iLXNsaWNlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jsb2Itc2xpY2VyL3NyYy9yZWFkLXN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL2xpYi9iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXItY3JjMzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuemlwLWpzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW56aXAtanMvc3JjL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bnppcC1qcy9zcmMvemlwLWZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKT84MWNmIl0sIm5hbWVzIjpbInNhdmVGaWxlIiwiaGFuZGxlIiwic2hvd1NhdmVGaWxlUGlja2VyIiwiY29uc29sZSIsImxvZyIsIm9wZW5GaWxlIiwic2hvd09wZW5GaWxlUGlja2VyIiwic3RhcnRTaG93Iiwic2VuZCIsImNhbGwiLCJlbmRTaG93Iiwic2V0UHJvcCIsIkNPTkZJRyIsInBhcmFtcyIsImVuZCIsInBhdXNlU2hvdyIsInJlc3VtZVNob3ciLCJjb25zdHJhaW4iLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIm1hcCIsImZyb21NaW4iLCJmcm9tTWF4IiwidG9NaW4iLCJ0b01heCIsInJnYlRvSHNsIiwiciIsImciLCJiIiwiTWF0aCIsImgiLCJzIiwibCIsImQiLCJoc2xUb1JnYiIsImdsb2JhbCIsImh1ZTJyZ2IiLCJwIiwicSIsInQiLCJyZ2JUb0hzdiIsInYiLCJoc3ZUb1JnYiIsImkiLCJmbG9vciIsImYiLCIkIiwic2VsZWN0b3IiLCJkb2N1bWVudCIsImJvZHkiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2V0VGV4dCIsInRleHQiLCJmb3JFYWNoIiwiZWwiLCJpbm5lckhUTUwiLCJzZXRWYWx1ZSIsInByb3AiLCJzZXRBdHRyIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsImNsaWNrIiwibWV0aG9kIiwiYXJncyIsInJlcXVlc3QiLCJwYXRoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsIk9iamVjdCIsImVudHJpZXMiLCJ1cmkiLCJsZW5ndGgiLCJrZXkiLCJqb2luIiwic2l6ZSIsIm91dHB1dCIsImRlYnVnIiwib3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJKU09OIiwicGFyc2UiLCJyZXNwb25zZVRleHQiLCJmZXRjaEZpbGUiLCJ0eXBlIiwiJHByb2dyZXNzIiwiY3JlYXRlRWxlbWVudCIsIiRvdXRwdXQiLCJhcHBlbmRDaGlsZCIsImNhbmNlbGVkIiwicHJvZ3Jlc3MiLCJyZXNwb25zZSIsInN0cmVhbSIsImJ5dGVzUmVhZCIsImRhdGEiLCJwcm9taXNlIiwiZmV0Y2giLCJnZXRSZWFkZXIiLCJuZXh0IiwiZG9uZSIsInJlYWQiLCJjYW5jZWwiLCJwdXNoIiwiaW5uZXJUZXh0IiwiZm9ybWF0Qnl0ZXMiLCJzZXRUaW1lb3V0IiwiZmlsZSIsIkJsb2IiLCJlIiwiY2FsbGJhY2siLCJ1cGxvYWRGaWxlIiwic3luYyIsInRhcmdldCIsInVzZVNEIiwidG9GaXhlZCIsImZvcm0iLCJGb3JtRGF0YSIsImFwcGVuZCIsIm9ubG9hZGVuZCIsImdldCIsInBvc3QiLCJleGVjIiwiY21kIiwiYnl0ZXMiLCJ0b1ByZWNpc2lvbiIsImZvcm1hdFRpbWUiLCJkdXJhdGlvbiIsInNob3dIb3VyIiwiaG91ciIsImhvdXJMZWZ0IiwibWludXRlIiwic2Vjb25kIiwibXMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic2VuZENvbW1hbmQiLCJjb21tYW5kIiwic2VsZWN0ZWQiLCJub2RlcyIsImZpbHRlciIsIm4iLCJpZCIsInRvVXBwZXJDYXNlIiwiYXNzaWduIiwicmVuZGVySGVhZCIsInBhcnNlSW50IiwiZGF0YXNldCIsInNob3ciLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJydW5uaW5nIiwicGF1c2VkIiwiQVVESU8iLCJyZW5kZXJOb2RlcyIsInNlY3Rpb24iLCJzb3J0IiwiYSIsIm5hbWUiLCJub2RlIiwiJG5vZGUiLCJ2YmF0IiwiaGlkZGVuIiwicGVyY2VudCIsImRyb3BwYWJsZSIsImRldmljZSIsImNoZWNrTm9kZXMiLCJleHBpcmVkIiwiRGF0ZSIsIm5vdyIsImNoYW5nZWQiLCJsYXN0VXBkYXRlZCIsImZldGNoUmVxdWVzdCIsInNlbGVjdFNob3ciLCJoYW5kbGVFbmQiLCJTSE9XIiwidHJhY2tzIiwicmVuZGVyIiwidGhlbiIsInJlbmRlclNob3ciLCJyZW5kZXJBdWRpbyIsImNhdGNoIiwiQXVkaW9Db250ZXh0Iiwid2luZG93IiwicGFyc2VBdWRpbyIsImN0eCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImF1ZGlvIiwic2FtcGxlUmF0ZSIsImNoYW5uZWxzIiwibnVtYmVyT2ZDaGFubmVscyIsImdldENoYW5uZWxEYXRhIiwidGVtcG8iLCJiZWF0cyIsInBlYWtzIiwic3BlY3RyYWxGbHV4IiwiZmx1eCIsIm90aGVyIiwiTXVzaWNUZW1wbyIsInJvdW5kIiwiZGVjb2RlQXVkaW9EYXRhIiwicmVzdWx0IiwiaGFuZGxlRXJyb3IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZW5kZXJXYXZlZm9ybSIsIndyYXBwZXIiLCJpbmRleCIsImNhbnZhcyIsImdldENvbnRleHQiLCJ3YXZlRGF0YSIsImhlaWdodCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImhhbGZIZWlnaHQiLCJzdGVwIiwic3R5bGUiLCJsZWZ0IiwiY2xpZW50V2lkdGgiLCJ4Iiwic3VtUG9zaXRpdmUiLCJzdW1OZWdhdGl2ZSIsIm1heFBvc2l0aXZlIiwibWF4TmVnYXRpdmUiLCJrTmVnYXRpdmUiLCJrUG9zaXRpdmUiLCJkcmF3SWR4IiwicDEiLCJzdHJva2VTdHlsZSIsInN0cm9rZVJlY3QiLCJwMiIsImJyaWdodG5lc3MiLCJjaGFubmVsIiwidGltZSIsInN5bmNpbmciLCJMSUdIVCIsImNvbG9yIiwicmdiIiwiaHNsIiwidXBkYXRlUkdCIiwidXBkYXRlSFNMIiwicmVxdWlyZSIsInBhcnNlTFNGIiwicGFyc2VMVFAiLCJwYXJzZUlQWCIsImVycm9yIiwiYXJndW1lbnRzIiwiaGFuZGxlRmlsZSIsImV2ZW50IiwiZW5kc1dpdGgiLCJmaWxlbmFtZSIsInN0cmluZ2lmeSIsImNsb3Nlc3QiLCJzdGFydHNXaXRoIiwiaGFuZGxlQ2hhbmdlIiwiZmlsZXMiLCJoYW5kbGVDbGljayIsImFjdGlvbiIsImFjdGlvbnMiLCJyZXN0IiwiZXZhbCIsImhhbmRsZURyYWdPdmVyIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVEcmFnTGVhdmUiLCJoYW5kbGVEcmFnRHJvcCIsImRhdGFUcmFuc2ZlciIsInNjcm9sbGluZyIsInNjcm9sbEVuZGVkIiwic2Nyb2xsU3RhcnQiLCJkZWJvdW5jZSIsImxlYWRpbmciLCJzY3JvbGxFbmQiLCJwbGF5ZXIiLCJwbGF5IiwidHJhaWxpbmciLCJoYW5kbGVTY3JvbGwiLCJ0aW1lbGluZSIsInJhdGlvIiwic2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJjdXJyZW50VGltZSIsImhhbmRsZVBsYXkiLCJoYW5kbGVUaW1lVXBkYXRlIiwiaGFuZGxlUGxheWluZyIsImhhbmRsZVBhdXNlIiwiaGFuZGxlU3RhcnQiLCJoYW5kbGVUaW1lU2Vla2luZyIsImhhbmRsZVRpbWVTZWVrZWQiLCIkdGltZWxpbmUiLCIkaGFuZGxlIiwicXVlcnlTZWxlY3RvciIsInRvcCIsIm9mZnNldFRvcCIsIm9mZnNldEhlaWdodCIsInNlbmRTeW5jIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZHJhdyIsImhhbmRsZUluaXQiLCJzZXRJbnRlcnZhbCIsIkZ1bmN0aW9uIiwibGVkX251bXMiLCJyZ2JGcmFtZVJlZ2V4IiwiZW5kRnJhbWVSZWdleCIsImxvb3BGcmFtZVJlZ2V4IiwidW56aXAiLCJlcnIiLCJ6aXAiLCJyZWFkRW50cmllcyIsImVuZGVkIiwiZW50cnkiLCJyZWFkRW50cnlEYXRhIiwiY29udGVudCIsIm9uIiwicmVhZEFzVGV4dCIsInNvbHV0aW9uIiwib25sb2FkIiwibWF0Y2giLCJzZWdtZW50Iiwic3Vic3RyIiwidHJpbSIsInNwbGl0IiwibGluZSIsIm1hdGNoZWQiLCJzdGFydCIsInRyYW5zaXRpb24iLCJmcmFtZXMiLCJsaW5lcyIsImZyYW1lIiwiVWludDhBcnJheSIsInZpZXciLCJEYXRhVmlldyIsImJ1ZmZlciIsInNldFVpbnQ4Iiwic2V0VWludDMyIiwiaW1hZ2VzIiwic2VxdWVuY2VzIiwic3JjZG9jIiwiZG9jIiwiY29udGVudERvY3VtZW50IiwiaXRlbSIsImdldEF0dHJpYnV0ZSIsImNoaWxkTm9kZXMiLCJub2RlVmFsdWUiLCJyZXBsYWNlIiwidXBsb2FkUGF0aCIsImltZyIsIkltYWdlIiwic3JjIiwic2NhbGUiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJQSSIsImRyYXdJbWFnZSIsInJlc3RvcmUiLCJVaW50OENsYW1wZWRBcnJheSIsImdldEltYWdlRGF0YSIsInJlZHVjZSIsImJsb2IiLCJ0b0RhdGFVUkwiLCJBcnJheSIsImNoaWxkIiwiaW1hZ2UiLCJyZW1vdmVDaGlsZCIsIiR0cmFja3MiLCJ0cmFjayIsIiR0cmFjayIsImVsZW1lbnRzIiwicmVuZGVyTGlnaHQiLCJjb250YWluZXIiLCIkZWwiLCJjb2xvclN0YXJ0IiwiY29sb3JFbmQiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiY29udmVydENvbG9yIiwiY29sb3IxIiwiY29sb3IyIiwiYmFja2dyb3VuZENvbG9yIiwidG9Dc3NDb2xvciIsImJhY2tncm91bmQiLCJwZXJpb2QiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkcmF3Rmxhc2giLCJkcmF3UmFpbmJvdyIsImRyYXdEb3RzIiwic3BhY2luZyIsImRyYXdQdWxzZSIsInRvQ3NzSFNMIiwidG1wQ2FudmFzIiwibGVuMSIsImxlbjIiLCJncmFkaWVudCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiaGVhZCIsIkNvbnNvbGVFbGVtZW50IiwiY29uc3RydWN0b3IiLCJtYWluIiwiaW5wdXQiLCJoYW5kbGVLZXlkb3duIiwiYmluZCIsIlN0cmluZyIsInN0YWNrIiwiZm9jdXMiLCJpY29uIiwibGFzdE91dHB1dCIsInNjcm9sbFRvcCIsInNjcm9sbEhlaWdodCIsImxvZ2dlciIsIm9yaWdpbmFsIiwiaW5mbyIsIndhcm4iLCJzb2NrZXQiLCJmc1Jlc3BvbnNlZCIsImNyZWF0ZVNvY2tldCIsIldlYlNvY2tldCIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJiaW5hcnlUeXBlIiwiQXJyYXlCdWZmZXIiLCJyZWFkU3RyIiwiZXF1YWxzIiwibjEiLCJnZXRVaW50OCIsImdldFVpbnQxNiIsImV4aXN0IiwibjIiLCJpc0VxdWFsIiwic2xpY2UiLCJ3YWl0RmlsZVJlc3BvbnNlIiwidGltZW91dCIsImNoZWNrIiwic2VuZEZpbGUiLCJvZmZzZXQiLCJidWYiLCJieXRlTGVuZ3RoIiwicGF5bG9hZCIsInByaW50IiwiZXZlcnkiLCJjIiwiZnJvbUNoYXJDb2RlIiwiYnl0ZSIsInN0ciIsInBvcyIsImNoYXJDb2RlQXQiLCJoZWFkZXIiLCJ0YXJnZXRCeXRlcyIsImhlYWRlckJ5dGVzIiwib2JqZWN0QXNzaWduIiwiY29tcGFyZSIsInkiLCJsZW4iLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIl9pc0J1ZmZlciIsInV0aWwiLCJoYXNPd24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInBTbGljZSIsImZ1bmN0aW9uc0hhdmVOYW1lcyIsImZvbyIsInBUb1N0cmluZyIsIm9iaiIsImlzVmlldyIsImFycmJ1ZiIsImFzc2VydCIsIm1vZHVsZSIsImV4cG9ydHMiLCJvayIsInJlZ2V4IiwiZ2V0TmFtZSIsImZ1bmMiLCJpc0Z1bmN0aW9uIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcHRpb25zIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsIm1lc3NhZ2UiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiZ2V0TWVzc2FnZSIsInN0YWNrU3RhcnRGdW5jdGlvbiIsImZhaWwiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwib3V0IiwiZm5fbmFtZSIsImlkeCIsImluZGV4T2YiLCJuZXh0X2xpbmUiLCJzdWJzdHJpbmciLCJpbmhlcml0cyIsInRydW5jYXRlIiwiaW5zcGVjdCIsInNvbWV0aGluZyIsInJhd25hbWUiLCJzZWxmIiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIl9kZWVwRXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3QiLCJtZW1vcyIsImlzRGF0ZSIsImdldFRpbWUiLCJpc1JlZ0V4cCIsInNvdXJjZSIsIm11bHRpbGluZSIsImxhc3RJbmRleCIsImlnbm9yZUNhc2UiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJhY3R1YWxJbmRleCIsIm9iakVxdWl2IiwiaXNBcmd1bWVudHMiLCJvYmplY3QiLCJhY3R1YWxWaXNpdGVkT2JqZWN0cyIsInVuZGVmaW5lZCIsImlzUHJpbWl0aXZlIiwiZ2V0UHJvdG90eXBlT2YiLCJhSXNBcmdzIiwiYklzQXJncyIsImthIiwib2JqZWN0S2V5cyIsImtiIiwibm90RGVlcEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImV4cGVjdGVkRXhjZXB0aW9uIiwidGVzdCIsImlzUHJvdG90eXBlT2YiLCJfdHJ5QmxvY2siLCJibG9jayIsIl90aHJvd3MiLCJzaG91bGRUaHJvdyIsIlR5cGVFcnJvciIsInVzZXJQcm92aWRlZE1lc3NhZ2UiLCJpc1Vud2FudGVkRXhjZXB0aW9uIiwiaXNFcnJvciIsImlzVW5leHBlY3RlZEV4Y2VwdGlvbiIsInRocm93cyIsImRvZXNOb3RUaHJvdyIsImlmRXJyb3IiLCJrZXlzIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiY29kZSIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImFyciIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJSZWFkU3RyZWFtIiwiQmxvYlNsaWNlciIsIl9ibG9iIiwiY2IiLCJvbkxvYWRlbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZnJvbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJSZWFkYWJsZSIsImhpZ2hXYXRlck1hcmsiLCJfZW5kIiwiX3BvcyIsIl9yZWFkZXIiLCJfbG9hZGVuZExpc3RlbmVyIiwiZGVzdHJveSIsImNyZWF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWFkYWJsZUxlbmd0aCIsIl9yZWFkYWJsZVN0YXRlIiwiX3JlYWQiLCJkZXN0cm95ZWQiLCJfZGVzdHJveSIsInJlYWR5U3RhdGUiLCJMT0FESU5HIiwiYWJvcnQiLCJac3RyZWFtIiwiemxpYl9kZWZsYXRlIiwiemxpYl9pbmZsYXRlIiwiY29uc3RhbnRzIiwiTk9ORSIsIkRFRkxBVEUiLCJJTkZMQVRFIiwiR1pJUCIsIkdVTlpJUCIsIkRFRkxBVEVSQVciLCJJTkZMQVRFUkFXIiwiVU5aSVAiLCJHWklQX0hFQURFUl9JRDEiLCJHWklQX0hFQURFUl9JRDIiLCJabGliIiwibW9kZSIsImRpY3Rpb25hcnkiLCJmbHVzaCIsImluaXRfZG9uZSIsImxldmVsIiwibWVtTGV2ZWwiLCJzdHJhdGVneSIsIndpbmRvd0JpdHMiLCJ3cml0ZV9pbl9wcm9ncmVzcyIsInBlbmRpbmdfY2xvc2UiLCJnemlwX2lkX2J5dGVzX3JlYWQiLCJjbG9zZSIsImRlZmxhdGVFbmQiLCJzdHJtIiwiaW5mbGF0ZUVuZCIsIndyaXRlIiwiaW5fb2ZmIiwiaW5fbGVuIiwib3V0X29mZiIsIm91dF9sZW4iLCJfd3JpdGUiLCJ3cml0ZVN5bmMiLCJhc3luYyIsIlpfTk9fRkxVU0giLCJaX1BBUlRJQUxfRkxVU0giLCJaX1NZTkNfRkxVU0giLCJaX0ZVTExfRkxVU0giLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJhbGxvYyIsImF2YWlsX2luIiwibmV4dF9pbiIsImF2YWlsX291dCIsIm5leHRfb3V0IiwiX3Byb2Nlc3MiLCJfY2hlY2tFcnJvciIsIl9hZnRlclN5bmMiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJfYWZ0ZXIiLCJuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlIiwiZGVmbGF0ZSIsImluZmxhdGUiLCJaX05FRURfRElDVCIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwiWl9PSyIsIlpfREFUQV9FUlJPUiIsIlpfU1RSRUFNX0VORCIsInJlc2V0IiwiWl9CVUZfRVJST1IiLCJfZXJyb3IiLCJtc2ciLCJvbmVycm9yIiwiaW5pdCIsIlpfRklMVEVSRUQiLCJaX0hVRkZNQU5fT05MWSIsIlpfUkxFIiwiWl9GSVhFRCIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIl9pbml0IiwiX3NldERpY3Rpb25hcnkiLCJfcmVzZXQiLCJkZWZsYXRlSW5pdDIiLCJaX0RFRkxBVEVEIiwiaW5mbGF0ZUluaXQyIiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJkZWZsYXRlUmVzZXQiLCJpbmZsYXRlUmVzZXQiLCJUcmFuc2Zvcm0iLCJiaW5kaW5nIiwia01heExlbmd0aCIsImtSYW5nZUVycm9yTWVzc2FnZSIsIlpfTUlOX1dJTkRPV0JJVFMiLCJaX01BWF9XSU5ET1dCSVRTIiwiWl9ERUZBVUxUX1dJTkRPV0JJVFMiLCJaX01JTl9DSFVOSyIsIlpfTUFYX0NIVU5LIiwiSW5maW5pdHkiLCJaX0RFRkFVTFRfQ0hVTksiLCJaX01JTl9NRU1MRVZFTCIsIlpfTUFYX01FTUxFVkVMIiwiWl9ERUZBVUxUX01FTUxFVkVMIiwiWl9NSU5fTEVWRUwiLCJaX01BWF9MRVZFTCIsIlpfREVGQVVMVF9MRVZFTCIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsImJrZXlzIiwiYmsiLCJia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb2RlcyIsIlpfRVJSTk8iLCJaX1NUUkVBTV9FUlJPUiIsIlpfTUVNX0VSUk9SIiwiWl9WRVJTSU9OX0VSUk9SIiwiY2tleXMiLCJjayIsImNrZXkiLCJmcmVlemUiLCJEZWZsYXRlIiwiSW5mbGF0ZSIsIkd6aXAiLCJHdW56aXAiLCJEZWZsYXRlUmF3IiwiSW5mbGF0ZVJhdyIsIlVuemlwIiwiY3JlYXRlRGVmbGF0ZSIsIm8iLCJjcmVhdGVJbmZsYXRlIiwiY3JlYXRlRGVmbGF0ZVJhdyIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVHemlwIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlVW56aXAiLCJvcHRzIiwiemxpYkJ1ZmZlciIsImRlZmxhdGVTeW5jIiwiemxpYkJ1ZmZlclN5bmMiLCJnemlwIiwiZ3ppcFN5bmMiLCJkZWZsYXRlUmF3IiwiZGVmbGF0ZVJhd1N5bmMiLCJ1bnppcFN5bmMiLCJpbmZsYXRlU3luYyIsImd1bnppcCIsImd1bnppcFN5bmMiLCJpbmZsYXRlUmF3IiwiaW5mbGF0ZVJhd1N5bmMiLCJlbmdpbmUiLCJidWZmZXJzIiwibnJlYWQiLCJvbkVycm9yIiwib25FbmQiLCJmbG93IiwiY2h1bmsiLCJvbmNlIiwicmVtb3ZlTGlzdGVuZXIiLCJSYW5nZUVycm9yIiwiY29uY2F0IiwiZmx1c2hGbGFnIiwiX2ZpbmlzaEZsdXNoRmxhZyIsIl9wcm9jZXNzQ2h1bmsiLCJpc1ZhbGlkRmx1c2hGbGFnIiwiZmxhZyIsIl90aGlzIiwiX29wdHMiLCJfY2h1bmtTaXplIiwiY2h1bmtTaXplIiwiZmluaXNoRmx1c2giLCJfZmx1c2hGbGFnIiwiX2hhbmRsZSIsIl9oYWRFcnJvciIsImVycm5vIiwiX2Nsb3NlIiwiZW1pdCIsIl9idWZmZXIiLCJhbGxvY1Vuc2FmZSIsIl9vZmZzZXQiLCJfbGV2ZWwiLCJfc3RyYXRlZ3kiLCJjb25maWd1cmFibGUiLCJfZmx1c2giLCJfdHJhbnNmb3JtIiwia2luZCIsIl90aGlzMiIsIndzIiwiX3dyaXRhYmxlU3RhdGUiLCJlbmRpbmciLCJuZWVkRHJhaW4iLCJlbWl0Q2xvc2VOVCIsImVuY29kaW5nIiwibGFzdCIsImF2YWlsSW5CZWZvcmUiLCJhdmFpbE91dEJlZm9yZSIsImluT2ZmIiwiZXIiLCJyZXMiLCJhdmFpbEluQWZ0ZXIiLCJhdmFpbE91dEFmdGVyIiwiaGF2ZSIsIm5ld1JlcSIsIkNSQ19UQUJMRSIsIkludDMyQXJyYXkiLCJlbnN1cmVCdWZmZXIiLCJoYXNOZXdCdWZmZXJBUEkiLCJidWZmZXJpemVJbnQiLCJ3cml0ZUludDMyQkUiLCJfY3JjMzIiLCJwcmV2aW91cyIsInJlYWRVSW50MzJCRSIsImNyYyIsImNyYzMyIiwiYXBwbHkiLCJzaWduZWQiLCJ1bnNpZ25lZCIsImJhc2U2NCIsImllZWU3NTQiLCJpc0FycmF5IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiX19wcm90b19fIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsImNvcHkiLCJpc25hbiIsInRvTG93ZXJDYXNlIiwibGlzdCIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwidmFsIiwiZGlyIiwiaXNOYU4iLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwicmV0IiwidG9IZXgiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsImRzdCIsIm9iamVjdFRvU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc051bWJlciIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsInJlIiwiaXNPYmplY3QiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImNoZWNrTGlzdGVuZXIiLCJsaXN0ZW5lciIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJkb0Vycm9yIiwiZXZlbnRzIiwiY29udGV4dCIsImhhbmRsZXIiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwidyIsImVtaXR0ZXIiLCJjb3VudCIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzaGlmdCIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJwb3AiLCJldmVudExpc3RlbmVyIiwiZXJyb3JMaXN0ZW5lciIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiTmFOIiwicnQiLCJhYnMiLCJMTjIiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJnZXROYXRpdmUiLCJyb290IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJjbGVhciIsImhhcyIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJTZXQiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJ2YWx1ZXMiLCJfX2RhdGFfXyIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsIlN0YWNrIiwiV2Vha01hcCIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJiYXNlVGltZXMiLCJpc0luZGV4IiwiaXNUeXBlZEFycmF5Iiwib2JqZWN0UHJvdG8iLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYXJyYXlQdXNoIiwiYXJyYXlTb21lIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJiYXNlR2V0QWxsS2V5cyIsImtleXNGdW5jIiwic3ltYm9sc0Z1bmMiLCJnZXRSYXdUYWciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzRXF1YWwiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsImVxdWFsT2JqZWN0cyIsImdldFRhZyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiYXJyYXlUYWciLCJvYmplY3RUYWciLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImlzTWFza2VkIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsImlzTGVuZ3RoIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImlzUHJvdG90eXBlIiwibmF0aXZlS2V5cyIsImJhc2VLZXlzIiwiaXRlcmF0ZWUiLCJiYXNlVW5hcnkiLCJjYWNoZUhhcyIsImNhY2hlIiwiY29yZUpzRGF0YSIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJpc1BhcnRpYWwiLCJvdGhMZW5ndGgiLCJhcnJTdGFja2VkIiwib3RoU3RhY2tlZCIsInNlZW4iLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5Iiwic3ltYm9sVGFnIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsInRhZyIsImNvbnZlcnQiLCJzdGFja2VkIiwiZ2V0QWxsS2V5cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJvYmpTdGFja2VkIiwic2tpcEN0b3IiLCJvYmpWYWx1ZSIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZnJlZUdsb2JhbCIsImdldFN5bWJvbHMiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiZ2V0VmFsdWUiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJzeW1ib2wiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiQ3RvciIsImN0b3JTdHJpbmciLCJuYXRpdmVDcmVhdGUiLCJIQVNIX1VOREVGSU5FRCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJJRV9QUk9UTyIsInByb3RvIiwiYXJyYXlQcm90byIsInNwbGljZSIsIm92ZXJBcmciLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJmcmVlUHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJ0cmFuc2Zvcm0iLCJmcmVlU2VsZiIsIkxBUkdFX0FSUkFZX1NJWkUiLCJwYWlycyIsInRvTnVtYmVyIiwiRlVOQ19FUlJPUl9URVhUIiwibmF0aXZlTWF4IiwibmF0aXZlTWluIiwid2FpdCIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNsZWFyVGltZW91dCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJpc0FycmF5TGlrZSIsInN0dWJGYWxzZSIsIm5hdGl2ZUlzQnVmZmVyIiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJOQU4iLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsImlzQmluYXJ5IiwicHJvcElzRW51bWVyYWJsZSIsInRvT2JqZWN0Iiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJ0ZXN0MiIsIm9yZGVyMiIsInRlc3QzIiwibGV0dGVyIiwidG8iLCJzeW1ib2xzIiwiVFlQRURfT0siLCJVaW50MTZBcnJheSIsIl9oYXMiLCJzb3VyY2VzIiwic2hyaW5rQnVmIiwiZm5UeXBlZCIsImFycmF5U2V0IiwiZGVzdCIsInNyY19vZmZzIiwiZGVzdF9vZmZzIiwiZmxhdHRlbkNodW5rcyIsImNodW5rcyIsImZuVW50eXBlZCIsInNldFR5cGVkIiwiQnVmOCIsIkJ1ZjE2IiwiQnVmMzIiLCJhZGxlcjMyIiwiYWRsZXIiLCJzMSIsInMyIiwiWl9UUkVFUyIsIlpfTk9fQ09NUFJFU1NJT04iLCJaX0JFU1RfU1BFRUQiLCJaX0JFU1RfQ09NUFJFU1NJT04iLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsIm1ha2VUYWJsZSIsInRhYmxlIiwiayIsImNyY1RhYmxlIiwidXRpbHMiLCJ0cmVlcyIsIk1BWF9NRU1fTEVWRUwiLCJNQVhfV0JJVFMiLCJERUZfTUVNX0xFVkVMIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyb3JDb2RlIiwicmFuayIsInplcm8iLCJmbHVzaF9wZW5kaW5nIiwicGVuZGluZyIsInBlbmRpbmdfYnVmIiwicGVuZGluZ19vdXQiLCJ0b3RhbF9vdXQiLCJmbHVzaF9ibG9ja19vbmx5IiwiX3RyX2ZsdXNoX2Jsb2NrIiwiYmxvY2tfc3RhcnQiLCJzdHJzdGFydCIsInB1dF9ieXRlIiwicHV0U2hvcnRNU0IiLCJyZWFkX2J1ZiIsIndyYXAiLCJ0b3RhbF9pbiIsImxvbmdlc3RfbWF0Y2giLCJjdXJfbWF0Y2giLCJjaGFpbl9sZW5ndGgiLCJtYXhfY2hhaW5fbGVuZ3RoIiwic2NhbiIsImJlc3RfbGVuIiwicHJldl9sZW5ndGgiLCJuaWNlX21hdGNoIiwid19zaXplIiwiX3dpbiIsIndtYXNrIiwid19tYXNrIiwicHJldiIsInN0cmVuZCIsInNjYW5fZW5kMSIsInNjYW5fZW5kIiwiZ29vZF9tYXRjaCIsImxvb2thaGVhZCIsIm1hdGNoX3N0YXJ0IiwiZmlsbF93aW5kb3ciLCJfd19zaXplIiwibW9yZSIsIndpbmRvd19zaXplIiwiaGFzaF9zaXplIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwiZGVmbGF0ZV9zdG9yZWQiLCJtYXhfYmxvY2tfc2l6ZSIsInBlbmRpbmdfYnVmX3NpemUiLCJtYXhfc3RhcnQiLCJkZWZsYXRlX2Zhc3QiLCJoYXNoX2hlYWQiLCJiZmx1c2giLCJtYXRjaF9sZW5ndGgiLCJfdHJfdGFsbHkiLCJtYXhfbGF6eV9tYXRjaCIsImxhc3RfbGl0IiwiZGVmbGF0ZV9zbG93IiwibWF4X2luc2VydCIsInByZXZfbWF0Y2giLCJtYXRjaF9hdmFpbGFibGUiLCJkZWZsYXRlX3JsZSIsImRlZmxhdGVfaHVmZiIsIkNvbmZpZyIsImdvb2RfbGVuZ3RoIiwibWF4X2xhenkiLCJuaWNlX2xlbmd0aCIsIm1heF9jaGFpbiIsImNvbmZpZ3VyYXRpb25fdGFibGUiLCJsbV9pbml0IiwiRGVmbGF0ZVN0YXRlIiwiZ3poZWFkIiwiZ3ppbmRleCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbGVuIiwiaGVhcF9tYXgiLCJkZXB0aCIsImxfYnVmIiwibGl0X2J1ZnNpemUiLCJkX2J1ZiIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwibWF0Y2hlcyIsImJpX2J1ZiIsImJpX3ZhbGlkIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImRhdGFfdHlwZSIsIl90cl9pbml0IiwiZGVmbGF0ZVNldEhlYWRlciIsImRlZmxhdGVJbml0Iiwib2xkX2ZsdXNoIiwiYmVnIiwiaGNyYyIsImV4dHJhIiwiY29tbWVudCIsIm9zIiwibGV2ZWxfZmxhZ3MiLCJic3RhdGUiLCJfdHJfYWxpZ24iLCJfdHJfc3RvcmVkX2Jsb2NrIiwiZGljdExlbmd0aCIsImF2YWlsIiwidG1wRGljdCIsImRlZmxhdGVJbmZvIiwiQkFEIiwiVFlQRSIsImluZmxhdGVfZmFzdCIsIl9pbiIsIl9vdXQiLCJkbWF4Iiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwic193aW5kb3ciLCJob2xkIiwiYml0cyIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwiZGlzdCIsImZyb21fc291cmNlIiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwiZG9sZW4iLCJkb2Rpc3QiLCJzYW5lIiwiaW5mbGF0ZV90YWJsZSIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwiSEVBRCIsIkZMQUdTIiwiVElNRSIsIk9TIiwiRVhMRU4iLCJFWFRSQSIsIk5BTUUiLCJDT01NRU5UIiwiSENSQyIsIkRJQ1RJRCIsIkRJQ1QiLCJUWVBFRE8iLCJTVE9SRUQiLCJDT1BZXyIsIkNPUFkiLCJUQUJMRSIsIkxFTkxFTlMiLCJDT0RFTEVOUyIsIkxFTl8iLCJMRU4iLCJMRU5FWFQiLCJESVNUIiwiRElTVEVYVCIsIk1BVENIIiwiTElUIiwiQ0hFQ0siLCJMRU5HVEgiLCJET05FIiwiTUVNIiwiU1lOQyIsIkVOT1VHSF9MRU5TIiwiRU5PVUdIX0RJU1RTIiwiREVGX1dCSVRTIiwienN3YXAzMiIsIkluZmxhdGVTdGF0ZSIsImhhdmVkaWN0IiwiZmxhZ3MiLCJ0b3RhbCIsIndiaXRzIiwibmNvZGUiLCJubGVuIiwibmRpc3QiLCJ3b3JrIiwibGVuZHluIiwiZGlzdGR5biIsImJhY2siLCJ3YXMiLCJpbmZsYXRlUmVzZXRLZWVwIiwiaW5mbGF0ZVJlc2V0MiIsImluZmxhdGVJbml0IiwidmlyZ2luIiwibGVuZml4IiwiZGlzdGZpeCIsImZpeGVkdGFibGVzIiwic3ltIiwidXBkYXRld2luZG93IiwicHV0IiwiaGVyZV9iaXRzIiwiaGVyZV9vcCIsImhlcmVfdmFsIiwibGFzdF9iaXRzIiwibGFzdF9vcCIsImxhc3RfdmFsIiwiaGJ1ZiIsIm9yZGVyIiwiaW5mX2xlYXZlIiwieGZsYWdzIiwiZXh0cmFfbGVuIiwiaW5mbGF0ZUdldEhlYWRlciIsImRpY3RpZCIsImluZmxhdGVJbmZvIiwiTUFYQklUUyIsImxiYXNlIiwibGV4dCIsImRiYXNlIiwiZGV4dCIsImxlbnNfaW5kZXgiLCJ0YWJsZV9pbmRleCIsImN1cnIiLCJkcm9wIiwidXNlZCIsImh1ZmYiLCJpbmNyIiwibG93IiwibWFzayIsImJhc2UiLCJiYXNlX2luZGV4Iiwib2ZmcyIsImV4dHJhX2luZGV4IiwiU1RPUkVEX0JMT0NLIiwiU1RBVElDX1RSRUVTIiwiRFlOX1RSRUVTIiwiQnVmX3NpemUiLCJNQVhfQkxfQklUUyIsIkVORF9CTE9DSyIsIlJFUF8zXzYiLCJSRVBaXzNfMTAiLCJSRVBaXzExXzEzOCIsImV4dHJhX2xiaXRzIiwiZXh0cmFfZGJpdHMiLCJleHRyYV9ibGJpdHMiLCJibF9vcmRlciIsIkRJU1RfQ09ERV9MRU4iLCJzdGF0aWNfbHRyZWUiLCJzdGF0aWNfZHRyZWUiLCJfZGlzdF9jb2RlIiwiX2xlbmd0aF9jb2RlIiwiYmFzZV9sZW5ndGgiLCJiYXNlX2Rpc3QiLCJTdGF0aWNUcmVlRGVzYyIsInN0YXRpY190cmVlIiwiZXh0cmFfYml0cyIsImV4dHJhX2Jhc2UiLCJlbGVtcyIsIm1heF9sZW5ndGgiLCJoYXNfc3RyZWUiLCJzdGF0aWNfbF9kZXNjIiwic3RhdGljX2RfZGVzYyIsInN0YXRpY19ibF9kZXNjIiwiVHJlZURlc2MiLCJkeW5fdHJlZSIsInN0YXRfZGVzYyIsIm1heF9jb2RlIiwiZF9jb2RlIiwicHV0X3Nob3J0Iiwic2VuZF9iaXRzIiwic2VuZF9jb2RlIiwidHJlZSIsImJpX3JldmVyc2UiLCJiaV9mbHVzaCIsImdlbl9iaXRsZW4iLCJkZXNjIiwic3RyZWUiLCJ4Yml0cyIsIm92ZXJmbG93IiwiZ2VuX2NvZGVzIiwibmV4dF9jb2RlIiwidHJfc3RhdGljX2luaXQiLCJpbml0X2Jsb2NrIiwiYmlfd2luZHVwIiwiY29weV9ibG9jayIsInNtYWxsZXIiLCJfbjIiLCJfbTIiLCJwcWRvd25oZWFwIiwiY29tcHJlc3NfYmxvY2siLCJsdHJlZSIsImR0cmVlIiwibGMiLCJseCIsImJ1aWxkX3RyZWUiLCJzY2FuX3RyZWUiLCJwcmV2bGVuIiwiY3VybGVuIiwibmV4dGxlbiIsIm1heF9jb3VudCIsIm1pbl9jb3VudCIsInNlbmRfdHJlZSIsImJ1aWxkX2JsX3RyZWUiLCJtYXhfYmxpbmRleCIsInNlbmRfYWxsX3RyZWVzIiwibGNvZGVzIiwiZGNvZGVzIiwiYmxjb2RlcyIsImRldGVjdF9kYXRhX3R5cGUiLCJibGFja19tYXNrIiwic3RhdGljX2luaXRfZG9uZSIsInN0b3JlZF9sZW4iLCJvcHRfbGVuYiIsInN0YXRpY19sZW5iIiwiWlN0cmVhbSIsInZlcnNpb24iLCJmbiIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInJ1biIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbnMiLCJub29wIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsInBuYSIsIkR1cGxleCIsIldyaXRhYmxlIiwicmVhZGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25lbmQiLCJvbkVuZE5UIiwiUGFzc1Rocm91Z2giLCJSZWFkYWJsZVN0YXRlIiwiRUUiLCJFRWxpc3RlbmVyQ291bnQiLCJTdHJlYW0iLCJPdXJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZWJ1Z1V0aWwiLCJkZWJ1Z2xvZyIsIkJ1ZmZlckxpc3QiLCJkZXN0cm95SW1wbCIsIlN0cmluZ0RlY29kZXIiLCJrUHJveHlFdmVudHMiLCJpc0R1cGxleCIsIm9iamVjdE1vZGUiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJod20iLCJyZWFkYWJsZUh3bSIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImRlZmF1bHRFbmNvZGluZyIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJuZWVkTW9yZURhdGEiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwiZW5jIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJtYXliZVJlYWRNb3JlXyIsInBpcGUiLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZGF0YSIsImluY3JlYXNlZEF3YWl0RHJhaW4iLCJwYXVzZSIsInJlc3VtZSIsImRlc3RzIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsIl9mcm9tTGlzdCIsImZyb21MaXN0UGFydGlhbCIsImhhc1N0cmluZ3MiLCJjb3B5RnJvbUJ1ZmZlclN0cmluZyIsImNvcHlGcm9tQnVmZmVyIiwibmIiLCJ0YWlsIiwiZW5kUmVhZGFibGVOVCIsInhzIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2IiLCJ3cml0ZWNodW5rIiwicnMiLCJuZWVkVHJhbnNmb3JtIiwid3JpdGVlbmNvZGluZyIsInByZWZpbmlzaCIsImVycjIiLCJXcml0ZVJlcSIsIkNvcmtlZFJlcXVlc3QiLCJmaW5pc2giLCJvbkNvcmtlZEZpbmlzaCIsImFzeW5jV3JpdGUiLCJzZXRJbW1lZGlhdGUiLCJXcml0YWJsZVN0YXRlIiwiaW50ZXJuYWxVdGlsIiwiZGVwcmVjYXRlIiwibm9wIiwid3JpdGFibGVPYmplY3RNb2RlIiwid3JpdGFibGVId20iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJmaW5hbENhbGxlZCIsImZpbmlzaGVkIiwibm9EZWNvZGUiLCJkZWNvZGVTdHJpbmdzIiwid3JpdGluZyIsImNvcmtlZCIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwicHJlZmluaXNoZWQiLCJlcnJvckVtaXR0ZWQiLCJidWZmZXJlZFJlcXVlc3RDb3VudCIsImNvcmtlZFJlcXVlc3RzRnJlZSIsImdldEJ1ZmZlciIsImN1cnJlbnQiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZmluYWwiLCJfZmluYWwiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsInZhbGlkIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwibmVlZCIsImNvcmtSZXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiY29weUJ1ZmZlciIsImN1c3RvbSIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsImNvcHlQcm9wcyIsIlNhZmVCdWZmZXIiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJfaXNTdGRpbyIsImRpZE9uRW5kIiwiX25vcm1hbGl6ZUVuY29kaW5nIiwicmV0cmllZCIsIm5vcm1hbGl6ZUVuY29kaW5nIiwibmVuYyIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwic2NvcGUiLCJUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsIlppcEZpbGUiLCJVdGlscyIsInhociIsImNyZWF0ZVppcEZpbGUiLCJFIiwicmVzcG9uc2VUeXBlIiwicmVhZEVPQ0RSZWNvcmQiLCJlb2NkciIsInJlYWRVSW50NjRMRSIsImNwNDM3VG9Vbmljb2RlIiwiZml4ZWRGaWVsZHNTaXplIiwibWF4UmVjb3JkU2l6ZSIsInJlY29yZEJ1ZmZlciIsImVudHJ5Q291bnQiLCJjZFNpemUiLCJjZE9mZnNldCIsImNvbW1lbnRMZW5ndGgiLCJyZWFkRU9DRDY0UmVjb3JkIiwiZW9jZDY0ciIsImVvY2RPZmZzZXQiLCJyZWFkRU9DRExvY2F0b3IiLCJlb2NkNjRPZmZzZXQiLCJsb2NhdG9yUmVjb3JkU2l6ZSIsImNvbnZlcnRlZEJ1ZmZlciIsIk1BWF9DSFVOS19TSVpFIiwiX2NkU2l6ZSIsIl9jZE9mZnNldCIsImNhbGxlZCIsInJlYWRTdHJlYW0iLCJvblJlYWRhYmxlIiwiZGVzdHJveUFuZERyYWluIiwiZml4ZWRGaWVsZHNCdWZmZXIiLCJFbnRyeSIsInZlcnNpb25NYWRlQnkiLCJ2ZXJzaW9uTmVlZGVkVG9FeHRyYWN0IiwiZ2VuZXJhbFB1cnBvc2VCaXRGbGFnIiwiY29tcHJlc3Npb25NZXRob2QiLCJsYXN0TW9kVGltZSIsImxhc3RNb2REYXRlIiwiY29tcHJlc3NlZFNpemUiLCJ1bmNvbXByZXNzZWRTaXplIiwibmFtZUxlbmd0aCIsImV4dHJhRmllbGRzTGVuZ3RoIiwiaW50ZXJuYWxBdHRyaWJ1dGVzIiwiZXh0ZXJuYWxBdHRyaWJ1dGVzIiwibG9jYWxIZWFkZXJPZmZzZXQiLCJ2YXJpYWJsZUZpZWxkc1NpemUiLCJ2YXJpYWJsZUZpZWxkc0J1ZmZlciIsImV4dHJhRmllbGRzQnVmZmVyIiwiaGVhZGVySWQiLCJkYXRhU2l6ZSIsImV4dHJhRmllbGRzIiwiaXNVVEY4IiwiZmllbGQiLCJvbGREYXRhIiwiaW5mb1ppcFVFRnMiLCJlZiIsImluZm9aaXBVRUYiLCJ2ZXJzaW9uUmVjb2duaXplZCIsImNyY0NoZWNrUGFzc2VkIiwiemlwNjRFSUVGIiwiZmllbGRzIiwiY2hlY2tDcmMiLCJlbmNyeXB0ZWQiLCJleHRyYUZpZWxkTGVuZ3RoIiwiZGF0YVN0YXJ0Iiwib3V0U3RyZWFtIiwicGFydGlhbENyYyIsImNyY1RyYW5zZm9ybSIsImZpbmFsQ3JjIiwibGFzdE1vZERhdGVUaW1lIiwiY29uZmlnIiwiZGVwcmVjYXRlZCIsInRyYWNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZm9ybWF0UmVnRXhwIiwiZm9ybWF0Iiwib2JqZWN0cyIsIm5vRGVwcmVjYXRpb24iLCJ0aHJvd0RlcHJlY2F0aW9uIiwidHJhY2VEZXByZWNhdGlvbiIsImRlYnVncyIsImRlYnVnRW52aXJvbiIsIk5PREVfREVCVUciLCJwaWQiLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJjb2xvcnMiLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJyZWN1cnNlVGltZXMiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImZvcm1hdEVycm9yIiwiYnJhY2VzIiwidG9VVENTdHJpbmciLCJmb3JtYXRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJudW1MaW5lc0VzdCIsImN1ciIsImFyIiwicGFkIiwibW9udGhzIiwidGltZXN0YW1wIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsIm9yaWdpbiIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInNldFByb3RvdHlwZU9mIiwiY2FsbGJhY2tpZnlPblJlamVjdGVkIiwicmVhc29uIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIndlYnBhY2tQb2x5ZmlsbCIsInBhdGhzIiwiY2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNB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TUFBSjtBQUNoQyxDLENBRUQ7QUFDQTtBQUNBOzs7QUFFQW1TLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQnJjLENBQWpCLEM7Ozs7Ozs7Ozs7O0FDbkJBb2MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVNELE1BQVQsRUFBaUI7QUFDakMsTUFBSSxDQUFDQSxNQUFNLENBQUN1bEQsZUFBWixFQUE2QjtBQUM1QnZsRCxVQUFNLENBQUMyMEMsU0FBUCxHQUFtQixZQUFXLENBQUUsQ0FBaEM7O0FBQ0EzMEMsVUFBTSxDQUFDd2xELEtBQVAsR0FBZSxFQUFmLENBRjRCLENBRzVCOztBQUNBLFFBQUksQ0FBQ3hsRCxNQUFNLENBQUN5bEQsUUFBWixFQUFzQnpsRCxNQUFNLENBQUN5bEQsUUFBUCxHQUFrQixFQUFsQjtBQUN0QmovRCxVQUFNLENBQUMrbkIsY0FBUCxDQUFzQnZPLE1BQXRCLEVBQThCLFFBQTlCLEVBQXdDO0FBQ3ZDd08sZ0JBQVUsRUFBRSxJQUQyQjtBQUV2QzNrQixTQUFHLEVBQUUsWUFBVztBQUNmLGVBQU9tVyxNQUFNLENBQUMvYixDQUFkO0FBQ0E7QUFKc0MsS0FBeEM7QUFNQXVDLFVBQU0sQ0FBQytuQixjQUFQLENBQXNCdk8sTUFBdEIsRUFBOEIsSUFBOUIsRUFBb0M7QUFDbkN3TyxnQkFBVSxFQUFFLElBRHVCO0FBRW5DM2tCLFNBQUcsRUFBRSxZQUFXO0FBQ2YsZUFBT21XLE1BQU0sQ0FBQ3BiLENBQWQ7QUFDQTtBQUprQyxLQUFwQztBQU1Bb2IsVUFBTSxDQUFDdWxELGVBQVAsR0FBeUIsQ0FBekI7QUFDQTs7QUFDRCxTQUFPdmxELE1BQVA7QUFDQSxDQXJCRCxDOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9hcHAvanMvaW5kZXguanNcIik7XG4iLCJpbXBvcnQgeyBjYWxsLCBzZXRQcm9wIH0gZnJvbSBcIi4vYXBpXCJcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gXCIuL2RhdGFcIlxuaW1wb3J0IHsgc2VuZCB9IGZyb20gXCIuL3dzXCJcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVGaWxlKCkge1xuXHRjb25zdCBoYW5kbGUgPSBhd2FpdCBzaG93U2F2ZUZpbGVQaWNrZXIoKVxuXHRjb25zb2xlLmxvZyhoYW5kbGUpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuRmlsZSgpIHtcblx0Y29uc3QgaGFuZGxlID0gYXdhaXQgc2hvd09wZW5GaWxlUGlja2VyKClcblx0Y29uc29sZS5sb2coaGFuZGxlKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRTaG93KCkge1xuXHRzZW5kKCcjPkJFR0lOJylcblx0Y2FsbCgnI3BsYXllcicsICdwbGF5Jylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuZFNob3coKSB7XG5cdHNlbmQoJyM+RU5EJylcblx0c2V0UHJvcCgnI3BsYXllcicsICdjdXJyZW50VGltZScsIENPTkZJRy5wYXJhbXMuZW5kIC8gMTAwMClcblx0Y2FsbCgnI3BsYXllcicsICdwYXVzZScpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXVzZVNob3coKSB7XG5cdGNhbGwoJyNwbGF5ZXInLCAncGF1c2UnKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzdW1lU2hvdygpIHtcblx0Y2FsbCgnI3BsYXllcicsICdwbGF5Jylcbn1cbiIsIi8qKlxuICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC4gQ29udmVyc2lvbiBmb3JtdWxhXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG4gKiBBc3N1bWVzIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBhbmRcbiAqIHJldHVybnMgaCwgcywgYW5kIGwgaW4gdGhlIHNldCBbMCwgMV0uXG4gKlxuICogQHJldHVybiAgQXJyYXkgICAgICAgICAgIFRoZSBIU0wgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSByIE51bWJlclxuICogQHBhcmFtIGcgTnVtYmVyXG4gKiBAcGFyYW0gYiBOdW1iZXJcbiAqL1xuXG5pbXBvcnQgeyBDT05GSUcgfSBmcm9tIFwiLi9kYXRhXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cmFpbih2YWx1ZSwgbWluLCBtYXgpIHtcblx0cmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZVxufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcCh2YWx1ZSwgZnJvbU1pbiwgZnJvbU1heCwgdG9NaW4sIHRvTWF4KSB7XG5cdHJldHVybiB0b01pbiArICh0b01heCAtIHRvTWluKSAqICgodmFsdWUgLSBmcm9tTWluKSAvIChmcm9tTWF4IC0gZnJvbU1pbikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hzbChyLCBnLCBiKSB7XG5cdHIgLz0gMjU1XG5cdGcgLz0gMjU1XG5cdGIgLz0gMjU1XG5cblx0bGV0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuXHRsZXQgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMlxuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSBzID0gMCAvLyBhY2hyb21hdGljXG5cdH0gZWxzZSB7XG5cdFx0bGV0IGQgPSBtYXggLSBtaW5cblx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbilcblxuXHRcdHN3aXRjaCAobWF4KSB7XG5cdFx0XHRjYXNlIHI6XG5cdFx0XHRcdGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSBnOlxuXHRcdFx0XHRoID0gKGIgLSByKSAvIGQgKyAyXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIGI6XG5cdFx0XHRcdGggPSAociAtIGcpIC8gZCArIDRcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRoIC89IDZcblx0fVxuXG5cdHJldHVybiB7IGgsIHMsIGwgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuIENvbnZlcnNpb24gZm9ybXVsYVxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxuICogQXNzdW1lcyBoLCBzLCBhbmQgbCBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZFxuICogcmV0dXJucyByLCBnLCBhbmQgYiBpbiB0aGUgc2V0IFswLCAyNTVdLlxuICpcbiAqIEByZXR1cm4gIE9iamVjdCAgICAgICAgICAgVGhlIFJHQiByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIGhcbiAqIEBwYXJhbSBzXG4gKiBAcGFyYW0gbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuXHRsZXQgciwgZywgYlxuXG5cdGlmIChzID09PSAwKSB7XG5cdFx0ciA9IGcgPSBiID0gbCAvLyBhY2hyb21hdGljXG5cdH0gZWxzZSB7XG5cdFx0Z2xvYmFsLmh1ZTJyZ2IgPSBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcblx0XHRcdGlmICh0IDwgMCkgdCArPSAxXG5cdFx0XHRpZiAodCA+IDEpIHQgLT0gMVxuXHRcdFx0aWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRcblx0XHRcdGlmICh0IDwgMSAvIDIpIHJldHVybiBxXG5cdFx0XHRpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDZcblx0XHRcdHJldHVybiBwXG5cdFx0fVxuXG5cdFx0bGV0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzXG5cdFx0bGV0IHAgPSAyICogbCAtIHFcblxuXHRcdHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMylcblx0XHRnID0gaHVlMnJnYihwLCBxLCBoKVxuXHRcdGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMylcblx0fVxuXG5cdHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWLiBDb252ZXJzaW9uIGZvcm11bGFcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTVl9jb2xvcl9zcGFjZS5cbiAqIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxuICogcmV0dXJucyBoLCBzLCBhbmQgdiBpbiB0aGUgc2V0IFswLCAxXS5cbiAqXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgVGhlIEhTViByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHJcbiAqIEBwYXJhbSBnXG4gKiBAcGFyYW0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9Ic3YociwgZywgYikge1xuXHRyIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1XG5cblx0bGV0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuXHRsZXQgaCwgcywgdiA9IG1heFxuXG5cdGxldCBkID0gbWF4IC0gbWluXG5cdHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heFxuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwIC8vIGFjaHJvbWF0aWNcblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKG1heCkge1xuXHRcdFx0Y2FzZSByOlxuXHRcdFx0XHRoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgZzpcblx0XHRcdFx0aCA9IChiIC0gcikgLyBkICsgMlxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSBiOlxuXHRcdFx0XHRoID0gKHIgLSBnKSAvIGQgKyA0XG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0aCAvPSA2XG5cdH1cblxuXHRyZXR1cm4geyBoLCBzLCB2IH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBIU1YgY29sb3IgdmFsdWUgdG8gUkdCLiBDb252ZXJzaW9uIGZvcm11bGFcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTVl9jb2xvcl9zcGFjZS5cbiAqIEFzc3VtZXMgaCwgcywgYW5kIHYgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAxXSBhbmRcbiAqIHJldHVybnMgciwgZywgYW5kIGIgaW4gdGhlIHNldCBbMCwgMjU1XS5cbiAqXG4gKiBAcmV0dXJuICBPYmplY3QgICAgICAgICAgIFRoZSBSR0IgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBoXG4gKiBAcGFyYW0gc1xuICogQHBhcmFtIHZcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaHN2VG9SZ2IoaCwgcywgdikge1xuXHRsZXQgciwgZywgYlxuXG5cdGxldCBpID0gTWF0aC5mbG9vcihoICogNilcblx0bGV0IGYgPSBoICogNiAtIGlcblx0bGV0IHAgPSB2ICogKDEgLSBzKVxuXHRsZXQgcSA9IHYgKiAoMSAtIGYgKiBzKVxuXHRsZXQgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKVxuXG5cdHN3aXRjaCAoaSAlIDYpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRyID0gdlxuXHRcdFx0ZyA9IHRcblx0XHRcdGIgPSBwXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTpcblx0XHRcdHIgPSBxXG5cdFx0XHRnID0gdlxuXHRcdFx0YiA9IHBcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAyOlxuXHRcdFx0ciA9IHBcblx0XHRcdGcgPSB2XG5cdFx0XHRiID0gdFxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDM6XG5cdFx0XHRyID0gcFxuXHRcdFx0ZyA9IHFcblx0XHRcdGIgPSB2XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHIgPSB0XG5cdFx0XHRnID0gcFxuXHRcdFx0YiA9IHZcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSA1OlxuXHRcdFx0ciA9IHZcblx0XHRcdGcgPSBwXG5cdFx0XHRiID0gcVxuXHRcdFx0YnJlYWtcblx0fVxuXG5cdHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiAkKHNlbGVjdG9yKSB7XG5cdHJldHVybiBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0VGV4dChzZWxlY3RvciwgdGV4dCkge1xuXHRpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblx0JChzZWxlY3RvcikuZm9yRWFjaChlbCA9PiB7XG5cdFx0ZWwuaW5uZXJIVE1MID0gdGV4dFxuXHR9KVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhbHVlKHNlbGVjdG9yLCB2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cdCQoc2VsZWN0b3IpLmZvckVhY2goZWwgPT4ge1xuXHRcdGVsLnZhbHVlID0gdmFsdWVcblx0fSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wKHNlbGVjdG9yLCBwcm9wLCB2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cdCQoc2VsZWN0b3IpLmZvckVhY2goZWwgPT4ge1xuXHRcdGVsW3Byb3BdID0gdmFsdWVcblx0fSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRBdHRyKHNlbGVjdG9yLCBhdHRyLCB2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cdCQoc2VsZWN0b3IpLmZvckVhY2goZWwgPT4ge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcblx0fSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGljayhzZWxlY3Rvcikge1xuXHQkKHNlbGVjdG9yKS5mb3JFYWNoKGVsID0+IHtcblx0XHRlbC5jbGljaygpXG5cdH0pXG59XG5leHBvcnQgZnVuY3Rpb24gY2FsbChzZWxlY3RvciwgbWV0aG9kLCAuLi5hcmdzKSB7XG5cdCQoc2VsZWN0b3IpLmZvckVhY2goZWwgPT4ge1xuXHRcdGlmICh0eXBlb2YgZWxbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZWxbbWV0aG9kXS5jYWxsKGVsLCAuLi5hcmdzKVxuXHRcdH1cblx0fSlcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0KG1ldGhvZCA9ICdQT1NUJywgcGF0aCA9ICcnLCBhcmdzID0ge30sIGJvZHkgPSBudWxsKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0XG5cdFx0Y29uc3QgcGFyYW1zID0gT2JqZWN0LmVudHJpZXMoYXJncylcblx0XHRjb25zdCB1cmkgPSBwYXRoICsgKHBhcmFtcy5sZW5ndGggPyAnPycgKyBwYXJhbXMubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09JHt2YWx1ZX1gKS5qb2luKCcmJykgOiAnJylcblx0XHRjb25zdCBzaXplID0gYm9keSA/IGAgWyR7Ym9keS5zaXplIHx8IGJvZHkubGVuZ3RofSBLYl1gIDogJydcblx0XHRjb25zdCBvdXRwdXQgPSBjb25zb2xlLmRlYnVnKGAke21ldGhvZH0gJHt1cml9ICR7c2l6ZX0uLi4gYClcblxuXHRcdHJlcS5vcGVuKG1ldGhvZCwgdXJpLCB0cnVlKVxuXHRcdHJlcS5zZW5kKGJvZHkpXG5cdFx0cmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCAoKSA9PiB7XG5cdFx0XHRpZiAob3V0cHV0KSB7XG5cdFx0XHRcdC8vIG91dHB1dC5pbm5lckhUTUwgKz0gYFske3JlcS5zdGF0dXN9ICR7cmVxLnN0YXR1c1RleHR9XSAke3JlcS5yZXNwb25zZVRleHQuc3BsaXQoXCJcXG5cIilbMF19YFxuXHRcdFx0XHRvdXRwdXQuaW5uZXJIVE1MICs9IGBbJHtyZXEuc3RhdHVzfSAke3JlcS5zdGF0dXNUZXh0fV1gXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnLS0nLCBgWyR7cmVxLnN0YXR1c30gJHtyZXEuc3RhdHVzVGV4dH1dYClcblx0XHRcdH1cblx0XHRcdGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0aWYgKHJlcS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuXHRcdFx0XHRcdHJlc29sdmUoSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KSwgcmVxKVxuXHRcdFx0XHR9IGVsc2UgcmVzb2x2ZShyZXEucmVzcG9uc2VUZXh0LCByZXEpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWplY3QoKVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KVxuXHR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hGaWxlKHBhdGgsIHR5cGUgPSAnJykge1xuXHRjb25zdCAkcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcblx0Y29uc3QgJG91dHB1dCA9IGNvbnNvbGUuZGVidWcoYEZFVENIICR7cGF0aH0gLi4uIGApXG5cdGlmICgkb3V0cHV0KSAkb3V0cHV0LmFwcGVuZENoaWxkKCRwcm9ncmVzcylcblx0bGV0IGNhbmNlbGVkXG5cdGxldCBwcm9ncmVzc1xuXHRsZXQgcmVzcG9uc2Vcblx0bGV0IHN0cmVhbVxuXHRsZXQgYnl0ZXNSZWFkID0gMFxuXHRjb25zdCBkYXRhID0gW11cblx0Y29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRyZXNwb25zZSA9IGF3YWl0IGZldGNoKHBhdGgpXG5cdFx0c3RyZWFtID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKVxuXHRcdGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBzdHJlYW0ucmVhZCgpXG5cdFx0XHRcdGlmICghZG9uZSkge1xuXHRcdFx0XHRcdGlmIChjYW5jZWxlZCkge1xuXHRcdFx0XHRcdFx0c3RyZWFtLmNhbmNlbCgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ynl0ZXNSZWFkICs9IHZhbHVlLmxlbmd0aFxuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHZhbHVlKVxuXHRcdFx0XHRcdFx0aWYgKHByb2dyZXNzKSBwcm9ncmVzcyhieXRlc1JlYWQpXG5cdFx0XHRcdFx0XHRpZiAoJHByb2dyZXNzKSB7XG5cdFx0XHRcdFx0XHRcdCRwcm9ncmVzcy5pbm5lclRleHQgPSBgJHtmb3JtYXRCeXRlcyhieXRlc1JlYWQpfWBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2V0VGltZW91dChuZXh0KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjYW5jZWxlZCkge1xuXHRcdFx0XHRcdFx0JHByb2dyZXNzLmlubmVyVGV4dCArPSAnIENBTkNFTEVEJ1xuXHRcdFx0XHRcdFx0cmVqZWN0KClcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgZmlsZSA9IG5ldyBCbG9iKGRhdGEsIHsgdHlwZSB9KVxuXHRcdFx0XHRcdFx0JHByb2dyZXNzLmlubmVyVGV4dCArPSAnIE9LJ1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShmaWxlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKVxuXHRcdFx0XHRyZWplY3QoKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRzZXRUaW1lb3V0KG5leHQpXG5cdH0pXG5cdHByb21pc2UucHJvZ3Jlc3MgPSAoY2FsbGJhY2spID0+IHtcblx0XHRwcm9ncmVzcyA9IGNhbGxiYWNrXG5cdFx0cmV0dXJuIHByb21pc2Vcblx0fVxuXHRwcm9taXNlLmNhbmNlbCA9ICgpID0+IHtcblx0XHRjYW5jZWxlZCA9IHRydWVcblx0XHQvLyBpZiAoc3RyZWFtKSBzdHJlYW0uY2FuY2VsKClcblx0XHRyZXR1cm4gcHJvbWlzZVxuXHR9XG5cdHJldHVybiBwcm9taXNlXG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZShwYXRoLCBib2R5LCBzeW5jID0gZmFsc2UsIHRhcmdldCA9IG51bGwsIHVzZVNEID0gZmFsc2UpIHtcblx0Y29uc3QgZmlsZSA9IG5ldyBCbG9iKFtib2R5XSlcblx0Y29uc3Qgb3V0cHV0ID0gY29uc29sZS5kZWJ1ZyhgVVBMT0FEICR7cGF0aH0gWyR7KGZpbGUuc2l6ZSAvIDEwMDApLnRvRml4ZWQoMil9IEtCXSAuLi4gYClcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXHRcdGZvcm0uYXBwZW5kKCdmaWxlbmFtZScsIHBhdGgpXG5cdFx0Zm9ybS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKVxuXHRcdHJlcS5vcGVuKCdQT1NUJywgYGVkaXQ/JHtzeW5jID8gJ3N5bmMnIDogJ25vc3luYyd9JHt0YXJnZXQgPyBgJnRhcmdldD0ke3RhcmdldH1gIDogJyd9JHt1c2VTRCA/ICcmc3RvcmFnZT1zZCcgOiAnJ31gLCB0cnVlKVxuXHRcdHJlcS5zZW5kKGZvcm0pXG5cdFx0cmVxLm9ubG9hZGVuZCA9IChlKSA9PiB7XG5cdFx0XHRpZiAob3V0cHV0KSB7XG5cdFx0XHRcdG91dHB1dC5pbm5lckhUTUwgKz0gYFske3JlcS5zdGF0dXN9ICR7cmVxLnN0YXR1c1RleHR9XWBcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCctLScsIGBbJHtyZXEuc3RhdHVzfSAke3JlcS5zdGF0dXNUZXh0fV1gKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRyZXNvbHZlKHJlcSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlamVjdChyZXEpXG5cdFx0XHR9XG5cdFx0fVxuXHR9KVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldChwYXRoLCBwYXJhbXMpIHtcblx0cmV0dXJuIHJlcXVlc3QoJ0dFVCcsIHBhdGgsIHBhcmFtcylcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3N0KHBhdGgsIHBhcmFtcywgYm9keSkge1xuXHRyZXR1cm4gcmVxdWVzdCgnUE9TVCcsIHBhdGgsIHBhcmFtcywgYm9keSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjKGNtZCkge1xuXHQvLyBjb25zb2xlLmxvZygnZXhlY3V0ZSAnICsgY21kKVxuXHRyZXR1cm4gcmVxdWVzdCgnUE9TVCcsICdleGVjJywgeyBjbWQgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJ5dGVzKGJ5dGVzKSB7XG5cdGlmIChieXRlcyA+PSAxMDAwMDAwMDAwKSByZXR1cm4gKGJ5dGVzIC8gMTAwMDAwMDAwMCkudG9QcmVjaXNpb24oMykgKyAnIEdCJ1xuXHRpZiAoYnl0ZXMgPj0gMTAwMDAwMCkgcmV0dXJuIChieXRlcyAvIDEwMDAwMDApLnRvUHJlY2lzaW9uKDMpICsgJyBNQidcblx0aWYgKGJ5dGVzID49IDEwMDApIHJldHVybiAoYnl0ZXMgLyAxMDAwKS50b1ByZWNpc2lvbigzKSArICcgS0InXG5cdHJldHVybiAnMC4wMCBCJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZShkdXJhdGlvbiwgc2hvd0hvdXIgPSBmYWxzZSkge1xuXHRjb25zdCBob3VyID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIDM2MDApXG5cdGNvbnN0IGhvdXJMZWZ0ID0gZHVyYXRpb24gJSAzNjAwXG5cdGNvbnN0IG1pbnV0ZSA9IE1hdGguZmxvb3IoaG91ckxlZnQgLyA2MClcblx0Y29uc3Qgc2Vjb25kID0gTWF0aC5mbG9vcihob3VyTGVmdCAlIDYwKVxuXHRjb25zdCBtcyA9IE1hdGguZmxvb3IoKGR1cmF0aW9uICUgMSkgKiAxMDApXG5cdGlmIChzaG93SG91ciB8fCBob3VyKVxuXHRcdHJldHVybiBbXG5cdFx0XHRob3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSxcblx0XHRcdG1pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksXG5cdFx0XHRzZWNvbmQudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpLFxuXHRcdFx0bXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpLFxuXHRcdF0uam9pbignOicpXG5cdGVsc2Vcblx0XHRyZXR1cm4gW1xuXHRcdFx0bWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSxcblx0XHRcdHNlY29uZC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksXG5cdFx0XHRtcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcblx0XHRdLmpvaW4oJzonKVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRDb21tYW5kKGNvbW1hbmQgPSAnJywgLi4uZGF0YSkge1xuXHRjb25zb2xlLmxvZygnU0VORCAnICsgY29tbWFuZCArICcgJyArIGRhdGEuam9pbignICcpKVxuXHRsZXQgc2VsZWN0ZWQgPSBDT05GSUcubm9kZXMuZmlsdGVyKG4gPT4gbi5zZWxlY3RlZCkubWFwKG4gPT4gbi5pZClcblx0aWYgKCFzZWxlY3RlZC5sZW5ndGgpIHNlbGVjdGVkID0gWycjJ11cblx0Zm9yIChsZXQgaWQgb2Ygc2VsZWN0ZWQpIHtcblx0XHRhd2FpdCBzZW5kKGlkLCBjb21tYW5kLnRvVXBwZXJDYXNlKCksIC4uLmRhdGEpXG5cdH1cbn1cbk9iamVjdC5hc3NpZ24oZ2xvYmFsLCB7XG5cdCQsXG5cdHNldFRleHQsXG5cdHNldFZhbHVlLFxuXHRzZXRQcm9wLFxuXHRzZXRBdHRyLFxuXHRjbGljayxcblx0Y2FsbCxcblx0cmVxdWVzdCxcblx0Z2V0LFxuXHRwb3N0LFxuXHR1cGxvYWRGaWxlLFxuXHRmZXRjaEZpbGUsXG5cdHNlbmRDb21tYW5kXG59KVxuIiwiaW1wb3J0IHsgJCwgbWFwLCBjb25zdHJhaW4gfSBmcm9tIFwiLi9hcGlcIlxuaW1wb3J0IHsgQVVESU8sIENPTkZJRywgU0hPVyB9IGZyb20gXCIuL2RhdGFcIlxuaW1wb3J0IHsgcmVuZGVyQXVkaW8gfSBmcm9tIFwiLi9hdWRpb1wiXG5pbXBvcnQgeyByZW5kZXJTaG93IH0gZnJvbSBcIi4vbGlnaHRcIlxuaW1wb3J0IHsgaGFuZGxlRW5kIH0gZnJvbSBcIi4vZXZlbnRzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckhlYWQoKSB7XG5cdCQoJ1tkYXRhLXNob3ddJykuZm9yRWFjaChlbCA9PiB7XG5cdFx0aWYgKHBhcnNlSW50KGVsLmRhdGFzZXQuc2hvdykgPT09IENPTkZJRy5zaG93KSB7XG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJylcblx0XHR9XG5cdH0pXG5cdCQoJyN0b29sYmFyJykuZm9yRWFjaChlbCA9PiB7XG5cdFx0ZWwuaW5uZXJIVE1MID0gYGBcblx0XHRpZiAoQ09ORklHLnJ1bm5pbmcpIHtcblx0XHRcdC8vIGVsLmlubmVySFRNTCA9IGA8YnV0dG9uIGRhdGEtYWN0aW9uPVwic2hvdy1zdG9wXCI+U1RPUDwvYnV0dG9uPmBcblx0XHRcdGVsLmlubmVySFRNTCArPSBgPHNwYW4gaWQ9XCJ0aW1lXCI+PC9zcGFuPmBcblx0XHRcdGlmIChDT05GSUcucGF1c2VkKVxuXHRcdFx0XHRlbC5pbm5lckhUTUwgKz0gYDxidXR0b24gZGF0YS1hY3Rpb249XCJyZXN1bWVTaG93XCI+UExBWTwvYnV0dG9uPmBcblx0XHRcdGVsc2Vcblx0XHRcdFx0ZWwuaW5uZXJIVE1MICs9IGA8YnV0dG9uIGRhdGEtYWN0aW9uPVwicGF1c2VTaG93XCI+UEFVU0U8L2J1dHRvbj5gXG5cdFx0fSBlbHNlIGlmIChBVURJTy5maWxlKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgKz0gYDxidXR0b24gZGF0YS1hY3Rpb249XCJzdGFydFNob3dcIj5TVEFSVDwvYnV0dG9uPmBcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWwuaW5uZXJIVE1MICs9IGA8YnV0dG9uIGRhdGEtYWN0aW9uPVwib3BlbkZpbGVcIj5VUExPQUQ8L2J1dHRvbj5gXG5cdFx0fVxuXHR9KVxuXHQvLyBjb25zdCB7IGlkLCBpcCwgbWFjLCBicmlnaHRuZXNzLCBjaGFubmVsLCBzaG93IH0gPSBDT05GSUdcblx0Ly8gc2V0VGV4dCgnI2lkJywgaWQpXG5cdC8vIHNldFRleHQoJyNpcCcsIGlwKVxuXHQvLyBzZXRUZXh0KCcjbWFjJywgbWFjKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTm9kZXMoKSB7XG5cdCQoJ3NlY3Rpb24ubm9kZXMnKS5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuXHRcdHNlY3Rpb24uaW5uZXJIVE1MID0gJydcblx0XHRDT05GSUcubm9kZXMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0aWYgKGEubmFtZSA+IGIubmFtZSkgcmV0dXJuIDFcblx0XHRcdGlmIChhLm5hbWUgPCBiLm5hbWUpIHJldHVybiAtMVxuXHRcdFx0cmV0dXJuIDBcblx0XHR9KS5mb3JFYWNoKG5vZGUgPT4geyBcdFxuXHRcdFx0Y29uc3QgJG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhcnRpY2xlJylcblx0XHRcdGNvbnN0IHZiYXQgPSBub2RlLmhpZGRlbiA/IDAgOiBub2RlLnZiYXQgLyAxMDAwXG5cdFx0XHRjb25zdCBwZXJjZW50ID0gY29uc3RyYWluKG1hcCh2YmF0LCAzLjAsIDQuMSwgMCwgMTAwKSwgMCwgMTAwKVxuXHRcdFx0JG5vZGUuY2xhc3NMaXN0LmFkZCgnbm9kZScpXG5cdFx0XHQkbm9kZS5kYXRhc2V0LmRyb3BwYWJsZSA9IHRydWVcblx0XHRcdGlmIChub2RlLnNlbGVjdGVkKSAkbm9kZS5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpXG5cdFx0XHRpZiAobm9kZS5oaWRkZW4pICRub2RlLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXG5cdFx0XHQkbm9kZS5pbm5lckhUTUwgPSBgXG5cdFx0XHQ8c21hbGw+JHtub2RlLmlkfTwvc21hbGw+XG5cdFx0XHQ8ZGl2PiR7bm9kZS5uYW1lfTwvZGl2PlxuXHRcdFx0PHNtYWxsPiR7dmJhdC50b1ByZWNpc2lvbigyKX12ICR7cGVyY2VudC50b0ZpeGVkKDApfSU8L3NtYWxsPlxuXHRcdFx0PHByb2dyZXNzIHZhbHVlPVwiJHtwZXJjZW50LnRvRml4ZWQoMCl9XCIgbWF4PVwiMTAwXCI+PC9wcm9ncmVzcz5cblx0XHRcdGBcblx0XHRcdCRub2RlLmRhdGFzZXQuZGV2aWNlID0gbm9kZS5pZFxuXHRcdFx0JG5vZGUuZGF0YXNldC5kcm9wcGFibGUgPSB0cnVlXG5cdFx0XHRzZWN0aW9uLmFwcGVuZENoaWxkKCRub2RlKVxuXHRcdH0pXG5cdH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja05vZGVzKCkge1xuXHR0cnkge1xuXHRcdGNvbnN0IGV4cGlyZWQgPSBEYXRlLm5vdygpIC0gMTUwMDA7XG5cdFx0bGV0IGNoYW5nZWRcblx0XHRDT05GSUcubm9kZXMuZm9yRWFjaChub2RlID0+IHtcblx0XHRcdGlmICghbm9kZS5oaWRkZW4gJiYgbm9kZS5sYXN0VXBkYXRlZCA8IGV4cGlyZWQpIHtcblx0XHRcdFx0bm9kZS5oaWRkZW4gPSB0cnVlXG5cdFx0XHRcdG5vZGUuc2VsZWN0ZWQgPSBmYWxzZVxuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0aWYgKGNoYW5nZWQpIHJlbmRlck5vZGVzKClcblx0fSBjYXRjaCAoZSkgeyB9XG59XG5cbmxldCBmZXRjaFJlcXVlc3RcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWxlY3RTaG93KGlkKSB7XG5cdGlmIChmZXRjaFJlcXVlc3QpIHtcblx0XHRmZXRjaFJlcXVlc3QuY2FuY2VsKClcblx0fVxuXHRoYW5kbGVFbmQoKVxuXHRDT05GSUcuc2hvdyA9IGlkXG5cdE9iamVjdC5hc3NpZ24oU0hPVywgeyBtYXA6IHt9LCB0cmFja3M6IFtdLCBwYXJhbXM6IHt9IH0pXG5cdEFVRElPLmZpbGUgPSBudWxsXG5cdHNldFRleHQoJy50cmFja3MnLCAnJylcblx0cmVuZGVyKClcblx0ZmV0Y2hSZXF1ZXN0ID0gZmV0Y2hGaWxlKGBzaG93P2lkPSR7aWR9YClcblx0ZmV0Y2hSZXF1ZXN0LnRoZW4oYXN5bmMgKGZpbGUpID0+IHtcblx0XHRPYmplY3QuYXNzaWduKFNIT1csIEpTT04ucGFyc2UoYXdhaXQgZmlsZS50ZXh0KCkpKVxuXHRcdHJlbmRlclNob3coKVxuXHRcdGZldGNoUmVxdWVzdCA9IGZldGNoRmlsZShgc2hvdy8ke2lkfS5tcDNgKVxuXHRcdGZldGNoUmVxdWVzdC50aGVuKGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRmZXRjaFJlcXVlc3QgPSBudWxsXG5cdFx0XHRBVURJTy5maWxlID0gZmlsZVxuXHRcdFx0cmVuZGVyQXVkaW8oKVxuXHRcdFx0cmVuZGVySGVhZCgpXG5cdFx0fSkuY2F0Y2goZSA9PiB7XG5cdFx0XHRmZXRjaFJlcXVlc3QgPSBudWxsXG5cdFx0fSlcblx0fSkuY2F0Y2goZSA9PiB7XG5cdFx0ZmV0Y2hSZXF1ZXN0ID0gbnVsbFxuXHR9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRyZW5kZXJIZWFkKClcblx0cmVuZGVyTm9kZXMoKVxuXHRyZW5kZXJTaG93KClcblx0cmVuZGVyQXVkaW8oKVxufVxuXG5PYmplY3QuYXNzaWduKGdsb2JhbCwge1xuXHRyZW5kZXIsXG5cdHJlbmRlckF1ZGlvLFxuXHRyZW5kZXJIZWFkLFxuXHRyZW5kZXJOb2Rlcyxcblx0cmVuZGVyU2hvd1xufSlcbiIsImltcG9ydCB7IEFVRElPIH0gZnJvbSBcIi4vZGF0YVwiXG5pbXBvcnQgeyBoYW5kbGVFcnJvciB9IGZyb20gXCIuL2V2ZW50c1wiXG5cbmNvbnN0IEF1ZGlvQ29udGV4dCA9IHdpbmRvd1snQXVkaW9Db250ZXh0J10gfHwgd2luZG93Wyd3ZWJraXRBdWRpb0NvbnRleHQnXVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VBdWRpbyhmaWxlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KClcblx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpXG5cdFx0cmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBlID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKGBkZWNvZGluZyAke2ZpbGUudHlwZX0uLi5gKVxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGF1ZGlvKSB7XG5cdFx0XHRcdGNvbnN0IHsgc2FtcGxlUmF0ZSwgZHVyYXRpb24gfSA9IGF1ZGlvXG5cdFx0XHRcdGNvbnN0IGNoYW5uZWxzID0gW11cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpby5udW1iZXJPZkNoYW5uZWxzOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBkYXRhID0gYXVkaW8uZ2V0Q2hhbm5lbERhdGEoaSlcblx0XHRcdFx0XHRjb25zdCB7IHRlbXBvLCBiZWF0cywgcGVha3MsIHNwZWN0cmFsRmx1eDogZmx1eCwgLi4ub3RoZXIgfSA9IG5ldyBNdXNpY1RlbXBvKGRhdGEpXG5cdFx0XHRcdFx0YmVhdHMuZm9yRWFjaCgodCwgaSwgYikgPT4gKGJbaV0gPSBNYXRoLnJvdW5kKHQgKiAxMDAwKSkpXG5cdFx0XHRcdFx0Y2hhbm5lbHNbaV0gPSB7IGRhdGEsIGJlYXRzLCB0ZW1wbyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzb2x2ZShPYmplY3QuYXNzaWduKEFVRElPLCB7IGR1cmF0aW9uLCBjaGFubmVscyB9KSlcblx0XHRcdH1cblx0XHRcdGlmICgnY2hyb21lJyBpbiB3aW5kb3cpIHtcblx0XHRcdFx0Y3R4LmRlY29kZUF1ZGlvRGF0YShyZWFkZXIucmVzdWx0KS5jYXRjaChoYW5kbGVFcnJvcikudGhlbihoYW5kbGUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguZGVjb2RlQXVkaW9EYXRhKHJlYWRlci5yZXN1bHQsIGhhbmRsZSwgaGFuZGxlRXJyb3IpXG5cdFx0XHR9XG5cdFx0fSlcblx0fSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlckF1ZGlvKCkge1xuXHRpZiAoQVVESU8uZmlsZSkge1xuXHRcdHNldEF0dHIoJyNwbGF5ZXInLCAnc3JjJywgVVJMLmNyZWF0ZU9iamVjdFVSTChBVURJTy5maWxlKSlcblx0XHQvLyAkKCcudHJhY2sud2F2ZWZvcm0nKS5mb3JFYWNoKGVsID0+IChlbC5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj5Mb2FkaW5nLi4uPC9kaXY+JykpXG5cdFx0Ly8gcmVuZGVyV2F2ZWZvcm0oYXdhaXQgcGFyc2VBdWRpbyhBVURJTy5maWxlKSlcblx0fSBlbHNlIHtcblx0XHRzZXRBdHRyKCcjcGxheWVyJywgJ3NyYycsICcnKVxuXHRcdCQoJy50cmFjay53YXZlZm9ybScpLmZvckVhY2goZWwgPT4gKGVsLmlubmVySFRNTCA9ICcnKSlcblx0fVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyV2F2ZWZvcm0oKSB7XG5cdCQoJy50cmFjay53YXZlZm9ybScpLmZvckVhY2goKHdyYXBwZXIsIGluZGV4KSA9PiB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNvbnN0IHdhdmVEYXRhID0gQVVESU8uY2hhbm5lbHNbaW5kZXhdLmRhdGFcblx0XHRjb25zdCBoZWlnaHQgPSA4MDtcblx0XHRjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cdFx0Y29uc3QgbGVuZ3RoID0gd2F2ZURhdGEubGVuZ3RoO1xuXHRcdGNvbnN0IHN0ZXAgPSBNYXRoLnJvdW5kKGxlbmd0aCAvIHdpZHRoKTtcblxuXHRcdHdyYXBwZXIuaW5uZXJIVE1MID0gJydcblx0XHR3cmFwcGVyLmFwcGVuZENoaWxkKGNhbnZhcylcblxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG5cdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcblx0XHRjYW52YXMuc3R5bGUubGVmdCA9IE1hdGgucm91bmQod3JhcHBlci5jbGllbnRXaWR0aCAvIDIpICsgXCJweFwiO1xuXG5cdFx0bGV0IHggPSAwLFxuXHRcdFx0c3VtUG9zaXRpdmUgPSAwLFxuXHRcdFx0c3VtTmVnYXRpdmUgPSAwLFxuXHRcdFx0bWF4UG9zaXRpdmUgPSAwLFxuXHRcdFx0bWF4TmVnYXRpdmUgPSAwLFxuXHRcdFx0a05lZ2F0aXZlID0gMCxcblx0XHRcdGtQb3NpdGl2ZSA9IDAsXG5cdFx0XHRkcmF3SWR4ID0gc3RlcDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA9PSBkcmF3SWR4KSB7XG5cdFx0XHRcdGNvbnN0IHAxID0gbWF4TmVnYXRpdmUgKiBoYWxmSGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gJyMzMzMzMzMnO1xuXHRcdFx0XHRjdHguc3Ryb2tlUmVjdCh4LCBwMSwgMSwgKG1heFBvc2l0aXZlICogaGFsZkhlaWdodCArIGhhbGZIZWlnaHQpIC0gcDEpO1xuXG5cdFx0XHRcdGNvbnN0IHAyID0gc3VtTmVnYXRpdmUgLyBrTmVnYXRpdmUgKiBoYWxmSGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gJyNlZWVlZWUnO1xuXHRcdFx0XHRjdHguc3Ryb2tlUmVjdCh4LCBwMiwgMSwgKHN1bVBvc2l0aXZlIC8ga1Bvc2l0aXZlICogaGFsZkhlaWdodCArIGhhbGZIZWlnaHQpIC0gcDIpO1xuXHRcdFx0XHR4Kys7XG5cdFx0XHRcdGRyYXdJZHggKz0gc3RlcDtcblx0XHRcdFx0c3VtUG9zaXRpdmUgPSAwO1xuXHRcdFx0XHRzdW1OZWdhdGl2ZSA9IDA7XG5cdFx0XHRcdG1heFBvc2l0aXZlID0gMDtcblx0XHRcdFx0bWF4TmVnYXRpdmUgPSAwO1xuXHRcdFx0XHRrTmVnYXRpdmUgPSAwO1xuXHRcdFx0XHRrUG9zaXRpdmUgPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHdhdmVEYXRhW2ldIDwgMCkge1xuXHRcdFx0XHRcdHN1bU5lZ2F0aXZlICs9IHdhdmVEYXRhW2ldO1xuXHRcdFx0XHRcdGtOZWdhdGl2ZSsrO1xuXHRcdFx0XHRcdGlmIChtYXhOZWdhdGl2ZSA+IHdhdmVEYXRhW2ldKSBtYXhOZWdhdGl2ZSA9IHdhdmVEYXRhW2ldO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN1bVBvc2l0aXZlICs9IHdhdmVEYXRhW2ldO1xuXHRcdFx0XHRcdGtQb3NpdGl2ZSsrO1xuXHRcdFx0XHRcdGlmIChtYXhQb3NpdGl2ZSA8IHdhdmVEYXRhW2ldKSBtYXhQb3NpdGl2ZSA9IHdhdmVEYXRhW2ldO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH0pXG59XG5cblxuLy8gbGV0IGFiXG4vLyBnbG9iYWwuZ2V0V2F2ZWZvcm1EYXRhID0gZnVuY3Rpb24gZ2V0V2F2ZWZvcm1EYXRhKGF1ZGlvKSB7XG4vLyBcdGNvbnN0IGRhdGEgPSBhdWRpby5nZXRDaGFubmVsRGF0YSgwKVxuLy8gXHRjb25zdCBzaXplID0gYXVkaW8uc2FtcGxlUmF0ZSAvIDEwXG4vLyBcdGNvbnN0IHRvdGFsID0gYXVkaW8uZHVyYXRpb24gKiAxMFxuLy8gXHRjb25zdCBhcnJheSA9IG5ldyBJbnQ4QXJyYXkodG90YWwgKiAyKVxuLy8gXHRmb3IgKGxldCBpID0gMCA7IGkgPCB0b3RhbCA7IGkrKykge1xuLy8gXHRcdGxldCBtaW4gPSAxLCBtYXggPSAtMVxuLy8gXHRcdGNvbnN0IG9mZnNldCA9IGkgKiBzaXplXG4vLyBcdFx0Zm9yIChsZXQgYSA9IDAgOyBhIDwgc2l6ZSA7IGErKykge1xuLy8gXHRcdFx0bWluID0gTWF0aC5taW4obWluLCBkYXRhW29mZnNldCArIGFdKVxuLy8gXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW29mZnNldCArIGFdKVxuLy8gXHRcdH1cbi8vIFx0XHRhcnJheVtvZmZzZXQgKiAyXSA9IG1pbiAqIDEyN1xuLy8gXHRcdGFycmF5W29mZnNldCAqIDIgKyAxXSA9IG1heCAqIDEyN1xuLy8gXHR9XG4vLyB9XG4vLyBnbG9iYWwucGFyc2VBdWRpbyA9IGZ1bmN0aW9uIHBhcnNlQXVkaW8oZmlsZSkge1xuLy8gXHRBVURJTy5maWxlbmFtZSA9IGZpbGUubmFtZVxuLy8gXHRyZW5kZXJBdWRpbygpXG4vLyBcdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbi8vIFx0XHRjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbi8vIFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4vLyBcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpXG4vLyBcdFx0cmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBlID0+IHtcbi8vIFx0XHRcdGNvbnNvbGUuZGVidWcoYGRlY29kaW5nICR7ZmlsZS50eXBlfS4uLmApXG4vLyBcdFx0XHRjb25zdCBoYW5kbGUgPSBhdWRpbyA9PiB7XG4vLyBcdFx0XHRcdC8vIGdldFdhdmVmb3JtRGF0YShhdWRpbylcbi8vIFx0XHRcdFx0Y29uc29sZS5hcHBlbmQoJ09LJylcbi8vIFx0XHRcdFx0T2JqZWN0LmFzc2lnbihBVURJTywge1xuLy8gXHRcdFx0XHRcdGlkOiBDT05GSUcuc2hvdyxcbi8vIFx0XHRcdFx0XHR1cmw6IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSksXG4vLyBcdFx0XHRcdFx0ZmlsZW5hbWU6IGZpbGUubmFtZSxcbi8vIFx0XHRcdFx0XHRkdXJhdGlvbjogTWF0aC5yb3VuZChhdWRpby5kdXJhdGlvbiAqIDEwMDApIC8gMTAwMCxcbi8vIFx0XHRcdFx0XHRzYW1wbGVSYXRlOiBhdWRpby5zYW1wbGVSYXRlLFxuLy8gXHRcdFx0XHRcdHRlbXBvOiAwLFxuLy8gXHRcdFx0XHRcdGJlYXRzOiAwLFxuLy8gXHRcdFx0XHRcdGNoYW5uZWxzOiBbXVxuLy8gXHRcdFx0XHR9KVxuLy8gXHRcdFx0XHRmb3IgKGxldCBpID0gMCA7IGkgPCBhdWRpby5udW1iZXJPZkNoYW5uZWxzIDsgaSsrKSB7XG4vLyBcdFx0XHRcdFx0Y29uc3QgeyB0ZW1wbywgYmVhdHMgfSA9IG5ldyBNdXNpY1RlbXBvKGF1ZGlvLmdldENoYW5uZWxEYXRhKGkpKVxuLy8gXHRcdFx0XHRcdGJlYXRzLmZvckVhY2goKHQsIGksIGIpID0+IHtcbi8vIFx0XHRcdFx0XHRcdGJbaV0gPSBNYXRoLnJvdW5kKHQqMTAwMClcbi8vIFx0XHRcdFx0XHR9KVxuLy8gXHRcdFx0XHRcdEFVRElPLmNoYW5uZWxzW2ldID0geyBcbi8vIFx0XHRcdFx0XHRcdHRlbXBvLFxuLy8gXHRcdFx0XHRcdFx0YmVhdHMsXG4vLyBcdFx0XHRcdFx0XHRkZWxheTogYmVhdHNbMF0sXG4vLyBcdFx0XHRcdFx0XHRlbmQ6IGJlYXRzW2JlYXRzLmxlbmd0aCAtIDFdXG4vLyBcdFx0XHRcdFx0fVxuLy8gXHRcdFx0XHRcdEFVRElPLnRlbXBvICs9IHBhcnNlSW50KCh0ZW1wbykpXG4vLyBcdFx0XHRcdFx0QVVESU8uYmVhdHMgKz0gYmVhdHMubGVuZ3RoXG4vLyBcdFx0XHRcdFx0Y29uc29sZS5pbmZvKGAtLSBAJHtpICsgMX06ICR7YmVhdHMubGVuZ3RofSBiZWF0cywgVEVNUE86ICR7dGVtcG99IEJQTWApXG4vLyBcdFx0XHRcdH1cbi8vIFx0XHRcdFx0QVVESU8udGVtcG8gLz0gYXVkaW8ubnVtYmVyT2ZDaGFubmVsc1xuLy8gXHRcdFx0XHRBVURJTy5iZWF0cyAvPSBhdWRpby5udW1iZXJPZkNoYW5uZWxzXG4vLyBcdFx0XHRcdHJlbmRlckF1ZGlvKClcbi8vIFx0XHRcdFx0c2F2ZUF1ZGlvQ29uZmlnKCkudGhlbihyZXNvbHZlKVxuLy8gXHRcdFx0fVxuLy8gXHRcdFx0aWYgKCdjaHJvbWUnIGluIHdpbmRvdykge1xuLy8gXHRcdFx0XHRjdHguZGVjb2RlQXVkaW9EYXRhKHJlYWRlci5yZXN1bHQpLmNhdGNoKGhhbmRsZUVycm9yKS50aGVuKGhhbmRsZSlcbi8vIFx0XHRcdH0gZWxzZSB7XG4vLyBcdFx0XHRcdGN0eC5kZWNvZGVBdWRpb0RhdGEocmVhZGVyLnJlc3VsdCwgaGFuZGxlLCBoYW5kbGVFcnJvcilcbi8vIFx0XHRcdH1cbi8vIFx0XHR9KVxuLy8gXHR9KVxuLy8gfVxuLy8gZ2xvYmFsLnNhdmVBdWRpb0NvbmZpZyA9IGZ1bmN0aW9uIHNhdmVBdWRpb0NvbmZpZyhpZCA9IENPTkZJRy5zaG93LCBkYXRhID0gQVVESU8pIHtcbi8vIFx0cmV0dXJuIHVwbG9hZEZpbGUoYC9zaG93LyR7aWR9Lmpzb25gLCBKU09OLnN0cmluZ2lmeShBVURJTykpXG4vLyB9XG4vLyBnbG9iYWwubG9hZEF1ZGlvQ29uZmlnID0gZnVuY3Rpb24gbG9hZEF1ZGlvQ29uZmlnKGlkID0gQ09ORklHLnNob3csIGRhdGEgPSBBVURJTykge1xuLy8gXHRyZXR1cm4gZ2V0KGBzaG93LyR7aWR9Lmpzb25gKVxuLy8gXHRcdC50aGVuKHJlcyA9PiB7XG4vLyBcdFx0XHRPYmplY3QuYXNzaWduKGRhdGEsIHJlcylcbi8vIFx0XHRcdHJlbmRlckF1ZGlvKClcbi8vIFx0XHR9KVxuLy8gXHRcdC5jYXRjaCgoKSA9PiB7XG4vLyBcdFx0XHRPYmplY3QuYXNzaWduKGRhdGEsIEFVRElPX0RFRkFVTFQpXG4vLyBcdFx0XHRyZW5kZXJBdWRpbygpXG4vLyBcdFx0fSlcbi8vIH1cbi8vIGdsb2JhbC5zYXZlTGlnaHRTaG93ID0gZnVuY3Rpb24gc2F2ZUxpZ2h0U2hvdyhpZCA9IENPTkZJRy5zaG93LCBkYXRhID0gQVVESU8pIHtcbi8vIFx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuLy8gXHRcdC8vIFNIT1dTWzBdID0gY3JlYXRlTG9vcCgwLCBBVURJTy5jaGFubmVsc1swXSwgQVVESU8udGVtcG8pXG4vLyBcdFx0Ly8gU0hPV1NbMV0gPSBjcmVhdGVMb29wKDEsIEFVRElPLmNoYW5uZWxzWzFdLCBBVURJTy50ZW1wbylcbi8vIFx0XHRTSE9XU1swXSA9IGNyZWF0ZVNlcXVlbmNlRnJvbUJlYXRzKEFVRElPLmNoYW5uZWxzWzBdLmJlYXRzLCAwKVxuLy8gXHRcdFNIT1dTWzFdID0gY3JlYXRlU2VxdWVuY2VGcm9tQmVhdHMoQVVESU8uY2hhbm5lbHNbMV0uYmVhdHMsIDEpXG4vLyBcdFx0cmV0dXJuIHVwbG9hZEZpbGUoYC9zaG93LyR7Q09ORklHLnNob3d9QS5sc2JgLCBTSE9XU1swXSlcbi8vIFx0XHRcdC50aGVuKCgpID0+IHVwbG9hZEZpbGUoYC9zaG93LyR7Q09ORklHLnNob3d9Qi5sc2JgLCBTSE9XU1sxXSkpXG4vLyBcdFx0XHQudGhlbigoKSA9PiByZXNvbHZlKFNIT1dTKSlcbi8vIFx0fSlcbi8vIH1cbi8vIGdsb2JhbC5jbGVhckxpZ2h0U2hvdyA9IGZ1bmN0aW9uIGNsZWFyTGlnaHRTaG93KGlkID0gQ09ORklHLnNob3csIGRhdGEgPSBBVURJTykge1xuLy8gXHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4vLyBcdFx0cmV0dXJuIHJlcXVlc3QoJ0RFTEVURScsIGBzaG93LyR7Q09ORklHLnNob3d9Lmpzb25gKVxuLy8gXHRcdFx0LmZpbmFsbHkoKCkgPT4gcmVxdWVzdCgnREVMRVRFJywgYC9zaG93LyR7Q09ORklHLnNob3d9QS5sc2JgKSlcbi8vIFx0XHRcdC5maW5hbGx5KCgpID0+IHJlcXVlc3QoJ0RFTEVURScsIGAvc2hvdy8ke0NPTkZJRy5zaG93fUIubHNiYCkpXG4vLyBcdFx0XHQuZmluYWxseShyZXNvbHZlKVxuLy8gXHR9KVxuLy8gfVxuXG4vLyBnbG9iYWwuY3JlYXRlTG9vcCA9IGZ1bmN0aW9uIGNyZWF0ZUxvb3AoaW5kZXgsIGNoYW5uZWwsIHRlbXBvKSB7XG4vLyBcdGNvbnN0IGRlbGF5ID0gY2hhbm5lbC5kZWxheVxuLy8gXHRjb25zdCBlbmQgPSBjaGFubmVsLmVuZFxuLy8gXHRjb25zdCBkdXIgPSBNYXRoLmNlaWwoMTAwMCAvICh0ZW1wbyAvIDYwKSlcbi8vIFx0Y29uc3QgZHVyMSA9IE1hdGgucm91bmQoZHVyICogQVVESU8ucmF0aW8pXG4vLyBcdGNvbnN0IGR1cjIgPSBkdXIgLSBkdXIxXG4vLyBcdGNvbnN0IGZhZGUxID0gTWF0aC5yb3VuZChkdXIxICogMSlcbi8vIFx0Y29uc3QgZmFkZTIgPSBNYXRoLnJvdW5kKGR1cjIgKiAxKVxuLy8gXHRsZXQgY29sb3IxID0gaGV4VG9JbnRTdHJpbmcoQVVESU8uY29sb3IxKVxuLy8gXHRsZXQgY29sb3IyID0gaGV4VG9JbnRTdHJpbmcoQVVESU8uY29sb3IyKVxuLy8gXHRpZiAoQVVESU8uc3dhcCAmJiBpbmRleCAlIDIpIHtcbi8vIFx0XHRjb2xvcjEgPSBoZXhUb0ludFN0cmluZyhBVURJTy5jb2xvcjIpXG4vLyBcdFx0Y29sb3IyID0gaGV4VG9JbnRTdHJpbmcoQVVESU8uY29sb3IxKVxuLy8gXHR9XG4vLyBcdHJldHVybiBbXG4vLyBcdFx0YEMgMCAke2RlbGF5fSAwIDAgMCAwYCxcbi8vIFx0XHRgTCAke2RlbGF5fSAke2VuZCAtIGRlbGF5fWAsXG4vLyBcdFx0YFx0QyAwICR7ZHVyMX0gJHtmYWRlMX0gJHtjb2xvcjF9YCxcbi8vIFx0XHRgXHRDICR7ZHVyMX0gJHtkdXIyfSAke2ZhZGUyfSAke2NvbG9yMn1gLFxuLy8gXHRcdGBcdEUgJHtkdXJ9YCxcbi8vIFx0XHRgRSAke2VuZH1gXG4vLyBcdF0uam9pbignXFxuJylcbi8vIH1cbi8vIGdsb2JhbC5jcmVhdGVTZXF1ZW5jZUZyb21CZWF0cyA9IGZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRnJvbUJlYXRzKGJlYXRzLCBjaGFubmVsID0gMCkge1xuLy8gXHRsZXQgc2VxID0gYEMgMCAke2JlYXRzWzBdfSAwIDAgMCAwXFxuYFxuLy8gXHRzZXEgKz0gYmVhdHMubWFwKCh0aW1lLCBpbmRleCkgPT4ge1xuLy8gXHRcdGlmIChpbmRleCArIDEgPCBiZWF0cy5sZW5ndGgpIHtcbi8vIFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCh0aW1lKVxuLy8gXHRcdFx0Y29uc3QgZHVyID0gTWF0aC5yb3VuZCgoYmVhdHNbaW5kZXggKyAxXSAtIHRpbWUpKVxuLy8gXHRcdFx0Y29uc3QgZHVyMSA9IE1hdGgucm91bmQoZHVyICogQVVESU8ucmF0aW8pXG4vLyBcdFx0XHRjb25zdCBkdXIyID0gZHVyIC0gZHVyMVxuLy8gXHRcdFx0Y29uc3QgZmFkZTEgPSBNYXRoLnJvdW5kKGR1cjEgKiAxKVxuLy8gXHRcdFx0Y29uc3QgZmFkZTIgPSBNYXRoLnJvdW5kKGR1cjIgKiAxKVxuLy8gXHRcdFx0bGV0IGNvbG9yMSA9IGhleFRvSW50U3RyaW5nKEFVRElPLmNvbG9yMSlcbi8vIFx0XHRcdGxldCBjb2xvcjIgPSBoZXhUb0ludFN0cmluZyhBVURJTy5jb2xvcjIpXG4vLyBcdFx0XHRpZiAoQVVESU8uc3dhcCAmJiBjaGFubmVsICUgMikge1xuLy8gXHRcdFx0XHRyZXR1cm4gW1xuLy8gXHRcdFx0XHRcdGBDICR7c3RhcnR9ICR7ZHVyMX0gJHtmYWRlMX0gJHtjb2xvcjJ9YCxcbi8vIFx0XHRcdFx0XHRgQyAke3N0YXJ0ICsgZHVyMX0gJHtkdXIyfSAke2ZhZGUyfSAke2NvbG9yMX1gXG4vLyBcdFx0XHRcdF0uam9pbignXFxuJylcbi8vIFx0XHRcdH0gZWxzZSB7XG4vLyBcdFx0XHRcdHJldHVybiBbXG4vLyBcdFx0XHRcdFx0YEMgJHtzdGFydH0gJHtkdXIxfSAke2ZhZGUxfSAke2NvbG9yMX1gLFxuLy8gXHRcdFx0XHRcdGBDICR7c3RhcnQgKyBkdXIxfSAke2R1cjJ9ICR7ZmFkZTJ9ICR7Y29sb3IyfWBcbi8vIFx0XHRcdFx0XS5qb2luKCdcXG4nKVxuLy8gXHRcdFx0fVxuLy8gXHRcdH1cbi8vIFx0fSkuam9pbignXFxuJylcbi8vIFx0c2VxICs9IGBFICR7YmVhdHNbYmVhdHMubGVuZ3RoLTFdfWBcbi8vIFx0cmV0dXJuIHNlcVxuLy8gfVxuLy8gZ2xvYmFsLmhleFRvSW50U3RyaW5nID0gZnVuY3Rpb24gaGV4VG9JbnRTdHJpbmcoaGV4KSB7XG4vLyBcdGhleCA9IGhleC5yZXBsYWNlKC9bXjAtOWEtZl0rL2dpLCAnJylcbi8vIFx0cmV0dXJuIFtcbi8vIFx0XHRwYXJzZUludChoZXguc2xpY2UoMCwgMiksIDE2KSxcbi8vIFx0XHRwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSxcbi8vIFx0XHRwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KVxuLy8gXHRdLmpvaW4oJyAnKVxuLy8gfVxuIiwiLy8gc3RvcmUgaGFyZHdhcmUgY29uZmlncyBkYXRhXG5leHBvcnQgY29uc3QgQ09ORklHID0ge1xuXHRicmlnaHRuZXNzOiAyNTUsXG5cdGNoYW5uZWw6IDAsXG5cdHNob3c6IDEsXG5cdHRpbWU6IDAsXG5cdHJ1bm5pbmc6IDAsXG5cdHBhdXNlZDogMCxcblx0bm9kZXM6IFtdLFxuXHRzeW5jaW5nOiB0cnVlXG59XG5cbi8vIHN0b3JlIGF1ZGlvIGNvbmZpZ3MgZm9yIGN1cnJlbnQgc2hvd1xuZXhwb3J0IGNvbnN0IEFVRElPID0ge1xuXHRmaWxlOiBudWxsLFxuXHRjaGFubmVsczogW10sXG5cdGR1cmF0aW9uOiAwXG59XG5cbmV4cG9ydCBjb25zdCBMSUdIVCA9IHtcblx0ZmlsZTogbnVsbFxufVxuXG5leHBvcnQgY29uc3QgU0hPVyA9IHtcblx0bWFwOiB7fSxcblx0cGFyYW1zOiB7fSxcblx0dHJhY2tzOiBbXSxcbn1cblxuLy8gc3RvcmUgY29sb3IgZGF0YSBmb3IgY3VycmVudCBzZWdtZW50XG5nbG9iYWwuY29sb3IgPSB7XG5cdHJnYjoge1xuXHRcdHI6IDI1NSxcblx0XHRnOiAwLFxuXHRcdGI6IDBcblx0fSxcblx0aHNsOiB7XG5cdFx0aDogMjU1LFxuXHRcdHM6IDAsXG5cdFx0bDogMFxuXHR9XG59XG5nbG9iYWwudXBkYXRlUkdCID0gZnVuY3Rpb24gdXBkYXRlUkdCKCkge1xuXHRjb25zdCB7IGgsIHMsIGwgfSA9IGNvbG9yLmhzbFxuXHRjb2xvci5yZ2IgPSBoc2xUb1JnYihoLCBzLCBsKVxufVxuZ2xvYmFsLnVwZGF0ZUhTTCA9IGZ1bmN0aW9uIHVwZGF0ZUhTTCgpIHtcblx0Y29uc3QgeyByLCBnLCBiIH0gPSBjb2xvci5yZ2Jcblx0Y29sb3IuaHNsID0gcmdiVG9Ic2wociwgZywgYilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBDT05GSUcsIEFVRElPLCBMSUdIVCwgU0hPVyB9XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsLCB7IENPTkZJRywgQVVESU8sIExJR0hULCBTSE9XIH0pXG4iLCJpbXBvcnQgZGVib3VuY2UgZnJvbSBcImxvZGFzaC9kZWJvdW5jZVwiXG5pbXBvcnQgeyAkLCBjYWxsLCBnZXQsIHNldFByb3AsIHNldFRleHQsIHVwbG9hZEZpbGUsIGZldGNoRmlsZSwgZm9ybWF0VGltZSwgc2VuZENvbW1hbmQgfSBmcm9tIFwiLi9hcGlcIlxuaW1wb3J0IHsgcmVuZGVyLCByZW5kZXJIZWFkLCByZW5kZXJOb2RlcywgY2hlY2tOb2Rlcywgc2VsZWN0U2hvdyB9IGZyb20gXCIuL2FwcFwiXG5pbXBvcnQgeyBBVURJTywgQ09ORklHLCBTSE9XIH0gZnJvbSBcIi4vZGF0YVwiXG5pbXBvcnQgeyBzZW5kLCBzZW5kU3luYyB9IGZyb20gXCIuL3dzXCJcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi9hY3Rpb24nXG5cbmNvbnN0IHsgcGFyc2VBdWRpbywgcmVuZGVyQXVkaW8gfSA9IHJlcXVpcmUoXCIuL2F1ZGlvXCIpXG5jb25zdCB7IHBhcnNlTFNGLCBwYXJzZUxUUCwgcGFyc2VJUFgsIHJlbmRlclNob3cgfSA9IHJlcXVpcmUoXCIuL2xpZ2h0XCIpXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcblx0Y29uc29sZS5lcnJvciguLi5hcmd1bWVudHMpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVGaWxlKGZpbGUsIGV2ZW50KSB7XG5cdGlmIChDT05GSUcucnVubmluZykge1xuXHRcdGNhbGwoJyNwbGF5ZXInLCAncGF1c2UnKVxuXHRcdHNldFByb3AoJyNwbGF5ZXInLCAnY3VycmVudFRpbWUnLCAwKVxuXHRcdGF3YWl0IGhhbmRsZUVuZCgpXG5cdH1cblx0Y29uc29sZS5kZWJ1Zyhgc2VsZWN0IGZpbGU6ICR7ZmlsZS5uYW1lfWApXG5cdGlmIChmaWxlLm5hbWUuZW5kc1dpdGgoJy5iaW4nKSkge1xuXHRcdGF3YWl0IHVwbG9hZEZpbGUoJ2Zpcm13YXJlLycgKyBmaWxlbmFtZSwgZmlsZSlcblx0fSBlbHNlIGlmIChmaWxlLm5hbWUuZW5kc1dpdGgoJy5sdHAnKSkge1xuXHRcdGNvbnN0IHNob3cgPSBKU09OLnN0cmluZ2lmeShhd2FpdCBwYXJzZUxUUChmaWxlKSlcblx0XHRhd2FpdCByZW5kZXIoKVxuXHRcdGF3YWl0IHVwbG9hZEZpbGUoYHNob3cvJHtDT05GSUcuc2hvd30uanNvbmAsIHNob3cpO1xuXHRcdGF3YWl0IHVwbG9hZEZpbGUoYHNob3cvJHtDT05GSUcuc2hvd30ubXAzYCwgQVVESU8uZmlsZSk7XG5cdH0gZWxzZSBpZiAoZmlsZS5uYW1lLmVuZHNXaXRoKCcubHNmJykpIHtcblx0XHRjb25zdCBkYXRhID0gYXdhaXQgcGFyc2VMU0YoZmlsZSlcblx0XHRsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRldmljZV0nKVxuXHRcdHRhcmdldCAmJiAodGFyZ2V0ID0gdGFyZ2V0LmRhdGFzZXQuZGV2aWNlKVxuXHRcdGlmICh0YXJnZXQpIHtcblx0XHRcdFNIT1cubWFwW3RhcmdldF0gPSBmaWxlLm5hbWVcblx0XHRcdGF3YWl0IHVwbG9hZEZpbGUoYC9zaG93LyR7Q09ORklHLnNob3d9Lmpzb25gLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoU0hPVyldKSlcblx0XHR9XG5cdFx0Zm9yIChsZXQgaWQgaW4gU0hPVy5tYXApIHtcblx0XHRcdGlmIChTSE9XLm1hcFtpZF0gPT0gZmlsZS5uYW1lKSB7XG5cdFx0XHRcdGlmIChkYXRhLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0YXdhaXQgdXBsb2FkRmlsZShgL3Nob3cvJHtDT05GSUcuc2hvd31BLmxzYmAsIG5ldyBCbG9iKGRhdGFbMF0pLCB0cnVlLCBpZCk7XG5cdFx0XHRcdFx0YXdhaXQgdXBsb2FkRmlsZShgL3Nob3cvJHtDT05GSUcuc2hvd31CLmxzYmAsIG5ldyBCbG9iKGRhdGFbMF0pLCB0cnVlLCBpZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRhd2FpdCB1cGxvYWRGaWxlKGAvc2hvdy8ke0NPTkZJRy5zaG93fUEubHNiYCwgbmV3IEJsb2IoZGF0YVsxXSksIHRydWUsIGlkKTtcblx0XHRcdFx0XHRhd2FpdCB1cGxvYWRGaWxlKGAvc2hvdy8ke0NPTkZJRy5zaG93fUIubHNiYCwgbmV3IEJsb2IoZGF0YVsyXSksIHRydWUsIGlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChmaWxlLm5hbWUuZW5kc1dpdGgoJy5pcHgnKSkge1xuXHRcdGF3YWl0IHBhcnNlSVBYKGZpbGUpXG5cdH0gZWxzZSBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvJykpIHtcblx0XHRhd2FpdCBwYXJzZUF1ZGlvKGZpbGUpXG5cdFx0YXdhaXQgcmVuZGVyQXVkaW8oKVxuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ3Vuc3VwcG9ydGVkIGZpbGUgZm9ybWF0Jylcblx0fVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcblx0aWYgKGUudHlwZSA9PT0gJ2NoYW5nZScgJiYgZS50YXJnZXQuaWQgPT09ICdzZWxlY3QtZmlsZScpIHtcblx0XHRmb3IgKGxldCBmaWxlIG9mIGUudGFyZ2V0LmZpbGVzKSB7XG5cdFx0XHRhd2FpdCBoYW5kbGVGaWxlKGZpbGUpXG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG5cdGNvbnN0IHsgc2hvdywgYWN0aW9uLCBjb21tYW5kLCBieXRlcyB9ID0gZS50YXJnZXQuZGF0YXNldFxuXHRpZiAoZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtZGV2aWNlXScpKSB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtZGV2aWNlXScpXG5cdFx0Q09ORklHLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG5cdFx0XHRpZiAobm9kZS5pZCA9PSB0YXJnZXQuZGF0YXNldC5kZXZpY2UpIHtcblx0XHRcdFx0bm9kZS5zZWxlY3RlZCA9ICFub2RlLnNlbGVjdGVkXG5cdFx0XHRcdGlmIChub2RlLnNlbGVjdGVkKSBzZW5kKG5vZGUuaWQsICdCTElOSycsIDUpXG5cdFx0XHRcdGVsc2Ugc2VuZChub2RlLmlkLCAnQkxJTksnLCAwKVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmVuZGVyTm9kZXMoKVxuXHR9XG5cdGlmIChlLnRhcmdldC5kYXRhc2V0LnNob3cpIHtcblx0XHRzZWxlY3RTaG93KHBhcnNlSW50KGUudGFyZ2V0LmRhdGFzZXQuc2hvdykgfHwgMClcblx0fVxuXHRpZiAoYWN0aW9uKSB7XG5cdFx0aWYgKHR5cGVvZiBhY3Rpb25zW2FjdGlvbl0gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEFDVElPTiAke2FjdGlvbn0oKSBpcyB1bmRlZmluZWQuYClcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWN0aW9uc1thY3Rpb25dLmNhbGwoZS50YXJnZXQsIGUpXG5cdFx0fVxuXHR9XG5cdGlmIChlLnRhcmdldC5kYXRhc2V0LmNvbW1hbmQpIHtcblx0XHRsZXQgcmVzdCA9IFtdXG5cdFx0dHJ5IHsgcmVzdCA9IGV2YWwoYFske2UudGFyZ2V0LmRhdGFzZXQuYm9keSB8fCAnJ31dYCkgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKSB9XG5cdFx0c2VuZENvbW1hbmQoZS50YXJnZXQuZGF0YXNldC5jb21tYW5kLCAuLi5yZXN0KVxuXHR9XG59XG5mdW5jdGlvbiBoYW5kbGVEcmFnT3ZlcihlKSB7XG5cdGUucHJldmVudERlZmF1bHQoKVxuXHRjb25zdCBkcm9wcGFibGUgPSBlLnRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcm9wcGFibGVdJylcblx0aWYgKGRyb3BwYWJsZSkge1xuXHRcdGRyb3BwYWJsZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuXHR9XG59XG5mdW5jdGlvbiBoYW5kbGVEcmFnTGVhdmUoZSkge1xuXHRlLnByZXZlbnREZWZhdWx0KClcblx0Y29uc3QgZHJvcHBhYmxlID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJvcHBhYmxlXScpXG5cdGlmIChkcm9wcGFibGUpIHtcblx0XHRkcm9wcGFibGUuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcblx0fVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZURyYWdEcm9wKGUpIHtcblx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdGZvciAobGV0IGZpbGUgb2YgZS5kYXRhVHJhbnNmZXIuZmlsZXMpIHtcblx0XHRhd2FpdCBoYW5kbGVGaWxlKGZpbGUsIGUpXG5cdH1cbn1cblxubGV0IHNjcm9sbGluZyA9IGZhbHNlO1xubGV0IHNjcm9sbEVuZGVkID0gMDtcbmNvbnN0IHNjcm9sbFN0YXJ0ID0gZGVib3VuY2UoKCkgPT4ge1xuXHRpZiAoRGF0ZS5ub3coKSAtIHNjcm9sbEVuZGVkID4gMTApIHtcblx0XHRzY3JvbGxpbmcgPSB0cnVlXG5cdFx0aWYgKENPTkZJRy5ydW5uaW5nICYmICFDT05GSUcucGF1c2VkKSBjYWxsKCcjcGxheWVyJywgJ3BhdXNlJylcblx0fVxufSwgMzAwLCB7IGxlYWRpbmc6IHRydWUgfSlcbmNvbnN0IHNjcm9sbEVuZCA9IGRlYm91bmNlKCgpID0+IHtcblx0JCgnI3BsYXllcicpLmZvckVhY2gocGxheWVyID0+IHtcblx0XHRwbGF5ZXIucGxheSgpXG5cdH0pXG5cdHNjcm9sbGluZyA9IGZhbHNlXG5cdHNjcm9sbEVuZGVkID0gRGF0ZS5ub3coKTtcbn0sIDMwMCwgeyB0cmFpbGluZzogdHJ1ZSB9KVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwoZSkge1xuXHRpZiAoQ09ORklHLnJ1bm5pbmcgJiYgZS50YXJnZXQuY2xvc2VzdCgnLnRpbWVsaW5lJykpIHtcblx0XHRzY3JvbGxTdGFydCgpXG5cdFx0JCgnLnRpbWVsaW5lJykuZm9yRWFjaCh0aW1lbGluZSA9PiB7XG5cdFx0XHRjb25zdCByYXRpbyA9IHRpbWVsaW5lLnNjcm9sbExlZnQgLyAodGltZWxpbmUuc2Nyb2xsV2lkdGggLSB0aW1lbGluZS5vZmZzZXRXaWR0aClcblx0XHRcdCQoJyNwbGF5ZXInKS5mb3JFYWNoKHBsYXllciA9PiB7XG5cdFx0XHRcdHBsYXllci5jdXJyZW50VGltZSA9IChTSE9XLnBhcmFtcy5lbmQgLyAxMDAwKSAqIHJhdGlvXG5cdFx0XHR9KVxuXHRcdH0pXG5cblx0XHRzY3JvbGxFbmQoKVxuXHR9XG59XG5cbmxldCBhdWRpbztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVQbGF5KGUpIHtcblx0Ly8gY29uc29sZS5sb2coJ3BsYXknKVxuXHRhdWRpbyA9IGUudGFyZ2V0XG5cdENPTkZJRy5wYXVzZWQgPSAwXG5cdENPTkZJRy5ydW5uaW5nID0gMVxuXHRyZW5kZXJIZWFkKClcblx0aGFuZGxlVGltZVVwZGF0ZShlKVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVBsYXlpbmcoZSkge1xuXHRjb25zb2xlLmxvZygncGxheWluZycpXG5cdGF1ZGlvID0gZS50YXJnZXRcblx0Q09ORklHLnBhdXNlZCA9IDBcblx0Q09ORklHLnJ1bm5pbmcgPSAxXG5cdHJlbmRlckhlYWQoKVxuXHRoYW5kbGVUaW1lVXBkYXRlKGUpXG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUGF1c2UoZSkge1xuXHRjb25zb2xlLmxvZygncGF1c2VkJylcblx0YXVkaW8gPSBlLnRhcmdldFxuXHRpZiAoZS50YXJnZXQuY3VycmVudFRpbWUgPT09IGUudGFyZ2V0LmR1cmF0aW9uKSB7XG5cdFx0aGFuZGxlRW5kKGUpXG5cdH0gZWxzZSB7XG5cdFx0Q09ORklHLnBhdXNlZCA9IDFcblx0XHRyZW5kZXJIZWFkKClcblx0XHRoYW5kbGVUaW1lVXBkYXRlKGUpXG5cdH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVTdGFydCgpIHtcblx0Y29uc29sZS5sb2coJ3N0YXJ0Jylcblx0Q09ORklHLnJ1bm5pbmcgPSAxXG5cdGF3YWl0IHNlbmRDb21tYW5kKCdiZWdpbicpXG5cdGNhbGwoJyNwbGF5ZXInLCAncGxheScpXG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRW5kKCkge1xuXHRjb25zb2xlLmxvZygnZW5kZWQnKVxuXHRDT05GSUcucnVubmluZyA9IDBcblx0Q09ORklHLnBhdXNlZCA9IDBcblx0Q09ORklHLnRpbWUgPSAwXG5cdHNlbmRDb21tYW5kKCdlbmQnKVxuXHRyZW5kZXJIZWFkKClcblx0aGFuZGxlVGltZVVwZGF0ZSgpXG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlVGltZVNlZWtpbmcoZSkge1xuXHRhdWRpbyA9IGUudGFyZ2V0XG5cdC8vIGNvbnNvbGUubG9nKCdzZWVraW5nJylcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVUaW1lU2Vla2VkKGUpIHtcblx0YXVkaW8gPSBlLnRhcmdldFxuXHQvLyBjb25zb2xlLmxvZygnc2Vla2VkJylcblx0aWYgKHNjcm9sbGluZykgcmV0dXJuXG5cdGNvbnN0IHRpbWVsaW5lID0gJCgnLnRpbWVsaW5lJylcblx0aWYgKHRpbWVsaW5lKSB7XG5cdFx0Y29uc3QgcmF0aW8gPSBlLmN1cnJlbnRUaW1lIC8gKFNIT1cucGFyYW1zLmVuZCAvIDEwMDApXG5cdFx0JHRpbWVsaW5lLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0ZWwuc2Nyb2xsTGVmdCA9IChlbC5zY3JvbGxXaWR0aCAtIGVsLm9mZnNldFdpZHRoKSAqIHJhdGlvXG5cdFx0XHRjb25zdCAkaGFuZGxlID0gZWwucXVlcnlTZWxlY3RvcignLmhhbmRsZScpXG5cdFx0XHRpZiAoJGhhbmRsZSkge1xuXHRcdFx0XHQkaGFuZGxlLnN0eWxlLmxlZnQgPSBNYXRoLnJvdW5kKGVsLm9mZnNldFdpZHRoICogcmF0aW8pICsgJ3B4J1xuXHRcdFx0XHQkaGFuZGxlLnN0eWxlLnRvcCA9IGVsLm9mZnNldFRvcCArICdweCdcblx0XHRcdFx0JGhhbmRsZS5zdHlsZS5oZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQgKyAncHgnXG5cdFx0XHR9XG5cdFx0fSlcblx0fVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlVGltZVVwZGF0ZSgpIHtcblx0YXVkaW8gJiYgc2V0VGV4dCgnI3RpbWUnLCBmb3JtYXRUaW1lKGF1ZGlvLmN1cnJlbnRUaW1lKSlcbn1cblxuc2V0VGltZW91dChhc3luYyBmdW5jdGlvbiBzeW5jKCkge1xuXHRpZiAoYXVkaW8gJiYgQ09ORklHLnN5bmNpbmcpIHtcblx0XHRDT05GSUcudGltZSA9IE1hdGgubWluKE1hdGgucm91bmQoYXVkaW8uY3VycmVudFRpbWUgKiAxMDAwKSwgU0hPVy5wYXJhbXMuZW5kKVxuXHRcdGF3YWl0IHNlbmRTeW5jKClcblx0fVxuXHRzZXRUaW1lb3V0KHN5bmMsIDEwMClcbn0pXG5jb25zdCAkdGltZWxpbmUgPSAkKCcudGltZWxpbmUnKVxucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGRyYXcoKSB7XG5cdGlmIChhdWRpbyAmJiBDT05GSUcucnVubmluZyAmJiAhQ09ORklHLnBhdXNlZCkge1xuXHRcdGNvbnN0IHJhdGlvID0gYXVkaW8uY3VycmVudFRpbWUgLyAoU0hPVy5wYXJhbXMuZW5kIC8gMTAwMClcblx0XHRoYW5kbGVUaW1lVXBkYXRlKClcblx0XHQkdGltZWxpbmUuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRlbC5zY3JvbGxMZWZ0ID0gKGVsLnNjcm9sbFdpZHRoIC0gZWwub2Zmc2V0V2lkdGgpICogcmF0aW9cblx0XHRcdGNvbnN0ICRoYW5kbGUgPSBlbC5xdWVyeVNlbGVjdG9yKCcuaGFuZGxlJylcblx0XHRcdGlmICgkaGFuZGxlKSB7XG5cdFx0XHRcdCRoYW5kbGUuc3R5bGUubGVmdCA9IE1hdGgucm91bmQoZWwub2Zmc2V0V2lkdGggKiByYXRpbykgKyAncHgnXG5cdFx0XHRcdCRoYW5kbGUuc3R5bGUudG9wID0gZWwub2Zmc2V0VG9wICsgJ3B4J1xuXHRcdFx0XHQkaGFuZGxlLnN0eWxlLmhlaWdodCA9IGVsLm9mZnNldEhlaWdodCArICdweCdcblx0XHRcdH1cblx0XHRcdC8vIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKC0ke3JhdGlvKjEwMH0lKWBcblx0XHR9KVxuXHR9XG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxufSlcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUluaXQoKSB7XG5cdE9iamVjdC5hc3NpZ24oQ09ORklHLCBhd2FpdCBnZXQoJ3N0YXQnKSlcblx0c2V0VGltZW91dCgoKSA9PiBzZWxlY3RTaG93KENPTkZJRy5zaG93KSwgMTAwMClcblx0c2V0SW50ZXJ2YWwoY2hlY2tOb2RlcywgMTAwMClcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBoYW5kbGVTY3JvbGwsIHRydWUpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBoYW5kbGVEcmFnT3ZlciwgdHJ1ZSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBoYW5kbGVEcmFnTGVhdmUsIHRydWUpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGhhbmRsZURyYWdEcm9wLCB0cnVlKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlQ2hhbmdlLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgaGFuZGxlQ2hhbmdlLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2ssIHRydWUpXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlUGxheSwgdHJ1ZSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGhhbmRsZVBhdXNlLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBoYW5kbGVQbGF5aW5nLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBoYW5kbGVUaW1lVXBkYXRlLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIGhhbmRsZVRpbWVTZWVrZWQsIHRydWUpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIGhhbmRsZVRpbWVTZWVraW5nLCB0cnVlKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGhhbmRsZUVuZCwgdHJ1ZSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBuZXcgRnVuY3Rpb24oKSwgdHJ1ZSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVJbml0KVxuXG5cblxuIiwiaW1wb3J0ICcuL2xvZy5qcydcbmltcG9ydCAnLi9jb2xvci5qcydcbmltcG9ydCAnLi9kYXRhLmpzJ1xuaW1wb3J0ICcuL2FwcC5qcydcbmltcG9ydCAnLi9hcGkuanMnXG5pbXBvcnQgJy4vYXVkaW8uanMnXG5pbXBvcnQgJy4vZXZlbnRzLmpzJ1xuIiwiaW1wb3J0IHVuemlwIGZyb20gJ3VuemlwLWpzJ1xuaW1wb3J0IHsgTElHSFQgfSBmcm9tICcuL2RhdGEnXG5cbmNvbnN0IGxlZF9udW1zID0gMzZcbmNvbnN0IHJnYkZyYW1lUmVnZXggPSAvKFxcdCspPyhbMC05XSspbXM6IHNldHJnYiBbQUJdKyAoWzAtOV0rKW1zID4gKFswLTldKyksIChbMC05XSspLCAoWzAtOV0rKS9pXG5jb25zdCBlbmRGcmFtZVJlZ2V4ID0gLyhcXHQrKT8oWzAtOV0rKW1zOiBlbmQvaVxuY29uc3QgbG9vcEZyYW1lUmVnZXggPSAvKFswLTldKyltczogbG9vcCAoWzAtOV0rKW1zL2lcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlTFRQKGZpbGUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdCQoJy50cmFja3MnKS5mb3JFYWNoKGVsID0+IHtcblx0XHRcdGVsLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+bG9hZGluZy4uLjwvZGl2Pidcblx0XHR9KVxuXHRcdHVuemlwKGZpbGUsIChlcnIsIHppcCkgPT4ge1xuXHRcdFx0aWYgKGVycikgcmVqZWN0KGVycilcblx0XHRcdHppcC5yZWFkRW50cmllcygoZXJyLCBlbnRyaWVzKSA9PiB7XG5cdFx0XHRcdGlmIChlcnIpIHJlamVjdChlcnIpXG5cdFx0XHRcdGxldCBlbmRlZCA9IDBcblx0XHRcdFx0ZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcblx0XHRcdFx0XHRjb25zdCB7IG5hbWUgfSA9IGVudHJ5XG5cdFx0XHRcdFx0emlwLnJlYWRFbnRyeURhdGEoZW50cnksIGZhbHNlLCAoZXJyLCBzdHJlYW0pID0+IHtcblx0XHRcdFx0XHRcdGlmIChlcnIpIHJlamVjdChlcnIpXG5cdFx0XHRcdFx0XHRsZXQgY29udGVudCA9IFtdXG5cdFx0XHRcdFx0XHRzdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50LnB1c2goZGF0YSlcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRzdHJlYW0ub24oJ2VuZCcsIGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmlsZSA9IG5ldyBCbG9iKGNvbnRlbnQpXG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lID09IFwicHJvamVjdC5sdDNcIikge1xuXHRcdFx0XHRcdFx0XHRcdExJR0hULmZpbGUgPSBmaWxlXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXJcblx0XHRcdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuXHRcdFx0XHRcdFx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdClcblx0XHRcdFx0XHRcdFx0XHRcdFNIT1cucGFyYW1zID0gZGF0YS5zb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0U0hPVy50cmFja3MgPSBkYXRhLnRyYWNrc1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnLm1wMycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0QVVESU8uZmlsZSA9IGZpbGVcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ltYWdlcy8nKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKG5hbWUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCsrZW5kZWQgPT09IGVudHJpZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShTSE9XKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXHRcdH0pXG5cdH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUxTRihmaWxlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cdFx0cmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcblx0XHRyZWFkZXIub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0Y29uc3Qgb3V0cHV0ID0ge31cblx0XHRcdGNvbnN0IGRhdGEgPSByZWFkZXIucmVzdWx0Lm1hdGNoKC9AP1xcdytbXkBdKy9tZykubWFwKHNlZ21lbnQgPT4ge1xuXHRcdFx0XHRsZXQgaWQgPSAnQUInXG5cdFx0XHRcdGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ0AnKSkge1xuXHRcdFx0XHRcdGlkID0gc2VnbWVudFsxXTtcblx0XHRcdFx0XHRzZWdtZW50ID0gc2VnbWVudC5zdWJzdHIoMilcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3V0cHV0W2lkXSA9IHNlZ21lbnQudHJpbSgpLnNwbGl0KC9cXHJ8XFxufFxcclxcbi8pXG5cdFx0XHRcdFx0LmZpbHRlcihsaW5lID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiAhIWxpbmUubWF0Y2goL15bXFx0MC05XS8pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQubWFwKGxpbmUgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG1hdGNoZWRcblx0XHRcdFx0XHRcdGlmIChtYXRjaGVkID0gbGluZS5tYXRjaChyZ2JGcmFtZVJlZ2V4KSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgWywgLCBzdGFydCwgdHJhbnNpdGlvbiwgciwgZywgYl0gPSBtYXRjaGVkXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHR5cGU6IDEsIHN0YXJ0LCBkdXJhdGlvbjogMCwgdHJhbnNpdGlvbiwgciwgZywgYiB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChtYXRjaGVkID0gbGluZS5tYXRjaChlbmRGcmFtZVJlZ2V4KSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgWywgLCBzdGFydF0gPSBtYXRjaGVkXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHR5cGU6IDIsIHN0YXJ0IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKG1hdGNoZWQgPSBsaW5lLm1hdGNoKGxvb3BGcmFtZVJlZ2V4KSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgWywgc3RhcnQsIGR1cmF0aW9uXSA9IG1hdGNoZWRcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgdHlwZTogMywgc3RhcnQsIGR1cmF0aW9uLCBmcmFtZXM6IFtdIH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLm1hcCgoeyBzdGFydCA9IDAsIGR1cmF0aW9uID0gMCwgdHJhbnNpdGlvbiA9IDAsIHR5cGUgPSAwLCByID0gMCwgZyA9IDAsIGIgPSAwIH0sIGluZGV4LCBsaW5lcykgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZnJhbWUgPSBuZXcgVWludDhBcnJheSgxNilcblx0XHRcdFx0XHRcdGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoZnJhbWUuYnVmZmVyKVxuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgJiYgbGluZXNbaW5kZXggKyAxXSkge1xuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbiA9IGxpbmVzW2luZGV4ICsgMV0uc3RhcnQgLSBzdGFydFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmlldy5zZXRVaW50OCgwLCB0eXBlLCB0cnVlKVxuXHRcdFx0XHRcdFx0dmlldy5zZXRVaW50OCgxLCByLCB0cnVlKVxuXHRcdFx0XHRcdFx0dmlldy5zZXRVaW50OCgyLCBnLCB0cnVlKVxuXHRcdFx0XHRcdFx0dmlldy5zZXRVaW50OCgzLCBiLCB0cnVlKVxuXHRcdFx0XHRcdFx0dmlldy5zZXRVaW50MzIoNCwgc3RhcnQsIHRydWUpXG5cdFx0XHRcdFx0XHR2aWV3LnNldFVpbnQzMig4LCBkdXJhdGlvbiwgdHJ1ZSlcblx0XHRcdFx0XHRcdHZpZXcuc2V0VWludDMyKDEyLCB0cmFuc2l0aW9uLCB0cnVlKVxuXHRcdFx0XHRcdFx0Ly8gbGV0IGhleCA9ICcnXG5cdFx0XHRcdFx0XHQvLyBmcmFtZS5mb3JFYWNoKGJ5dGUgPT4gKGhleCArPSAoYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSArICcgJykpKVxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coaGV4KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyYW1lXG5cdFx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdFx0XHRyZXNvbHZlKGRhdGEpXG5cdFx0fVxuXHR9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VJUFgoZmlsZSkge1xuXHRjb25zdCBvdXRwdXQgPSB7XG5cdFx0aW1hZ2VzOiBbXSxcblx0XHRzZXF1ZW5jZXM6IFtdXG5cdH1cblx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXHRyZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuXHRyZWFkZXIub25sb2FkID0gKCkgPT4ge1xuXHRcdGNvbnN0IGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcblx0XHRmcmFtZS5zcmNkb2MgPSByZWFkZXIucmVzdWx0LnRvU3RyaW5nKClcblx0XHRmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBkb2MgPSBmcmFtZS5jb250ZW50RG9jdW1lbnRcblx0XHRcdGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdJdGVtJykuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludChpdGVtLmdldEF0dHJpYnV0ZSgnSW5kZXgnKSlcblx0XHRcdFx0Y29uc3QgdHlwZSA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdUeXBlJylcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnSW1nJzpcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBpdGVtLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLnJlcGxhY2UoL1xcW0NEQVRBXFxbKC4qKVxcXVxcXS8sICckMScpXG5cdFx0XHRcdFx0XHRjb25zdCB1cGxvYWRQYXRoID0gYC9pbWcvJHtpbmRleH1gXG5cdFx0XHRcdFx0XHRsZXQgaW1nID0gb3V0cHV0LmltYWdlc1tpbmRleF0gPSBuZXcgSW1hZ2UoKVxuXHRcdFx0XHRcdFx0aW1nLnNyYyA9IGBkYXRhOmltZy9wbmc7YmFzZTY0LCR7ZGF0YX1gXG5cdFx0XHRcdFx0XHRpbWcub25sb2FkID0gKCkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNDQUxFIEFORCBST1RBVEUgSU1BR0Vcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2NhbGUgPSBsZWRfbnVtcyAvIGltZy5oZWlnaHRcblx0XHRcdFx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcblx0XHRcdFx0XHRcdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXG5cdFx0XHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IChpbWcuaGVpZ2h0KVxuXHRcdFx0XHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gKGltZy53aWR0aClcblx0XHRcdFx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSAnIzAwMDAwMCdcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKVxuXHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKGltZy5oZWlnaHQgLyAyLCBpbWcud2lkdGggLyAyKVxuXHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKCg5MCAqIE1hdGguUEkpIC8gMTgwKVxuXHRcdFx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgLWltZy53aWR0aCAvIDIsIC1pbWcuaGVpZ2h0IC8gMilcblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKVxuXG5cdFx0XHRcdFx0XHRcdGltZyA9IG5ldyBJbWFnZSgpXG5cdFx0XHRcdFx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSAoY2FudmFzLndpZHRoID0gbGVkX251bXMpXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gKGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICogc2NhbGUpXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblx0XHRcdFx0XHRcdFx0XHRjb25zdCByZ2IgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoXG5cdFx0XHRcdFx0XHRcdFx0XHRjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGEucmVkdWNlKChvdXRwdXQsIGIsIGkpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKChpICsgMSkgJSA0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goYilcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb3V0cHV0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCBbXSlcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKFtyZ2JdKVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVVBMT0FEIEFTU0VUU1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG5cdFx0XHRcdFx0XHRcdFx0Zm9ybS5hcHBlbmQoJ2ZpbGVuYW1lJywgdXBsb2FkUGF0aClcblx0XHRcdFx0XHRcdFx0XHRmb3JtLmFwcGVuZCgnZmlsZScsIGJsb2IpXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblx0XHRcdFx0XHRcdFx0XHRyZXEub3BlbignUE9TVCcsICdlZGl0JywgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRyZXEuc2VuZChmb3JtKVxuXHRcdFx0XHRcdFx0XHRcdHJlcS5vbmxvYWRlbmQgPSAoZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnVXBsb2FkIGNvbXBsZXRlZC4nKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdGNhc2UgJ1NlcSc6XG5cdFx0XHRcdFx0XHRjb25zdCBsZW5ndGggPSBwYXJzZUludChpdGVtLmdldEF0dHJpYnV0ZSgnTGVuZ3RoJykpXG5cdFx0XHRcdFx0XHRvdXRwdXQuc2VxdWVuY2VzW2luZGV4XSA9IG5ldyBBcnJheShsZW5ndGgpXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNoaWxkID0gaXRlbS5xdWVyeVNlbGVjdG9yKGBEYXRhJHtpfWApXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlID0gcGFyc2VJbnQoY2hpbGQuZ2V0QXR0cmlidXRlKCdJbmRleCcpKVxuXHRcdFx0XHRcdFx0XHRjb25zdCBkdXJhdGlvbiA9IHBhcnNlSW50KGNoaWxkLmdldEF0dHJpYnV0ZSgnRHVyYXRpb24nKSlcblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNlcXVlbmNlc1tpbmRleF1baV0gPSB7IGltYWdlLCBkdXJhdGlvbiB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChmcmFtZSlcblx0XHR9XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFtZSlcblx0fVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclNob3coKSB7XG5cdCQoJy50cmFja3MnKS5mb3JFYWNoKCR0cmFja3MgPT4ge1xuXHRcdCR0cmFja3MuaW5uZXJIVE1MID0gJydcblx0XHQkdHJhY2tzLnN0eWxlLndpZHRoID0gKFNIT1cucGFyYW1zLmVuZC8xMCkgKyAncHgnXG5cdFx0U0hPVy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG5cdFx0XHRjb25zdCAkdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdFx0Y29uc3QgeyBlbGVtZW50cywgLi4ucGFyYW1zIH0gPSB0cmFja1xuXHRcdFx0JHRyYWNrLmNsYXNzTGlzdC5hZGQoJ3RyYWNrJylcblx0XHRcdE9iamVjdC5hc3NpZ24oJHRyYWNrLmRhdGFzZXQsIHBhcmFtcylcblx0XHRcdCR0cmFja3MuYXBwZW5kQ2hpbGQoJHRyYWNrKVxuXHRcdFx0cmVuZGVyTGlnaHQoJHRyYWNrLCB0cmFjaylcblx0XHR9KVxuXHR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTGlnaHQoY29udGFpbmVyLCB0cmFjaykge1xuXHRzd2l0Y2ggKHRyYWNrLmRldmljZSkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTVweCdcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTVweCdcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ3Vuc3VwcG9ydGVkIGRldmljZSB0eXBlOicsIHRyYWNrLmRldmljZSlcblx0fVxuXG5cdHRyYWNrLmVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdGNvbnN0ICRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuXHRcdGxldCB7IGNvbG9yLCBjb2xvclN0YXJ0LCBjb2xvckVuZCwgLi4ucGFyYW1zIH0gPSBlbFxuXHRcdE9iamVjdC5hc3NpZ24oJGVsLmRhdGFzZXQsIHBhcmFtcylcblx0XHRjb25zdCBzdGFydCA9IHBhcmFtcy5zdGFydFRpbWVcblx0XHRjb25zdCBkdXJhdGlvbiA9IHBhcmFtcy5lbmRUaW1lIC0gZWwuc3RhcnRUaW1lXG5cdFx0aWYgKGNvbG9yKSBjb2xvciA9IGNvbnZlcnRDb2xvcihjb2xvcilcblx0XHRpZiAoY29sb3JTdGFydCkgY29sb3JTdGFydCA9IGNvbnZlcnRDb2xvcihjb2xvclN0YXJ0KVxuXHRcdGlmIChjb2xvckVuZCkgY29sb3JFbmQgPSBjb252ZXJ0Q29sb3IoY29sb3JFbmQpXG5cdFx0JGVsLnN0eWxlLmxlZnQgPSBgJHtzdGFydCAvIDEwfXB4YFxuXHRcdCRlbC5zdHlsZS53aWR0aCA9IGAke2R1cmF0aW9uIC8gMTB9cHhgXG5cdFx0bGV0IGNvbG9yMSwgY29sb3IyXG5cdFx0c3dpdGNoIChwYXJhbXMudHlwZSkge1xuXHRcdFx0Y2FzZSAyOiAvLyBzb2xpZFxuXHRcdFx0XHQkZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdG9Dc3NDb2xvcihjb2xvcilcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMzogLy8gZ3JhZGllbnRcblx0XHRcdFx0Y29sb3IxID0gdG9Dc3NDb2xvcihjb2xvclN0YXJ0KVxuXHRcdFx0XHRjb2xvcjIgPSB0b0Nzc0NvbG9yKGNvbG9yRW5kKVxuXHRcdFx0XHQkZWwuc3R5bGUuYmFja2dyb3VuZCA9IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICR7Y29sb3IxfSAwJSwgJHtjb2xvcjJ9IDEwMCUpYFxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSA0OiAvLyBmbGFzaFxuXHRcdFx0XHRjb2xvcjEgPSB0b0Nzc0NvbG9yKGNvbG9yU3RhcnQpXG5cdFx0XHRcdGNvbG9yMiA9IHRvQ3NzQ29sb3IoY29sb3JFbmQpXG5cdFx0XHRcdGNvbnN0IHsgcGVyaW9kLCByYXRpbyB9ID0gcGFyYW1zXG5cdFx0XHRcdCRlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7ZHJhd0ZsYXNoKGNvbG9yMSwgY29sb3IyLCBwZXJpb2QsIHJhdGlvKX0pYFxuXHRcdFx0XHQvLyAkZWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnMjAlJ1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSA1OiAvLyByYWluYm93XG5cdFx0XHRcdCRlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7ZHJhd1JhaW5ib3cocGFyYW1zLnBlcmlvZCl9KWBcblx0XHRcdFx0Ly8gJGVsLnN0eWxlLmJhY2tncm91bmRTaXplID0gJzIwJSdcblx0XHRcdFx0Ly8gJGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHJlZCwgb3JhbmdlICwgeWVsbG93LCBncmVlbiwgY3lhbiwgYmx1ZSwgdmlvbGV0KWBcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgNjogLy8gZG90c1xuXHRcdFx0XHQkZWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke2RyYXdEb3RzKHRvQ3NzQ29sb3IoY29sb3IpLCBwYXJhbXMuc3BhY2luZyl9KWBcblx0XHRcdFx0Ly8gJGVsLnN0eWxlLmJhY2tncm91bmRTaXplID0gJzIwJSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgNzogLy8gcHVsc2Vcblx0XHRcdFx0JGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtkcmF3UHVsc2UodG9Dc3NDb2xvcihjb2xvciksIHBhcmFtcy5wZXJpb2QpfSlgXG5cdFx0XHRcdC8vICRlbC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICcyMCUnXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmxvZyhcInVuaGFuZGxlZCBsaWdodCB0eXBlOlwiLCBwYXJhbXMudHlwZSlcblx0XHR9XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCRlbClcblx0fSlcbn1cblxuZnVuY3Rpb24gY29udmVydENvbG9yKHsgciwgZywgYiB9KSB7XG5cdHJldHVybiB7IHI6IE1hdGgucm91bmQociAqIDI1NSksIGc6IE1hdGgucm91bmQoZyAqIDI1NSksIGI6IE1hdGgucm91bmQoYiAqIDI1NSkgfVxufVxuXG5mdW5jdGlvbiB0b0Nzc0NvbG9yKHsgciwgZywgYiB9KSB7XG5cdHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYFxufVxuXG5mdW5jdGlvbiB0b0Nzc0hTTCh7IGgsIHMsIGwgfSkge1xuXHRyZXR1cm4gYGhzbCgke2ggKiAzNjB9LCAke3MgKiAxMDB9JSwgJHtsICogMTAwfSUpYFxufVxuXG5jb25zdCB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuZnVuY3Rpb24gZHJhd0ZsYXNoKGNvbG9yMSwgY29sb3IyLCBwZXJpb2QsIHJhdGlvKSB7XG5cdHRtcENhbnZhcy53aWR0aCA9IHBlcmlvZFxuXHR0bXBDYW52YXMuaGVpZ2h0ID0gMVxuXHRjb25zdCBjdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXHRjb25zdCBsZW4xID0gcGVyaW9kICogKHJhdGlvIC8gMTAwKVxuXHRjb25zdCBsZW4yID0gcGVyaW9kICogKCgxMDAgLSByYXRpbykgLyAxMDApXG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjFcblx0Y3R4LmZpbGxSZWN0KDAsIDAsIGxlbjEsIDEpO1xuXHRjdHguZmlsbFN0eWxlID0gY29sb3IyXG5cdGN0eC5maWxsUmVjdChsZW4xLCAwLCBsZW4yLCAxKTtcblx0cmV0dXJuIHRtcENhbnZhcy50b0RhdGFVUkwoKVxufVxuZnVuY3Rpb24gZHJhd0RvdHMoY29sb3IsIHNwYWNpbmcpIHtcblx0dG1wQ2FudmFzLndpZHRoID0gc3BhY2luZyArIDJcblx0dG1wQ2FudmFzLmhlaWdodCA9IDFcblx0Y29uc3QgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJylcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0Y3R4LmZpbGxTdHlsZSA9ICdibGFjaydcblx0Y3R4LmZpbGxSZWN0KDEsIDAsIDEsIDEpO1xuXHRyZXR1cm4gdG1wQ2FudmFzLnRvRGF0YVVSTCgpXG59XG5mdW5jdGlvbiBkcmF3UHVsc2UoY29sb3IsIHBlcmlvZCkge1xuXHR0bXBDYW52YXMud2lkdGggPSBwZXJpb2Rcblx0dG1wQ2FudmFzLmhlaWdodCA9IDFcblx0Y29uc3QgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJylcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdGN0eC5maWxsUmVjdCgwLCAwLCBwZXJpb2QsIDEpO1xuXHRjdHguZmlsbFN0eWxlID0gJ2JsYWNrJ1xuXHRjdHguZmlsbFJlY3QoMCwgMCwgMjQsIDEpO1xuXHRjdHguZmlsbFN0eWxlID0gJ3doaXRlJ1xuXHRjdHguZmlsbFJlY3QoMTIsIDAsIDIsIDEpO1xuXHRyZXR1cm4gdG1wQ2FudmFzLnRvRGF0YVVSTCgpXG59XG5mdW5jdGlvbiBkcmF3UmFpbmJvdyhwZXJpb2QpIHtcblx0dG1wQ2FudmFzLndpZHRoID0gcGVyaW9kXG5cdHRtcENhbnZhcy5oZWlnaHQgPSAxXG5cdGNvbnN0IGN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cdHZhciBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBwZXJpb2QsIDApO1xuXHRncmFkaWVudC5hZGRDb2xvclN0b3AoMSAvIDYgKiAwLCAncmVkJyk7XG5cdGdyYWRpZW50LmFkZENvbG9yU3RvcCgxIC8gNiAqIDEsICdvcmFuZ2UnKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEgLyA2ICogMiwgJ3llbGxvdycpO1xuXHRncmFkaWVudC5hZGRDb2xvclN0b3AoMSAvIDYgKiAzLCAnZ3JlZW4nKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEgLyA2ICogNCwgJ2N5YW4nKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEgLyA2ICogNSwgJ2JsdWUnKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEgLyA2ICogNiwgJ3Zpb2xldCcpO1xuXHRjdHguZmlsbFN0eWxlID0gZ3JhZGllbnRcblx0Y3R4LmZpbGxSZWN0KDAsIDAsIHBlcmlvZCwgMSk7XG5cdHJldHVybiB0bXBDYW52YXMudG9EYXRhVVJMKClcbn1cbiIsImRvY3VtZW50LmhlYWQuaW5uZXJIVE1MICs9IGA8c3R5bGU+XG5cbngtY29uc29sZSBtYWluIHtcblx0cGFkZGluZzogMDtcblx0bWFyZ2luOiAwO1xufVxueC1jb25zb2xlIHtcblx0ei1pbmRleDogMjAwMDtcblx0ZGlzcGxheTogYmxvY2s7XG5cdHBvc2l0aW9uOiBmaXhlZDtcblx0Ym90dG9tOiAwO1xuXHRyaWdodDogMDtcblx0bGVmdDogMDtcblx0XG5cdGJhY2tncm91bmQ6ICMwMjAyMDJjOTtcblx0Ym9yZGVyOiAxMHB4IHNvbGlkICMwMjAyMDJjOTtcblx0XG5cdGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuXHRtYXgtaGVpZ2h0OiA1MHB4O1xuXHRvdmVyZmxvdzogYXV0bztcbn1cbngtY29uc29sZSBpbnB1dCxcbngtY29uc29sZSBvdXRwdXQsXG54LWNvbnNvbGUgc3BhbiB7XG5cdHVzZXItc2VsZWN0OiB0ZXh0O1xuXHRmb250LWZhbWlseTogbWVubG87XG5cdGZvbnQtc2l6ZTogMTJweDtcblx0bGluZS1oZWlnaHQ6IDEuNWVtO1xufVxueC1jb25zb2xlIGlucHV0LFxueC1jb25zb2xlIHNwYW4ge1xuXHRoZWlnaHQ6IDEuNWVtO1xufVxueC1jb25zb2xlIGlucHV0LFxueC1jb25zb2xlIG91dHB1dCB7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXJnaW46IDA7XG5cdHBhZGRpbmc6IDA7XG5cdGJvcmRlcjogbm9uZTtcblx0YmFja2dyb3VuZDogbm9uZTtcblx0b3V0bGluZTogbm9uZTtcblx0d2hpdGUtc3BhY2U6IHByZSAhaW1wb3J0YW50O1xuXHRjb2xvcjogI2ZmZjtcblx0dGV4dC1hbGlnbjogbGVmdDtcbn1cbngtY29uc29sZSBsaW5lIHtcblx0ZGlzcGxheTogZ3JpZDtcblx0Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyMHB4IGF1dG87XG59XG54LWNvbnNvbGUgbGluZSBzcGFuLFxueC1jb25zb2xlIGxpbmUgb3V0cHV0IHtcblx0Y29sb3I6IGxpZ2h0Z3JleTtcbn1cbngtY29uc29sZSBsaW5lLmRlYnVnICoge1xuXHRjb2xvcjogbGlnaHRncmVlbjtcbn1cbngtY29uc29sZSBsaW5lLmluZm8gKiB7XG5cdGNvbG9yOiBza3libHVlO1xufVxueC1jb25zb2xlIGxpbmUud2FybiAqIHtcblx0Y29sb3I6IHllbGxvdztcbn1cbngtY29uc29sZSBsaW5lLmVycm9yICoge1xuXHRjb2xvcjogb3JhbmdlcmVkO1xufVxueC1jb25zb2xlIGxpbmUuaW5wdXQgKiB7XG5cdGNvbG9yOiB3aGl0ZTtcbn1cbngtY29uc29sZSBsaW5lLmlucHV0IHtcblx0ZGlzcGxheTogbm9uZTtcbn1cbjwvc3R5bGU+YFxuXG5jbGFzcyBDb25zb2xlRWxlbWVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4LWNvbnNvbGUnKVxuXHRcdHRoaXMuZWwuaW5uZXJIVE1MID0gYFxuXHRcdDxtYWluPjwvbWFpbj5cblx0XHQ8bGluZSBjbGFzcz1cImlucHV0XCI+XG5cdFx0XHQ8c3Bhbj4jPC9zcGFuPlxuXHRcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz5cblx0XHQ8L2xpbmU+XG5cdFx0YFxuXHRcdHRoaXMubWFpbiA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignbWFpbicpXG5cdFx0dGhpcy5pbnB1dCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKVxuXHRcdHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKVxuXHR9XG5cblx0aGFuZGxlS2V5ZG93bihlKSB7XG5cdFx0aWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG5cdFx0XHR0aGlzLnB1c2goJyMnLCAnJywgZS50YXJnZXQudmFsdWUpXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLnB1c2goJ+KAoicsICdpbmZvJywgU3RyaW5nKGV2YWwoZS50YXJnZXQudmFsdWUpKSlcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHR0aGlzLnB1c2goJ+KAoicsICdlcnJvcicsIGVyci5zdGFjaylcblx0XHRcdH1cblx0XHRcdGUudGFyZ2V0LnZhbHVlID0gJydcblx0XHRcdGUudGFyZ2V0LmZvY3VzKClcblx0XHR9XG5cdH1cblxuXHRwdXNoKGljb24sIHR5cGUsIC4uLmFyZ3MpIHtcblx0XHRjb25zdCBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluZScpXG5cdFx0dHlwZSAmJiBsaW5lLmNsYXNzTGlzdC5hZGQodHlwZSlcblx0XHRsaW5lLmlubmVySFRNTCA9IGA8c3Bhbj4ke2ljb259PC9zcGFuPjxvdXRwdXQ+PC9vdXRwdXQ+YFxuXHRcdGNvbnN0IG91dHB1dCA9IGxpbmUucXVlcnlTZWxlY3Rvcignb3V0cHV0Jylcblx0XHRvdXRwdXQuaW5uZXJUZXh0ID0gYXJncy5qb2luKCcgJylcblx0XHR0aGlzLmxhc3RPdXRwdXQgPSBvdXRwdXRcblx0XHR0aGlzLm1haW4uYXBwZW5kQ2hpbGQobGluZSlcblx0XHR0aGlzLmVsLnNjcm9sbFRvcCA9IHRoaXMuZWwuc2Nyb2xsSGVpZ2h0XG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG59XG5jb25zdCBsb2dnZXIgPSBuZXcgQ29uc29sZUVsZW1lbnQoKVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsb2dnZXIuZWwpXG5cbmNvbnN0IG9yaWdpbmFsID0ge31cbmZvciAobGV0IGtleSBpbiBjb25zb2xlKSB7XG5cdG9yaWdpbmFsW2tleV0gPSBjb25zb2xlW2tleV1cbn1cblxud2luZG93LmNvbnNvbGUubG9nID0gKC4uLmFyZ3MpID0+IHtcblx0b3JpZ2luYWwubG9nKC4uLmFyZ3MpXG5cdHJldHVybiBsb2dnZXIucHVzaCgn4oCiJywgJ2xvZycsIC4uLmFyZ3MpXG59XG53aW5kb3cuY29uc29sZS5kZWJ1ZyA9ICguLi5hcmdzKSA9PiB7XG5cdG9yaWdpbmFsLmRlYnVnKC4uLmFyZ3MpXG5cdHJldHVybiBsb2dnZXIucHVzaCgn4oCiJywgJ2RlYnVnJywgLi4uYXJncylcbn1cbndpbmRvdy5jb25zb2xlLmluZm8gPSAoLi4uYXJncykgPT4ge1xuXHRvcmlnaW5hbC5pbmZvKC4uLmFyZ3MpXG5cdHJldHVybiBsb2dnZXIucHVzaCgn4oCiJywgJ2luZm8nLCAuLi5hcmdzKVxufVxud2luZG93LmNvbnNvbGUud2FybiA9ICguLi5hcmdzKSA9PiB7XG5cdG9yaWdpbmFsLndhcm4oLi4uYXJncylcblx0cmV0dXJuIGxvZ2dlci5wdXNoKCfigKInLCAnd2FybicsIC4uLmFyZ3MpXG59XG53aW5kb3cuY29uc29sZS5lcnJvciA9ICguLi5hcmdzKSA9PiB7XG5cdG9yaWdpbmFsLmVycm9yKC4uLmFyZ3MpXG5cdHJldHVybiBsb2dnZXIucHVzaCgn4oCiJywgJ2Vycm9yJywgLi4uYXJncylcbn1cbndpbmRvdy5jb25zb2xlLmFwcGVuZCA9ICguLi5hcmdzKSA9PiB7XG5cdGlmIChsb2dnZXIubGFzdE91dHB1dCkge1xuXHRcdGxvZ2dlci5sYXN0T3V0cHV0LmlubmVySFRNTCA9IGAke2xvZ2dlci5sYXN0T3V0cHV0LmlubmVySFRNTH0ke2FyZ3Muam9pbignICcpfWBcblx0fVxufVxuIiwiaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsXCJcbmltcG9ydCB7IHJlbmRlck5vZGVzIH0gZnJvbSBcIi4vYXBwXCJcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gXCIuL2RhdGFcIlxuXG5sZXQgc29ja2V0XG5sZXQgZnNSZXNwb25zZWRcblxuKGZ1bmN0aW9uIGNyZWF0ZVNvY2tldCgpIHtcblx0Y29uc29sZS5sb2coJ1NPQ0tFVCBpbml0aWFsaXplIC4uLicpXG5cdHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoYHdzOi8vJHtsb2NhdGlvbi5ob3N0bmFtZX06ODFgKVxuXHRzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcblx0c29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZSkgPT4ge1xuXHRcdGlmICh0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJykge1xuXHRcdFx0Ly8gaGFuZGxlTWVzc2FnZShlLmRhdGEpXG5cdFx0fVxuXHRcdGlmIChlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0bGV0IGNoYW5nZWQgPSBmYWxzZVxuXHRcdFx0bGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoZS5kYXRhKVxuXHRcdFx0Y29uc3QgaWQgPSByZWFkU3RyKHZpZXcsIDYsIDApO1xuXHRcdFx0aWYgKHJlYWRTdHIodmlldywgMSwgNikgIT09ICc8Jykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJ3cm9uZyBmb3JtYXQgWFhYWFhYPENNRC4uLlwiKTtcblx0XHRcdH0gZWxzZSBpZiAoZXF1YWxzKCc8UElORycsIHZpZXcsIDYpKSB7XG5cdFx0XHRcdGNvbnN0IG4xID0ge1xuXHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdHR5cGU6IHZpZXcuZ2V0VWludDgoMTEpLFxuXHRcdFx0XHRcdHZiYXQ6IHZpZXcuZ2V0VWludDE2KDEyKSxcblx0XHRcdFx0XHRuYW1lOiByZWFkU3RyKHZpZXcsIDIwLCAxNCksXG5cdFx0XHRcdFx0aGlkZGVuOiBmYWxzZSxcblx0XHRcdFx0XHRsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBleGlzdCA9IGZhbHNlXG5cdFx0XHRcdENPTkZJRy5ub2Rlcy5mb3JFYWNoKG4yID0+IHtcblx0XHRcdFx0XHRpZiAobjEuaWQgPT0gbjIuaWQpIHtcblx0XHRcdFx0XHRcdGlmICghaXNFcXVhbChuMSwgbjIpKSB7XG5cdFx0XHRcdFx0XHRcdE9iamVjdC5hc3NpZ24objIsIG4xKVxuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZXhpc3QgPSB0cnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpZiAoIWV4aXN0KSBDT05GSUcubm9kZXMucHVzaChuMSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdENPTkZJRy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuXHRcdFx0XHRcdGlmIChpZCA9PSBub2RlLmlkKSB7XG5cdFx0XHRcdFx0XHR2aWV3ID0gbmV3IERhdGFWaWV3KGUuZGF0YS5zbGljZSg3KSlcblx0XHRcdFx0XHRcdGlmIChlcXVhbHMoJ1NFTEVDVCcsIHZpZXcpKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGUuc2VsZWN0ZWQgPSAhbm9kZS5zZWxlY3RlZDtcblx0XHRcdFx0XHRcdFx0bm9kZS5sYXN0VXBkYXRlZCA9IERhdGUubm93KClcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG5vZGUuc2VsZWN0ZWQpIHNlbmQobm9kZS5pZCwgJ0JMSU5LJywgNSlcblx0XHRcdFx0XHRcdFx0ZWxzZSBzZW5kKG5vZGUuaWQsICdCTElOSycsIDApXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYW5nZWQpIHJlbmRlck5vZGVzKClcblx0XHR9XG5cdH0pXG5cdHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHtcblx0XHRzZXRUaW1lb3V0KGNyZWF0ZVNvY2tldCwgMTAwMClcblx0fSlcblx0c29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG5cblx0fSlcblx0d2luZG93LnNvY2tldCA9IHNvY2tldFxufSkoKVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0RmlsZVJlc3BvbnNlKHRpbWVvdXQgPSAxMDAwKSB7XG5cdGNvbnN0IGV4cGlyZWQgPSBEYXRlLm5vdyArIDEwMDBcblx0ZnNSZXNwb25zZWQgPSBmYWxzZVxuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gY2hlY2soKSB7XG5cdFx0XHRpZiAoZnNSZXNwb25zZWQpIHJlc29sdmUoKVxuXHRcdFx0ZWxzZSBpZiAoRGF0ZS5ub3coKSA+IGV4cGlyZWQpIHJlamVjdCgpXG5cdFx0XHRlbHNlIHNldFRpbWVvdXQoY2hlY2ssIDEpXG5cdFx0fSlcblx0fSlcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kRmlsZSh0YXJnZXQsIHBhdGgsIGZpbGUpIHtcblx0YXdhaXQgc2VuZCh0YXJnZXQsICdGUzEnICsgcGF0aClcblx0YXdhaXQgd2FpdEZpbGVSZXNwb25zZSgpXG5cdGNvbnNvbGUubG9nKCdmaWxlIHNlbmQgb3BlbicpXG5cdGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyXG5cdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKVxuXHRyZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGFzeW5jIGUgPT4ge1xuXHRcdGxldCBvZmZzZXQgPSAwO1xuXHRcdGNvbnN0IGJ1ZiA9IGUudGFyZ2V0LnJlc3VsdFxuXHRcdHdoaWxlIChvZmZzZXQgPCBidWYuYnl0ZUxlbmd0aCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2ZpbGUgc2VudCBjaHVuaycpXG5cdFx0XHRjb25zdCBzaXplID0gTWF0aC5taW4oYnVmLmJ5dGVMZW5ndGggLSBvZmZzZXQsIDI0MClcblx0XHRcdGF3YWl0IHNlbmQodGFyZ2V0LCAnRlMyJywgLi4ubmV3IFVpbnQ4QXJyYXkoYnVmLnNsaWNlKG9mZnNldCwgc2l6ZSkpKVxuXHRcdFx0YXdhaXQgd2FpdEZpbGVSZXNwb25zZSgpXG5cdFx0XHRvZmZzZXQgKz0gMjQwXG5cdFx0fVxuXHRcdGF3YWl0IHNlbmQodGFyZ2V0LCAnRlMzJylcblx0XHRhd2FpdCB3YWl0RmlsZVJlc3BvbnNlKClcblx0XHRjb25zb2xlLmxvZygnZmlsZSBzZW5kIGRvbmUnKVxuXHR9KVxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU3luYygpIHtcblx0Y29uc3QgcGF5bG9hZCA9IG5ldyBVaW50OEFycmF5KDEzKVxuXHRjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHBheWxvYWQuYnVmZmVyKVxuXHRwcmludCh2aWV3LCAnIz5TWU5DJywgMClcblx0dmlldy5zZXRVaW50OCg2LCBDT05GSUcuc2hvdylcblx0dmlldy5zZXRVaW50OCg3LCBDT05GSUcucnVubmluZylcblx0dmlldy5zZXRVaW50OCg4LCBDT05GSUcucGF1c2VkKVxuXHR2aWV3LnNldFVpbnQzMig5LCBDT05GSUcudGltZSlcblx0c29ja2V0LnNlbmQocGF5bG9hZC5idWZmZXIpXG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKHRleHQgPSAnJywgdmlldywgb2Zmc2V0ID0gMCkge1xuXHRyZXR1cm4gdGV4dC5zcGxpdCgnJykuZXZlcnkoKGMsIGkpID0+IHtcblx0XHRyZXR1cm4gYyA9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXcuZ2V0VWludDgoaSArIG9mZnNldCkpXG5cdH0pXG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cih2aWV3LCBzaXplLCBvZmZzZXQgPSAwKSB7XG5cdGxldCBvdXRwdXQgPSAnJ1xuXHRsZXQgYnl0ZVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuXHRcdGJ5dGUgPSB2aWV3LmdldFVpbnQ4KGkgKyBvZmZzZXQpXG5cdFx0aWYgKGJ5dGUgPj0gMzAgJiYgYnl0ZSA8IDEyNykge1xuXHRcdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSlcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dFxufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50KHZpZXcsIHN0ciwgcG9zID0gMCkge1xuXHRsZXQgb2Zmc2V0ID0gcG9zXG5cdHN0ci5zcGxpdCgnJykubWFwKChjLCBpKSA9PiB7XG5cdFx0b2Zmc2V0ID0gaSArIHBvc1xuXHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBjLmNoYXJDb2RlQXQoMCkpXG5cdH0pXG5cdHJldHVybiBvZmZzZXQgKyAxXG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZCh0YXJnZXQgPSAnIycsIGhlYWRlciA9ICcnLCAuLi5wYXlsb2FkKSB7XG5cdGNvbnN0IHRhcmdldEJ5dGVzID0gdGFyZ2V0LnNwbGl0KCcnKS5tYXAoYyA9PiBjLmNoYXJDb2RlQXQoMCkpXG5cdGNvbnN0IGhlYWRlckJ5dGVzID0gaGVhZGVyLnNwbGl0KCcnKS5tYXAoYyA9PiBjLmNoYXJDb2RlQXQoMCkpXG5cdHNvY2tldC5zZW5kKG5ldyBVaW50OEFycmF5KFsuLi50YXJnZXRCeXRlcywgNjIsIC4uLmhlYWRlckJ5dGVzLCAuLi5wYXlsb2FkXSkpXG59XG5cbi8vIGNvbnN0IGRlYm91bmNlR2V0Tm9kZXMgPSBkZWJvdW5jZShhc3luYyBmdW5jdGlvbiAoKSB7XG4vLyBcdENPTkZJRy5ub2RlcyA9IGF3YWl0IGdldCgnbm9kZXMnKVxuLy8gXHRyZW5kZXJOb2RlcygpXG4vLyB9LCAxMDApXG4vLyBsZXQgaXNSdW5uaW5nID0gZmFsc2U7XG4vLyBsZXQgaXNQYXVzZWQgPSBmYWxzZTtcbi8vICBhc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1zZykge1xuLy8gXHQvLyBjb25zb2xlLmxvZyhgU09DS0VUOjogYCwgbXNnKVxuLy8gXHRpZiAobXNnLnN0YXJ0c1dpdGgoJyM8UElORycpKSB7XG4vLyBcdFx0ZGVib3VuY2VHZXROb2RlcygpXG4vLyBcdH1cbi8vIFx0ZWxzZSBpZiAobXNnLnN0YXJ0c1dpdGgoJyM+U1lOQycpKSB7XG4vLyBcdFx0Y29uc3QgWywgYSwgYiwgY10gPSBtc2cuc3BsaXQoJzonKVxuLy8gXHRcdGNvbnN0IHRpbWUgPSBwYXJzZUludChhKSAvIDEwXG4vLyBcdFx0Y29uc3QgcnVubmluZyA9ICEhcGFyc2VJbnQoYilcbi8vIFx0XHRjb25zdCBwYXVzZWQgPSAhIXBhcnNlSW50KGMpXG4vLyBcdFx0aWYgKGlzUGF1c2VkICE9PSBwYXVzZWQpIHtcbi8vIFx0XHRcdGlzUGF1c2VkID0gcGF1c2VkXG4vLyBcdFx0XHRpZiAocGF1c2VkKSB7XG4vLyBcdFx0XHRcdHNldEF0dHIoJyNwYXVzZScsICdkYXRhLWNvbW1hbmQnLCAncmVzdW1lJylcbi8vIFx0XHRcdFx0c2V0VGV4dCgnI3BhdXNlJywgJ1JFU1VNRScpXG4vLyBcdFx0XHRcdGNhbGwoJyNwbGF5ZXInLCAncGF1c2UnKVxuLy8gXHRcdFx0fSBlbHNlIHtcbi8vIFx0XHRcdFx0c2V0QXR0cignI3BhdXNlJywgJ2RhdGEtY29tbWFuZCcsICdwYXVzZScpXG4vLyBcdFx0XHRcdHNldFRleHQoJyNwYXVzZScsICdQQVVTRScpXG4vLyBcdFx0XHRcdGNhbGwoJyNwbGF5ZXInLCAncGxheScpXG4vLyBcdFx0XHR9XG4vLyBcdFx0fVxuLy8gXHRcdGlmIChpc1J1bm5pbmcgIT09IHJ1bm5pbmcpIHtcbi8vIFx0XHRcdGlzUnVubmluZyA9IHJ1bm5pbmdcbi8vIFx0XHRcdGlmIChydW5uaW5nKSB7XG4vLyBcdFx0XHRcdHNldEF0dHIoJyNwbGF5JywgJ2RhdGEtY29tbWFuZCcsICdlbmQnKVxuLy8gXHRcdFx0XHRzZXRUZXh0KCcjcGxheScsICdTVE9QJylcbi8vIFx0XHRcdFx0c2V0UHJvcCgnI3BsYXllcicsICdjdXJyZW50VGltZScsIDApXG4vLyBcdFx0XHRcdGNhbGwoJyNwbGF5ZXInLCAncGxheScpXG4vLyBcdFx0XHR9IGVsc2Uge1xuLy8gXHRcdFx0XHRzZXRBdHRyKCcjcGxheScsICdkYXRhLWNvbW1hbmQnLCAnc3RhcnQnKVxuLy8gXHRcdFx0XHRzZXRUZXh0KCcjcGxheScsICdQTEFZJylcbi8vIFx0XHRcdFx0Y2FsbCgnI3BsYXllcicsICdwYXVzZScpXG4vLyBcdFx0XHRcdHNldFByb3AoJyNwbGF5ZXInLCAnY3VycmVudFRpbWUnLCAwKVxuLy8gXHRcdFx0fVxuLy8gXHRcdH1cbi8vIFx0fVxuLy8gfVxuXG4vLyBleHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZEZpbGUoZmlsZSwgcmVjZWl2ZXJzID0gW10pIHtcbi8vIFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXJcbi8vIFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpXG4vLyBcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgYXN5bmMgZSA9PiB7XG4vLyBcdFx0Y29uc3QgYnVmID0gZS50YXJnZXQucmVzdWx0XG4vLyBcdFx0Y29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpXG5cbi8vIFx0XHQvLyBCZWdpbiBmaWxlIHN0cmVhbVxuLy8gXHRcdGlmICghcmVjZWl2ZXJzLmxlbmd0aCkge1xuLy8gXHRcdFx0YXdhaXQgc2VuZCgnIz5GSUxFXicpXG4vLyBcdFx0fSBlbHNlIHtcbi8vIFx0XHRcdHdoaWxlIChyZWNlaXZlcnMubGVuZ3RoKSB7XG4vLyBcdFx0XHRcdGxldCBpZCA9IHJlY2VpdmVycy5wb3AoKVxuLy8gXHRcdFx0XHRhd2FpdCBzZW5kKCcjPkZJTEVeJyArIGlkKVxuLy8gXHRcdFx0fVxuLy8gXHRcdH1cblxuLy8gXHRcdC8vIGZpbGUgY29udGVudCBzdHJlYW1cbi8vIFx0XHRsZXQgb2Zmc2V0ID0gMFxuLy8gXHRcdHdoaWxlIChvZmZzZXQgPCBidWYuYnl0ZUxlbmd0aCkge1xuLy8gXHRcdFx0bGV0IGxlbiA9IE1hdGgubWluKGJ1Zi5ieXRlTGVuZ3RoIC0gb2Zmc2V0LCAyNDApXG4vLyBcdFx0XHRsZXQgcGF5bG9hZCA9IGJ1Zi5zbGljZShvZmZzZXQsIGxlbilcbi8vIFx0XHRcdHNlbmQobmV3IEJsb2IoWycjPkZJTEUrJywgcGF5bG9hZF0pKVxuLy8gXHRcdFx0b2Zmc2V0ICs9IGxlblxuLy8gXHRcdH1cblxuLy8gXHRcdC8vIGZpbGUgZW5kXG5cbi8vIFx0fSlcbi8vIH1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWwsIHsgc2VuZCwgc2VuZFN5bmMgfSlcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG4vLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cbi8vICAgICBub2RlLWFzc2VydCBoYXMgZXZvbHZlZCBhIGxvdCBzaW5jZSB0aGVuLCBib3RoIGluIEFQSSBhbmQgYmVoYXZpb3IuXG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXHJcbnZhciBSZWFkU3RyZWFtID0gcmVxdWlyZSgnLi9yZWFkLXN0cmVhbScpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsb2JTbGljZXJcclxuXHJcbmZ1bmN0aW9uIEJsb2JTbGljZXIgKGJsb2IpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmxvYlNsaWNlcikpIHJldHVybiBuZXcgQmxvYlNsaWNlcihibG9iKVxyXG5cclxuICBpZiAoIShcclxuICAgIGJsb2IgaW5zdGFuY2VvZiBCbG9iIHx8XHJcbiAgICBbJ1tvYmplY3QgQmxvYl0nLCAnW29iamVjdCBGaWxlXSddLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJsb2IpKSAhPT0gLTFcclxuICApKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2JcIiBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEJsb2Igb3IgRmlsZScpXHJcblxyXG4gIHRoaXMuX2Jsb2IgPSBibG9iXHJcbn1cclxuXHJcbkJsb2JTbGljZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY2IpIHtcclxuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnZnVuY3Rpb24nKSBjYiA9IHN0YXJ0XHJcbiAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2IgPSBlbmRcclxuICAgIGVuZCA9IHRoaXMuX2Jsb2Iuc2l6ZVxyXG4gIH1cclxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJylcclxuXHJcbiAgc3RhcnQgPSB+fnN0YXJ0XHJcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLl9ibG9iLnNpemUgOiB+fmVuZFxyXG5cclxuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxyXG4gIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gb25Mb2FkZW5kICgpIHtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZGVuZClcclxuICAgIGNiKHRoaXMuZXJyb3IsIHRoaXMucmVzdWx0ID8gQnVmZmVyLmZyb20odGhpcy5yZXN1bHQpIDogbnVsbClcclxuICB9KVxyXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLl9ibG9iLnNsaWNlKHN0YXJ0LCBlbmQpKVxyXG59XHJcblxyXG5CbG9iU2xpY2VyLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IFJlYWRTdHJlYW0odGhpcy5fYmxvYiwgb3B0aW9ucylcclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhZFN0cmVhbVxyXG5cclxuZnVuY3Rpb24gUmVhZFN0cmVhbSAoYmxvYiwgb3B0aW9ucykge1xyXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XHJcbiAgaWYgKG9wdGlvbnMuaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLmhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjRcclxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpXHJcblxyXG4gIHZhciBzdGFydCA9IH5+b3B0aW9ucy5zdGFydFxyXG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCA9PT0gdW5kZWZpbmVkID8gYmxvYi5zaXplIDogfn5vcHRpb25zLmVuZFxyXG5cclxuICB0aGlzLl9ibG9iID0gYmxvYi5zbGljZShzdGFydCwgZW5kKVxyXG4gIHRoaXMuX2VuZCA9IHRoaXMuX2Jsb2Iuc2l6ZVxyXG4gIHRoaXMuX3BvcyA9IDBcclxuICB0aGlzLl9yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXHJcblxyXG4gIHZhciBzZWxmID0gdGhpc1xyXG4gIHRoaXMuX2xvYWRlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmVycm9yKSB7XHJcbiAgICAgIHNlbGYuZGVzdHJveSh0aGlzLmVycm9yKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBzZWxmLl9wb3MgKz0gdGhpcy5yZXN1bHQuYnl0ZUxlbmd0aFxyXG4gICAgc2VsZi5wdXNoKEJ1ZmZlci5mcm9tKHRoaXMucmVzdWx0KSlcclxuICB9XHJcbiAgdGhpcy5fcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCB0aGlzLl9sb2FkZW5kTGlzdGVuZXIpXHJcblxyXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsgdGhpcy5kZXN0cm95KCkgfSlcclxufVxyXG5SZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGUucHJvdG90eXBlKVxyXG5SZWFkU3RyZWFtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWRTdHJlYW1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRTdHJlYW0ucHJvdG90eXBlLCB7XHJcbiAgcmVhZGFibGVMZW5ndGg6IHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggfVxyXG4gIH0sXHJcbiAgZW5kZWQ6IHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcG9zID49IHRoaXMuX2VuZCB9XHJcbiAgfVxyXG59KVxyXG5cclxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xyXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXHJcblxyXG4gIGlmICh0aGlzLmVuZGVkKSB7XHJcbiAgICB0aGlzLnB1c2gobnVsbClcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdGhpcy5fcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHRoaXMuX2Jsb2Iuc2xpY2UodGhpcy5fcG9zLCB0aGlzLl9wb3MgKyBuKSlcclxufVxyXG5cclxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xyXG4gIGNiKGVycilcclxuICBpZiAodGhpcy5fcmVhZGVyLnJlYWR5U3RhdGUgPT09IEZpbGVSZWFkZXIuTE9BRElORykgdGhpcy5fcmVhZGVyLmFib3J0KClcclxuICB0aGlzLl9yZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIHRoaXMuX2xvYWRlbmRMaXN0ZW5lcilcclxuICB0aGlzLl9yZWFkZXIgPSBudWxsXHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBac3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbnZhciBHWklQX0hFQURFUl9JRDEgPSAweDFmO1xudmFyIEdaSVBfSEVBREVSX0lEMiA9IDB4OGI7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmICh0eXBlb2YgbW9kZSAhPT0gJ251bWJlcicgfHwgbW9kZSA8IGV4cG9ydHMuREVGTEFURSB8fCBtb2RlID4gZXhwb3J0cy5VTlpJUCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbiAgdGhpcy5lcnIgPSAwO1xuICB0aGlzLmZsdXNoID0gMDtcbiAgdGhpcy5pbml0X2RvbmUgPSBmYWxzZTtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMubWVtTGV2ZWwgPSAwO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLnN0cmF0ZWd5ID0gMDtcbiAgdGhpcy53aW5kb3dCaXRzID0gMDtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAwO1xufVxuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnBlbmRpbmdfY2xvc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ2Nsb3NlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgPD0gZXhwb3J0cy5VTlpJUCk7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUCkge1xuICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH1cblxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICByZXR1cm4gdGhpcy5fd3JpdGUodHJ1ZSwgZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uIChmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZhbHNlLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGFzeW5jLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgYXNzZXJ0LmVxdWFsKGFyZ3VtZW50cy5sZW5ndGgsIDgpO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ3dyaXRlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgIT09IGV4cG9ydHMuTk9ORSwgJ2FscmVhZHkgZmluYWxpemVkJyk7XG4gIGFzc2VydC5lcXVhbChmYWxzZSwgdGhpcy53cml0ZV9pbl9wcm9ncmVzcywgJ3dyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCB0aGlzLnBlbmRpbmdfY2xvc2UsICdjbG9zZSBpcyBwZW5kaW5nJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCBmbHVzaCA9PT0gdW5kZWZpbmVkLCAnbXVzdCBwcm92aWRlIGZsdXNoIHZhbHVlJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgaWYgKGZsdXNoICE9PSBleHBvcnRzLlpfTk9fRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfU1lOQ19GTFVTSCAmJiBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZVTExfRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9CTE9DSykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCB2YWx1ZScpO1xuICB9XG5cbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICBpbnB1dCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cblxuICB0aGlzLnN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHRoaXMuc3RybS5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnN0cm0ubmV4dF9pbiA9IGluX29mZjtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHRoaXMuc3RybS5vdXRwdXQgPSBvdXQ7XG4gIHRoaXMuc3RybS5uZXh0X291dCA9IG91dF9vZmY7XG4gIHRoaXMuZmx1c2ggPSBmbHVzaDtcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgLy8gc3luYyB2ZXJzaW9uXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyU3luYygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhc3luYyB2ZXJzaW9uXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcHJvY2VzcygpO1xuICAgIHNlbGYuX2FmdGVyKCk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsX291dCA9IHRoaXMuc3RybS5hdmFpbF9vdXQ7XG4gIHZhciBhdmFpbF9pbiA9IHRoaXMuc3RybS5hdmFpbF9pbjtcblxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG5cbiAgcmV0dXJuIFthdmFpbF9pbiwgYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IG51bGw7XG5cbiAgLy8gSWYgdGhlIGF2YWlsX291dCBpcyBsZWZ0IGF0IDAsIHRoZW4gaXQgbWVhbnMgdGhhdCBpdCByYW4gb3V0XG4gIC8vIG9mIHJvb20uICBJZiB0aGVyZSB3YXMgYXZhaWxfb3V0IGxlZnQgb3ZlciwgdGhlbiBpdCBtZWFuc1xuICAvLyB0aGF0IGFsbCBvZiB0aGUgaW5wdXQgd2FzIGNvbnN1bWVkLlxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZSh0aGlzLnN0cm0sIHRoaXMuZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgICAgaWYgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDApIHtcbiAgICAgICAgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IHRoaXMuc3RybS5uZXh0X2luO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuZ3ppcF9pZF9ieXRlc19yZWFkKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAobmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RybS5pbnB1dFtuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlXSA9PT0gR1pJUF9IRUFERVJfSUQxKSB7XG4gICAgICAgICAgICB0aGlzLmd6aXBfaWRfYnl0ZXNfcmVhZCA9IDE7XG4gICAgICAgICAgICBuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlKys7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfaW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgYXZhaWxhYmxlIGJ5dGUgd2FzIGFscmVhZHkgcmVhZC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cm0uaW5wdXRbbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZV0gPT09IEdaSVBfSEVBREVSX0lEMikge1xuICAgICAgICAgICAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAyO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gZXhwb3J0cy5HVU5aSVA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGFjdHVhbCBkaWZmZXJlbmNlIGJldHdlZW4gSU5GTEFURSBhbmQgSU5GTEFURVJBV1xuICAgICAgICAgICAgLy8gKGFmdGVyIGluaXRpYWxpemF0aW9uKS5cbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyIG9mIGd6aXAgbWFnaWMgbnVtYmVyIGJ5dGVzIHJlYWQnKTtcbiAgICAgIH1cblxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoXG5cbiAgICAgIC8vIElmIGRhdGEgd2FzIGVuY29kZWQgd2l0aCBkaWN0aW9uYXJ5XG4gICAgICApO2lmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX05FRURfRElDVCAmJiB0aGlzLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgLy8gTG9hZCBpdFxuICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICAgIGlmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX09LKSB7XG4gICAgICAgICAgLy8gQW5kIHRyeSB0byBkZWNvZGUgYWdhaW5cbiAgICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHRoaXMuc3RybSwgdGhpcy5mbHVzaCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lcnIgPT09IGV4cG9ydHMuWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgICAgLy8gQm90aCBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGFuZCBpbmZsYXRlKCkgcmV0dXJuIFpfREFUQV9FUlJPUi5cbiAgICAgICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIGZvciBBZnRlcigpIHRvIHRlbGwgYSBiYWQgZGljdGlvbmFyeSBmcm9tIGJhZFxuICAgICAgICAgIC8vIGlucHV0LlxuICAgICAgICAgIHRoaXMuZXJyID0gZXhwb3J0cy5aX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDAgJiYgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUCAmJiB0aGlzLmVyciA9PT0gZXhwb3J0cy5aX1NUUkVBTV9FTkQgJiYgdGhpcy5zdHJtLm5leHRfaW5bMF0gIT09IDB4MDApIHtcbiAgICAgICAgLy8gQnl0ZXMgcmVtYWluIGluIGlucHV0IGJ1ZmZlci4gUGVyaGFwcyB0aGlzIGlzIGFub3RoZXIgY29tcHJlc3NlZFxuICAgICAgICAvLyBtZW1iZXIgaW4gdGhlIHNhbWUgYXJjaGl2ZSwgb3IganVzdCB0cmFpbGluZyBnYXJiYWdlLlxuICAgICAgICAvLyBUcmFpbGluZyB6ZXJvIGJ5dGVzIGFyZSBva2F5LCB0aG91Z2gsIHNpbmNlIHRoZXkgYXJlIGZyZXF1ZW50bHlcbiAgICAgICAgLy8gdXNlZCBmb3IgcGFkZGluZy5cblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSAnICsgdGhpcy5tb2RlKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEFjY2VwdGFibGUgZXJyb3Igc3RhdGVzIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB6bGliIHN0cmVhbS5cbiAgc3dpdGNoICh0aGlzLmVycikge1xuICAgIGNhc2UgZXhwb3J0cy5aX09LOlxuICAgIGNhc2UgZXhwb3J0cy5aX0JVRl9FUlJPUjpcbiAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfb3V0ICE9PSAwICYmIHRoaXMuZmx1c2ggPT09IGV4cG9ydHMuWl9GSU5JU0gpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlpfU1RSRUFNX0VORDpcbiAgICAgIC8vIG5vcm1hbCBzdGF0dXNlcywgbm90IGZhdGFsXG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuWl9ORUVEX0RJQ1Q6XG4gICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ01pc3NpbmcgZGljdGlvbmFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ0JhZCBkaWN0aW9uYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHNvbWV0aGluZyBlbHNlLlxuICAgICAgdGhpcy5fZXJyb3IoJ1psaWIgZXJyb3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhdmFpbF9vdXQgPSB0aGlzLnN0cm0uYXZhaWxfb3V0O1xuICB2YXIgYXZhaWxfaW4gPSB0aGlzLnN0cm0uYXZhaWxfaW47XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuXG4gIC8vIGNhbGwgdGhlIHdyaXRlKCkgY2JcbiAgdGhpcy5jYWxsYmFjayhhdmFpbF9pbiwgYXZhaWxfb3V0KTtcblxuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBpZiAodGhpcy5zdHJtLm1zZykge1xuICAgIG1lc3NhZ2UgPSB0aGlzLnN0cm0ubXNnO1xuICB9XG4gIHRoaXMub25lcnJvcihtZXNzYWdlLCB0aGlzLmVyclxuXG4gIC8vIG5vIGhvcGUgb2YgcmVzY3VlLlxuICApO3RoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSA0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDUsICdpbml0KHdpbmRvd0JpdHMsIGxldmVsLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIFtkaWN0aW9uYXJ5XSknKTtcblxuICBhc3NlcnQod2luZG93Qml0cyA+PSA4ICYmIHdpbmRvd0JpdHMgPD0gMTUsICdpbnZhbGlkIHdpbmRvd0JpdHMnKTtcbiAgYXNzZXJ0KGxldmVsID49IC0xICYmIGxldmVsIDw9IDksICdpbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsJyk7XG5cbiAgYXNzZXJ0KG1lbUxldmVsID49IDEgJiYgbWVtTGV2ZWwgPD0gOSwgJ2ludmFsaWQgbWVtbGV2ZWwnKTtcblxuICBhc3NlcnQoc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9GSUxURVJFRCB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX1JMRSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0ZJWEVEIHx8IHN0cmF0ZWd5ID09PSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSwgJ2ludmFsaWQgc3RyYXRlZ3knKTtcblxuICB0aGlzLl9pbml0KGxldmVsLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpO1xuICB0aGlzLl9zZXREaWN0aW9uYXJ5KCk7XG59O1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignZGVmbGF0ZVBhcmFtcyBOb3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5fc2V0RGljdGlvbmFyeSgpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobGV2ZWwsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubWVtTGV2ZWwgPSBtZW1MZXZlbDtcbiAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuXG4gIHRoaXMuZmx1c2ggPSBleHBvcnRzLlpfTk9fRkxVU0g7XG5cbiAgdGhpcy5lcnIgPSBleHBvcnRzLlpfT0s7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HVU5aSVApIHtcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLlVOWklQKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzID0gLTEgKiB0aGlzLndpbmRvd0JpdHM7XG4gIH1cblxuICB0aGlzLnN0cm0gPSBuZXcgWnN0cmVhbSgpO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCB0aGlzLmxldmVsLCBleHBvcnRzLlpfREVGTEFURUQsIHRoaXMud2luZG93Qml0cywgdGhpcy5tZW1MZXZlbCwgdGhpcy5zdHJhdGVneSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIHRoaXMud2luZG93Qml0cyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgJyArIHRoaXMubW9kZSk7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdJbml0IGVycm9yJyk7XG4gIH1cblxuICB0aGlzLmRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5O1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3NldERpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRpY3Rpb25hcnkgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyID0gZXhwb3J0cy5aX09LO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gc2V0IGRpY3Rpb25hcnknKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVyciA9IGV4cG9ydHMuWl9PSztcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gcmVzZXQgc3RyZWFtJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuWmxpYiA9IFpsaWI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcbnZhciBrTWF4TGVuZ3RoID0gcmVxdWlyZSgnYnVmZmVyJykua01heExlbmd0aDtcbnZhciBrUmFuZ2VFcnJvck1lc3NhZ2UgPSAnQ2Fubm90IGNyZWF0ZSBmaW5hbCBCdWZmZXIuIEl0IHdvdWxkIGJlIGxhcmdlciAnICsgJ3RoYW4gMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9IDE2ICogMTAyNDtcblxuYmluZGluZy5aX01JTl9NRU1MRVZFTCA9IDE7XG5iaW5kaW5nLlpfTUFYX01FTUxFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMID0gODtcblxuYmluZGluZy5aX01JTl9MRVZFTCA9IC0xO1xuYmluZGluZy5aX01BWF9MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9MRVZFTCA9IGJpbmRpbmcuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuXG4vLyBleHBvc2UgYWxsIHRoZSB6bGliIGNvbnN0YW50c1xudmFyIGJrZXlzID0gT2JqZWN0LmtleXMoYmluZGluZyk7XG5mb3IgKHZhciBiayA9IDA7IGJrIDwgYmtleXMubGVuZ3RoOyBiaysrKSB7XG4gIHZhciBia2V5ID0gYmtleXNbYmtdO1xuICBpZiAoYmtleS5tYXRjaCgvXlovKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBia2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogYmluZGluZ1tia2V5XSwgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gdHJhbnNsYXRpb24gdGFibGUgZm9yIHJldHVybiBjb2Rlcy5cbnZhciBjb2RlcyA9IHtcbiAgWl9PSzogYmluZGluZy5aX09LLFxuICBaX1NUUkVBTV9FTkQ6IGJpbmRpbmcuWl9TVFJFQU1fRU5ELFxuICBaX05FRURfRElDVDogYmluZGluZy5aX05FRURfRElDVCxcbiAgWl9FUlJOTzogYmluZGluZy5aX0VSUk5PLFxuICBaX1NUUkVBTV9FUlJPUjogYmluZGluZy5aX1NUUkVBTV9FUlJPUixcbiAgWl9EQVRBX0VSUk9SOiBiaW5kaW5nLlpfREFUQV9FUlJPUixcbiAgWl9NRU1fRVJST1I6IGJpbmRpbmcuWl9NRU1fRVJST1IsXG4gIFpfQlVGX0VSUk9SOiBiaW5kaW5nLlpfQlVGX0VSUk9SLFxuICBaX1ZFUlNJT05fRVJST1I6IGJpbmRpbmcuWl9WRVJTSU9OX0VSUk9SXG59O1xuXG52YXIgY2tleXMgPSBPYmplY3Qua2V5cyhjb2Rlcyk7XG5mb3IgKHZhciBjayA9IDA7IGNrIDwgY2tleXMubGVuZ3RoOyBjaysrKSB7XG4gIHZhciBja2V5ID0gY2tleXNbY2tdO1xuICBjb2Rlc1tjb2Rlc1tja2V5XV0gPSBja2V5O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NvZGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogT2JqZWN0LmZyZWV6ZShjb2RlcyksIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhdztcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXc7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgR3ppcChvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3VuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBHdW56aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVVuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZHMuXG4vLyBjb21wcmVzcy9kZWNvbXByZXNzIGEgc3RyaW5nIG9yIGJ1ZmZlciBpbiBvbmUgc3RlcC5cbmV4cG9ydHMuZGVmbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3ppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd6aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXcgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMudW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLnVuemlwU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5ndW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZjtcbiAgICB2YXIgZXJyID0gbnVsbDtcblxuICAgIGlmIChucmVhZCA+PSBrTWF4TGVuZ3RoKSB7XG4gICAgICBlcnIgPSBuZXcgUmFuZ2VFcnJvcihrUmFuZ2VFcnJvck1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB9XG5cbiAgICBidWZmZXJzID0gW107XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gICAgY2FsbGJhY2soZXJyLCBidWYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGVuZ2luZS5fZmluaXNoRmx1c2hGbGFnO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlUmF3KSkgcmV0dXJuIG5ldyBEZWZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFUkFXKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlUmF3KSkgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFUkFXKTtcbn1cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGbHVzaEZsYWcoZmxhZykge1xuICByZXR1cm4gZmxhZyA9PT0gYmluZGluZy5aX05PX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GSU5JU0ggfHwgZmxhZyA9PT0gYmluZGluZy5aX0JMT0NLO1xufVxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuXG5mdW5jdGlvbiBabGliKG9wdHMsIG1vZGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoICYmICFpc1ZhbGlkRmx1c2hGbGFnKG9wdHMuZmx1c2gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgfVxuICBpZiAob3B0cy5maW5pc2hGbHVzaCAmJiAhaXNWYWxpZEZsdXNoRmxhZyhvcHRzLmZpbmlzaEZsdXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCBmbGFnOiAnICsgb3B0cy5maW5pc2hGbHVzaCk7XG4gIH1cblxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgdGhpcy5fZmluaXNoRmx1c2hGbGFnID0gdHlwZW9mIG9wdHMuZmluaXNoRmx1c2ggIT09ICd1bmRlZmluZWQnID8gb3B0cy5maW5pc2hGbHVzaCA6IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fCBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8IG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8IG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fCBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiYgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2hhbmRsZSA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9oYW5kbGUub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIF9jbG9zZShzZWxmKTtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5faGFuZGxlLmluaXQob3B0cy53aW5kb3dCaXRzIHx8IGV4cG9ydHMuWl9ERUZBVUxUX1dJTkRPV0JJVFMsIGxldmVsLCBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLCBzdHJhdGVneSwgb3B0cy5kaWN0aW9uYXJ5KTtcblxuICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIHRoaXMuY2xvc2UpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2Nsb3NlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhX3RoaXMuX2hhbmRsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFpsaWIsIFRyYW5zZm9ybSk7XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uIChsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHwgbGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBsZXZlbCk7XG4gIH1cbiAgaWYgKHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJiBzdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiYgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIHN0cmF0ZWd5KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9sZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5fc3RyYXRlZ3kgIT09IHN0cmF0ZWd5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmx1c2goYmluZGluZy5aX1NZTkNfRkxVU0gsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFzc2VydChzZWxmLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICBzZWxmLl9oYW5kbGUucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGYuX2hhZEVycm9yKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gIHJldHVybiB0aGlzLl9oYW5kbGUucmVzZXQoKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIF9mbHVzaCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRyYW5zZm9ybSBjbGFzcyxcbi8vIGludGVybmFsbHksIHdoZW4gdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gd3JpdHRlbi5cblpsaWIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0oQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xufTtcblxuWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwga2luZCA9PT0gdW5kZWZpbmVkICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0ga2luZDtcbiAgICBraW5kID0gYmluZGluZy5aX0ZVTExfRkxVU0g7XG4gIH1cblxuICBpZiAod3MuZW5kZWQpIHtcbiAgICBpZiAoY2FsbGJhY2spIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5vbmNlKCdlbmQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MubmVlZERyYWluKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZsdXNoKGtpbmQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUoQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfY2xvc2UodGhpcywgY2FsbGJhY2spO1xuICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIF9jbG9zZShlbmdpbmUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgLy8gQ2FsbGVyIG1heSBpbnZva2UgLmNsb3NlIGFmdGVyIGEgemxpYiBlcnJvciAod2hpY2ggd2lsbCBudWxsIF9oYW5kbGUpLlxuICBpZiAoIWVuZ2luZS5faGFuZGxlKSByZXR1cm47XG5cbiAgZW5naW5lLl9oYW5kbGUuY2xvc2UoKTtcbiAgZW5naW5lLl9oYW5kbGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuWmxpYi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBmbHVzaEZsYWc7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBlbmRpbmcgPSB3cy5lbmRpbmcgfHwgd3MuZW5kZWQ7XG4gIHZhciBsYXN0ID0gZW5kaW5nICYmICghY2h1bmsgfHwgd3MubGVuZ3RoID09PSBjaHVuay5sZW5ndGgpO1xuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgcmV0dXJuIGNiKG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCcpKTtcblxuICBpZiAoIXRoaXMuX2hhbmRsZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignemxpYiBiaW5kaW5nIGNsb3NlZCcpKTtcblxuICAvLyBJZiBpdCdzIHRoZSBsYXN0IGNodW5rLCBvciBhIGZpbmFsIGZsdXNoLCB3ZSB1c2UgdGhlIFpfRklOSVNIIGZsdXNoIGZsYWdcbiAgLy8gKG9yIHdoYXRldmVyIGZsYWcgd2FzIHByb3ZpZGVkIHVzaW5nIG9wdHMuZmluaXNoRmx1c2gpLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KSBmbHVzaEZsYWcgPSB0aGlzLl9maW5pc2hGbHVzaEZsYWc7ZWxzZSB7XG4gICAgZmx1c2hGbGFnID0gdGhpcy5fZmx1c2hGbGFnO1xuICAgIC8vIG9uY2Ugd2UndmUgZmx1c2hlZCB0aGUgbGFzdCBvZiB0aGUgcXVldWUsIHN0b3AgZmx1c2hpbmcgYW5kXG4gICAgLy8gZ28gYmFjayB0byB0aGUgbm9ybWFsIGJlaGF2aW9yLlxuICAgIGlmIChjaHVuay5sZW5ndGggPj0gd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9mbHVzaEZsYWcgPSB0aGlzLl9vcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaywgZmx1c2hGbGFnLCBjYikge1xuICB2YXIgYXZhaWxJbkJlZm9yZSA9IGNodW5rICYmIGNodW5rLmxlbmd0aDtcbiAgdmFyIGF2YWlsT3V0QmVmb3JlID0gdGhpcy5fY2h1bmtTaXplIC0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYXN5bmMgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIG5yZWFkID0gMDtcblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcikge1xuICAgICAgZXJyb3IgPSBlcjtcbiAgICB9KTtcblxuICAgIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgZG8ge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX2hhbmRsZS53cml0ZVN5bmMoZmx1c2hGbGFnLCBjaHVuaywgLy8gaW5cbiAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cbiAgICB9IHdoaWxlICghdGhpcy5faGFkRXJyb3IgJiYgY2FsbGJhY2socmVzWzBdLCByZXNbMV0pKTtcblxuICAgIGlmICh0aGlzLl9oYWRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG5yZWFkID49IGtNYXhMZW5ndGgpIHtcbiAgICAgIF9jbG9zZSh0aGlzKTtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGtSYW5nZUVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIF9jbG9zZSh0aGlzKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICB2YXIgcmVxID0gdGhpcy5faGFuZGxlLndyaXRlKGZsdXNoRmxhZywgY2h1bmssIC8vIGluXG4gIGluT2ZmLCAvLyBpbl9vZmZcbiAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuXG4gIHJlcS5idWZmZXIgPSBjaHVuaztcbiAgcmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soYXZhaWxJbkFmdGVyLCBhdmFpbE91dEFmdGVyKSB7XG4gICAgLy8gV2hlbiB0aGUgY2FsbGJhY2sgaXMgdXNlZCBpbiBhbiBhc3luYyB3cml0ZSwgdGhlIGNhbGxiYWNrJ3NcbiAgICAvLyBjb250ZXh0IGlzIHRoZSBgcmVxYCBvYmplY3QgdGhhdCB3YXMgY3JlYXRlZC4gVGhlIHJlcSBvYmplY3RcbiAgICAvLyBpcyA9PT0gdGhpcy5faGFuZGxlLCBhbmQgdGhhdCdzIHdoeSBpdCdzIGltcG9ydGFudCB0byBudWxsXG4gICAgLy8gb3V0IHRoZSB2YWx1ZXMgYWZ0ZXIgdGhleSBhcmUgZG9uZSBiZWluZyB1c2VkLiBgdGhpcy5faGFuZGxlYFxuICAgIC8vIGNhbiBzdGF5IGluIG1lbW9yeSBsb25nZXIgdGhhbiB0aGUgY2FsbGJhY2sgYW5kIGJ1ZmZlciBhcmUgbmVlZGVkLlxuICAgIGlmICh0aGlzKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpIHJldHVybjtcblxuICAgIHZhciBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuICAgIGFzc2VydChoYXZlID49IDAsICdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuXG4gICAgaWYgKGhhdmUgPiAwKSB7XG4gICAgICB2YXIgb3V0ID0gc2VsZi5fYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldCwgc2VsZi5fb2Zmc2V0ICsgaGF2ZSk7XG4gICAgICBzZWxmLl9vZmZzZXQgKz0gaGF2ZTtcbiAgICAgIC8vIHNlcnZlIHNvbWUgb3V0cHV0IHRvIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBzZWxmLnB1c2gob3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgICBucmVhZCArPSBvdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aGF1c3RlZCB0aGUgb3V0cHV0IGJ1ZmZlciwgb3IgdXNlZCBhbGwgdGhlIGlucHV0IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2NodW5rU2l6ZSkge1xuICAgICAgYXZhaWxPdXRCZWZvcmUgPSBzZWxmLl9jaHVua1NpemU7XG4gICAgICBzZWxmLl9vZmZzZXQgPSAwO1xuICAgICAgc2VsZi5fYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDApIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiAgTmVlZCB0byByZXByb2Nlc3MuXG4gICAgICAvLyBBbHNvLCB1cGRhdGUgdGhlIGF2YWlsSW5CZWZvcmUgdG8gdGhlIGF2YWlsSW5BZnRlciB2YWx1ZSxcbiAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgLy8gaXQnbGwgaGF2ZSB0aGUgY29ycmVjdCBieXRlIGNvdW50cy5cbiAgICAgIGluT2ZmICs9IGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXI7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICBpZiAoIWFzeW5jKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIG5ld1JlcSA9IHNlbGYuX2hhbmRsZS53cml0ZShmbHVzaEZsYWcsIGNodW5rLCBpbk9mZiwgYXZhaWxJbkJlZm9yZSwgc2VsZi5fYnVmZmVyLCBzZWxmLl9vZmZzZXQsIHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgICBuZXdSZXEuY2FsbGJhY2sgPSBjYWxsYmFjazsgLy8gdGhpcyBzYW1lIGZ1bmN0aW9uXG4gICAgICBuZXdSZXEuYnVmZmVyID0gY2h1bms7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhc3luYykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTsiLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgQ1JDX1RBQkxFID0gW1xuICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweGVlMGU2MTJjLCAweDk5MDk1MWJhLCAweDA3NmRjNDE5LFxuICAweDcwNmFmNDhmLCAweGU5NjNhNTM1LCAweDllNjQ5NWEzLCAweDBlZGI4ODMyLCAweDc5ZGNiOGE0LFxuICAweGUwZDVlOTFlLCAweDk3ZDJkOTg4LCAweDA5YjY0YzJiLCAweDdlYjE3Y2JkLCAweGU3YjgyZDA3LFxuICAweDkwYmYxZDkxLCAweDFkYjcxMDY0LCAweDZhYjAyMGYyLCAweGYzYjk3MTQ4LCAweDg0YmU0MWRlLFxuICAweDFhZGFkNDdkLCAweDZkZGRlNGViLCAweGY0ZDRiNTUxLCAweDgzZDM4NWM3LCAweDEzNmM5ODU2LFxuICAweDY0NmJhOGMwLCAweGZkNjJmOTdhLCAweDhhNjVjOWVjLCAweDE0MDE1YzRmLCAweDYzMDY2Y2Q5LFxuICAweGZhMGYzZDYzLCAweDhkMDgwZGY1LCAweDNiNmUyMGM4LCAweDRjNjkxMDVlLCAweGQ1NjA0MWU0LFxuICAweGEyNjc3MTcyLCAweDNjMDNlNGQxLCAweDRiMDRkNDQ3LCAweGQyMGQ4NWZkLCAweGE1MGFiNTZiLFxuICAweDM1YjVhOGZhLCAweDQyYjI5ODZjLCAweGRiYmJjOWQ2LCAweGFjYmNmOTQwLCAweDMyZDg2Y2UzLFxuICAweDQ1ZGY1Yzc1LCAweGRjZDYwZGNmLCAweGFiZDEzZDU5LCAweDI2ZDkzMGFjLCAweDUxZGUwMDNhLFxuICAweGM4ZDc1MTgwLCAweGJmZDA2MTE2LCAweDIxYjRmNGI1LCAweDU2YjNjNDIzLCAweGNmYmE5NTk5LFxuICAweGI4YmRhNTBmLCAweDI4MDJiODllLCAweDVmMDU4ODA4LCAweGM2MGNkOWIyLCAweGIxMGJlOTI0LFxuICAweDJmNmY3Yzg3LCAweDU4Njg0YzExLCAweGMxNjExZGFiLCAweGI2NjYyZDNkLCAweDc2ZGM0MTkwLFxuICAweDAxZGI3MTA2LCAweDk4ZDIyMGJjLCAweGVmZDUxMDJhLCAweDcxYjE4NTg5LCAweDA2YjZiNTFmLFxuICAweDlmYmZlNGE1LCAweGU4YjhkNDMzLCAweDc4MDdjOWEyLCAweDBmMDBmOTM0LCAweDk2MDlhODhlLFxuICAweGUxMGU5ODE4LCAweDdmNmEwZGJiLCAweDA4NmQzZDJkLCAweDkxNjQ2Yzk3LCAweGU2NjM1YzAxLFxuICAweDZiNmI1MWY0LCAweDFjNmM2MTYyLCAweDg1NjUzMGQ4LCAweGYyNjIwMDRlLCAweDZjMDY5NWVkLFxuICAweDFiMDFhNTdiLCAweDgyMDhmNGMxLCAweGY1MGZjNDU3LCAweDY1YjBkOWM2LCAweDEyYjdlOTUwLFxuICAweDhiYmViOGVhLCAweGZjYjk4ODdjLCAweDYyZGQxZGRmLCAweDE1ZGEyZDQ5LCAweDhjZDM3Y2YzLFxuICAweGZiZDQ0YzY1LCAweDRkYjI2MTU4LCAweDNhYjU1MWNlLCAweGEzYmMwMDc0LCAweGQ0YmIzMGUyLFxuICAweDRhZGZhNTQxLCAweDNkZDg5NWQ3LCAweGE0ZDFjNDZkLCAweGQzZDZmNGZiLCAweDQzNjllOTZhLFxuICAweDM0NmVkOWZjLCAweGFkNjc4ODQ2LCAweGRhNjBiOGQwLCAweDQ0MDQyZDczLCAweDMzMDMxZGU1LFxuICAweGFhMGE0YzVmLCAweGRkMGQ3Y2M5LCAweDUwMDU3MTNjLCAweDI3MDI0MWFhLCAweGJlMGIxMDEwLFxuICAweGM5MGMyMDg2LCAweDU3NjhiNTI1LCAweDIwNmY4NWIzLCAweGI5NjZkNDA5LCAweGNlNjFlNDlmLFxuICAweDVlZGVmOTBlLCAweDI5ZDljOTk4LCAweGIwZDA5ODIyLCAweGM3ZDdhOGI0LCAweDU5YjMzZDE3LFxuICAweDJlYjQwZDgxLCAweGI3YmQ1YzNiLCAweGMwYmE2Y2FkLCAweGVkYjg4MzIwLCAweDlhYmZiM2I2LFxuICAweDAzYjZlMjBjLCAweDc0YjFkMjlhLCAweGVhZDU0NzM5LCAweDlkZDI3N2FmLCAweDA0ZGIyNjE1LFxuICAweDczZGMxNjgzLCAweGUzNjMwYjEyLCAweDk0NjQzYjg0LCAweDBkNmQ2YTNlLCAweDdhNmE1YWE4LFxuICAweGU0MGVjZjBiLCAweDkzMDlmZjlkLCAweDBhMDBhZTI3LCAweDdkMDc5ZWIxLCAweGYwMGY5MzQ0LFxuICAweDg3MDhhM2QyLCAweDFlMDFmMjY4LCAweDY5MDZjMmZlLCAweGY3NjI1NzVkLCAweDgwNjU2N2NiLFxuICAweDE5NmMzNjcxLCAweDZlNmIwNmU3LCAweGZlZDQxYjc2LCAweDg5ZDMyYmUwLCAweDEwZGE3YTVhLFxuICAweDY3ZGQ0YWNjLCAweGY5YjlkZjZmLCAweDhlYmVlZmY5LCAweDE3YjdiZTQzLCAweDYwYjA4ZWQ1LFxuICAweGQ2ZDZhM2U4LCAweGExZDE5MzdlLCAweDM4ZDhjMmM0LCAweDRmZGZmMjUyLCAweGQxYmI2N2YxLFxuICAweGE2YmM1NzY3LCAweDNmYjUwNmRkLCAweDQ4YjIzNjRiLCAweGQ4MGQyYmRhLCAweGFmMGExYjRjLFxuICAweDM2MDM0YWY2LCAweDQxMDQ3YTYwLCAweGRmNjBlZmMzLCAweGE4NjdkZjU1LCAweDMxNmU4ZWVmLFxuICAweDQ2NjliZTc5LCAweGNiNjFiMzhjLCAweGJjNjY4MzFhLCAweDI1NmZkMmEwLCAweDUyNjhlMjM2LFxuICAweGNjMGM3Nzk1LCAweGJiMGI0NzAzLCAweDIyMDIxNmI5LCAweDU1MDUyNjJmLCAweGM1YmEzYmJlLFxuICAweGIyYmQwYjI4LCAweDJiYjQ1YTkyLCAweDVjYjM2YTA0LCAweGMyZDdmZmE3LCAweGI1ZDBjZjMxLFxuICAweDJjZDk5ZThiLCAweDViZGVhZTFkLCAweDliNjRjMmIwLCAweGVjNjNmMjI2LCAweDc1NmFhMzljLFxuICAweDAyNmQ5MzBhLCAweDljMDkwNmE5LCAweGViMGUzNjNmLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAweDk1YmY0YTgyLCAweGUyYjg3YTE0LCAweDdiYjEyYmFlLCAweDBjYjYxYjM4LCAweDkyZDI4ZTliLFxuICAweGU1ZDViZTBkLCAweDdjZGNlZmI3LCAweDBiZGJkZjIxLCAweDg2ZDNkMmQ0LCAweGYxZDRlMjQyLFxuICAweDY4ZGRiM2Y4LCAweDFmZGE4MzZlLCAweDgxYmUxNmNkLCAweGY2YjkyNjViLCAweDZmYjA3N2UxLFxuICAweDE4Yjc0Nzc3LCAweDg4MDg1YWU2LCAweGZmMGY2YTcwLCAweDY2MDYzYmNhLCAweDExMDEwYjVjLFxuICAweDhmNjU5ZWZmLCAweGY4NjJhZTY5LCAweDYxNmJmZmQzLCAweDE2NmNjZjQ1LCAweGEwMGFlMjc4LFxuICAweGQ3MGRkMmVlLCAweDRlMDQ4MzU0LCAweDM5MDNiM2MyLCAweGE3NjcyNjYxLCAweGQwNjAxNmY3LFxuICAweDQ5Njk0NzRkLCAweDNlNmU3N2RiLCAweGFlZDE2YTRhLCAweGQ5ZDY1YWRjLCAweDQwZGYwYjY2LFxuICAweDM3ZDgzYmYwLCAweGE5YmNhZTUzLCAweGRlYmI5ZWM1LCAweDQ3YjJjZjdmLCAweDMwYjVmZmU5LFxuICAweGJkYmRmMjFjLCAweGNhYmFjMjhhLCAweDUzYjM5MzMwLCAweDI0YjRhM2E2LCAweGJhZDAzNjA1LFxuICAweGNkZDcwNjkzLCAweDU0ZGU1NzI5LCAweDIzZDk2N2JmLCAweGIzNjY3YTJlLCAweGM0NjE0YWI4LFxuICAweDVkNjgxYjAyLCAweDJhNmYyYjk0LCAweGI0MGJiZTM3LCAweGMzMGM4ZWExLCAweDVhMDVkZjFiLFxuICAweDJkMDJlZjhkXG5dO1xuXG5pZiAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gIENSQ19UQUJMRSA9IG5ldyBJbnQzMkFycmF5KENSQ19UQUJMRSk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUJ1ZmZlcihpbnB1dCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIHZhciBoYXNOZXdCdWZmZXJBUEkgPVxuICAgICAgdHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICB0eXBlb2YgQnVmZmVyLmZyb20gPT09IFwiZnVuY3Rpb25cIjtcblxuICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGhhc05ld0J1ZmZlckFQSSA/IEJ1ZmZlci5hbGxvYyhpbnB1dCkgOiBuZXcgQnVmZmVyKGlucHV0KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gaGFzTmV3QnVmZmVyQVBJID8gQnVmZmVyLmZyb20oaW5wdXQpIDogbmV3IEJ1ZmZlcihpbnB1dCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbXVzdCBiZSBidWZmZXIsIG51bWJlciwgb3Igc3RyaW5nLCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnB1dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVmZmVyaXplSW50KG51bSkge1xuICB2YXIgdG1wID0gZW5zdXJlQnVmZmVyKDQpO1xuICB0bXAud3JpdGVJbnQzMkJFKG51bSwgMCk7XG4gIHJldHVybiB0bXA7XG59XG5cbmZ1bmN0aW9uIF9jcmMzMihidWYsIHByZXZpb3VzKSB7XG4gIGJ1ZiA9IGVuc3VyZUJ1ZmZlcihidWYpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHByZXZpb3VzKSkge1xuICAgIHByZXZpb3VzID0gcHJldmlvdXMucmVhZFVJbnQzMkJFKDApO1xuICB9XG4gIHZhciBjcmMgPSB+fnByZXZpb3VzIF4gLTE7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgYnVmLmxlbmd0aDsgbisrKSB7XG4gICAgY3JjID0gQ1JDX1RBQkxFWyhjcmMgXiBidWZbbl0pICYgMHhmZl0gXiAoY3JjID4+PiA4KTtcbiAgfVxuICByZXR1cm4gKGNyYyBeIC0xKTtcbn1cblxuZnVuY3Rpb24gY3JjMzIoKSB7XG4gIHJldHVybiBidWZmZXJpemVJbnQoX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xufVxuY3JjMzIuc2lnbmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuY3JjMzIudW5zaWduZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKSA+Pj4gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChlcnJvckxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgLy8gQWRkaW5nIGFuIGVycm9yIGxpc3RlbmVyIGlzIG5vdCBvcHRpb25hbCBiZWNhdXNlXG4gICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIG9uIGFuIGV2ZW50IGVtaXR0ZXIgd2UgY2Fubm90XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGFjdHVhbCBldmVudCB3ZSBhcmUgd2FpdGluZyB3aWxsXG4gICAgLy8gYmUgZmlyZWQuIFRoZSByZXN1bHQgY291bGQgYmUgYSBzaWxlbnQgd2F5IHRvIGNyZWF0ZVxuICAgIC8vIG1lbW9yeSBvciBmaWxlIGRlc2NyaXB0b3IgbGVha3MsIHdoaWNoIGlzIHNvbWV0aGluZ1xuICAgIC8vIHdlIHNob3VsZCBhdm9pZC5cbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgbm93ID0gcmVxdWlyZSgnLi9ub3cnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG52YXIgQmxvYlNsaWNlciA9IHJlcXVpcmUoJ2Jsb2Itc2xpY2VyJylcclxudmFyIFppcEZpbGUgPSByZXF1aXJlKCcuL3ppcC1maWxlJylcclxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuemlwIChzb3VyY2UsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcclxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIGNyZWF0ZVppcEZpbGUodGhpcy5yZXNwb25zZSwgY2FsbGJhY2spXHJcbiAgICAgICAgZWxzZSBjYWxsYmFjayhVdGlscy5FKCduZXR3b3JrIGVycm9yOiB7MH0gezF9JywgdGhpcy5zdGF0dXMsIHRoaXMuc3RhdHVzVGV4dCkpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICB0cnkge1xyXG4gICAgICB4aHIub3BlbignR0VUJywgc291cmNlKVxyXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXHJcbiAgICAgIHhoci5zZW5kKClcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjYWxsYmFjayhlcnIpXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNyZWF0ZVppcEZpbGUoc291cmNlLCBjYWxsYmFjaylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVppcEZpbGUgKHNvdXJjZSwgY2FsbGJhY2spIHtcclxuICB0cnkge1xyXG4gICAgdmFyIHJlYWRlciA9IG5ldyBCbG9iU2xpY2VyKHNvdXJjZSlcclxuICAgIFV0aWxzLnJlYWRFT0NEUmVjb3JkKHJlYWRlciwgZnVuY3Rpb24gKGVyciwgZW9jZHIpIHtcclxuICAgICAgY2FsbGJhY2soZXJyLCBlcnIgPyBudWxsIDogbmV3IFppcEZpbGUocmVhZGVyLCBlb2NkcikpXHJcbiAgICB9KVxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY2FsbGJhY2soZXJyKVxyXG4gIH1cclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbmV4cG9ydHMucmVhZEVPQ0RSZWNvcmQgPSByZWFkRU9DRFJlY29yZFxyXG5leHBvcnRzLnJlYWRVSW50NjRMRSA9IHJlYWRVSW50NjRMRVxyXG5leHBvcnRzLkUgPSBFXHJcbmV4cG9ydHMuY3A0MzdUb1VuaWNvZGUgPSBjcDQzN1RvVW5pY29kZVxyXG5cclxuZnVuY3Rpb24gcmVhZEVPQ0RSZWNvcmQgKHJlYWRlciwgY2FsbGJhY2spIHtcclxuICB2YXIgZml4ZWRGaWVsZHNTaXplID0gMjJcclxuICB2YXIgbWF4UmVjb3JkU2l6ZSA9IGZpeGVkRmllbGRzU2l6ZSArIDB4ZmZmZlxyXG5cclxuICByZWFkZXIucmVhZCgtbWF4UmVjb3JkU2l6ZSwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XHJcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxyXG5cclxuICAgIGlmIChidWYubGVuZ3RoIDwgZml4ZWRGaWVsZHNTaXplKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhcclxuICAgICAgICBFKCdleHBlY3RlZCBhdCBsZWFzdCAyMiBieXRlcyBmb3IgRW5kIE9mIENlbnRyYWwgRGlyZWN0b3J5IGdvdCB7MH0nLCBidWYubGVuZ3RoKVxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVvY2RyID0ge31cclxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmUgICAgNCBieXRlcyAgKDB4MDYwNTRiNTApXHJcbiAgICB2YXIgb2Zmc2V0ID0gYnVmLmxhc3RJbmRleE9mKCdQS1xceDA1XFx4MDYnKVxyXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHJldHVybiBjYWxsYmFjayhFKCdFbmQgT2YgQ2VudHJhbCBEaXJlY3Rvcnkgbm90IGZvdW5kJykpXHJcbiAgICB2YXIgcmVjb3JkQnVmZmVyID0gYnVmLnNsaWNlKG9mZnNldClcclxuICAgIC8vIG51bWJlciBvZiB0aGlzIGRpc2sgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgaWYgKHJlY29yZEJ1ZmZlci5yZWFkVUludDE2TEUoNCkgIT09IDApIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEUoJ3NwYW5uZWQgemlwIGZpbGVzIGFyZSBub3Qgc3VwcG9ydGVkJykpXHJcbiAgICB9XHJcbiAgICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGVcclxuICAgIC8vIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAgMiBieXRlc1xyXG4gICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlXHJcbiAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2sgIDIgYnl0ZXNcclxuICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluXHJcbiAgICAvLyB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICAgICAgICAgIDIgYnl0ZXNcclxuICAgIGVvY2RyLmVudHJ5Q291bnQgPSByZWNvcmRCdWZmZXIucmVhZFVJbnQxNkxFKDEwKVxyXG4gICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXHJcbiAgICBlb2Nkci5jZFNpemUgPSByZWNvcmRCdWZmZXIucmVhZFVJbnQzMkxFKDEyKVxyXG4gICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWxcclxuICAgIC8vIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG9cclxuICAgIC8vIHRoZSBzdGFydGluZyBkaXNrIG51bWJlciAgICAgICAgNCBieXRlc1xyXG4gICAgZW9jZHIuY2RPZmZzZXQgPSByZWNvcmRCdWZmZXIucmVhZFVJbnQzMkxFKDE2KVxyXG4gICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoICAgICAgICAyIGJ5dGVzXHJcbiAgICB2YXIgY29tbWVudExlbmd0aCA9IHJlY29yZEJ1ZmZlci5yZWFkVUludDE2TEUoMjApXHJcbiAgICAvLyAuWklQIGZpbGUgY29tbWVudCAgICAgICAodmFyaWFibGUgc2l6ZSlcclxuICAgIGVvY2RyLmNvbW1lbnQgPSByZWNvcmRCdWZmZXIudG9TdHJpbmcoJ3V0Zi04JywgMjIsIDIyICsgY29tbWVudExlbmd0aClcclxuICAgIGNvbnNvbGUuYXNzZXJ0KFxyXG4gICAgICBlb2Nkci5jb21tZW50Lmxlbmd0aCA9PT0gY29tbWVudExlbmd0aCxcclxuICAgICAgJ2V4cGVjdGVkICcgKyBjb21tZW50TGVuZ3RoICsgJyBieXRlcyBmb3IgemlwIGZpbGUgY29tbWVudCBnb3QgJyArIGVvY2RyLmNvbW1lbnQubGVuZ3RoXHJcbiAgICApXHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBlb2Nkci5lbnRyeUNvdW50ID09PSAweGZmZmYgfHxcclxuICAgICAgZW9jZHIuY2RTaXplID09PSAweGZmZmZmZmZmIHx8XHJcbiAgICAgIGVvY2RyLmNkT2Zmc2V0ID09PSAweGZmZmZmZmZmXHJcbiAgICApIHtcclxuICAgICAgcmVhZEVPQ0Q2NFJlY29yZChyZWFkZXIsIG9mZnNldCwgZnVuY3Rpb24gKGVyciwgZW9jZDY0cikge1xyXG4gICAgICAgIGlmIChlb2NkNjRyKSBlb2NkNjRyLmNvbW1lbnQgPSBlb2Nkci5jb21tZW50XHJcbiAgICAgICAgY2FsbGJhY2soZXJyLCBlb2NkNjRyKVxyXG4gICAgICB9KVxyXG4gICAgfSBlbHNlIGNhbGxiYWNrKG51bGwsIGVvY2RyKVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRFT0NENjRSZWNvcmQgKHJlYWRlciwgZW9jZE9mZnNldCwgY2FsbGJhY2spIHtcclxuICB2YXIgZml4ZWRGaWVsZHNTaXplID0gNTZcclxuXHJcbiAgcmVhZEVPQ0RMb2NhdG9yKHJlYWRlciwgZW9jZE9mZnNldCwgZnVuY3Rpb24gKGVyciwgZW9jZDY0T2Zmc2V0KSB7XHJcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxyXG5cclxuICAgIHJlYWRlci5yZWFkKGVvY2Q2NE9mZnNldCwgZW9jZDY0T2Zmc2V0ICsgZml4ZWRGaWVsZHNTaXplLCBmdW5jdGlvbiAoZXJyLCBidWYpIHtcclxuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcclxuXHJcbiAgICAgIGlmIChidWYubGVuZ3RoIDwgZml4ZWRGaWVsZHNTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxyXG4gICAgICAgICAgRSgnZXhwZWN0ZWQgYXQgbGVhc3QgNTYgYnl0ZXMgZm9yIFppcDY0IEVuZCBPZiBDZW50cmFsIERpcmVjdG9yeSBnb3QgezB9JywgYnVmLmxlbmd0aClcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlb2NkNjRyID0ge31cclxuICAgICAgLy8gemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyXHJcbiAgICAgIC8vIHNpZ25hdHVyZSAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlcyAgKDB4MDYwNjRiNTApXHJcbiAgICAgIGlmIChidWYucmVhZFVJbnQzMkxFKDApICE9PSAweDA2MDY0YjUwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEUoJ1ppcDY0IEVuZCBPZiBDZW50cmFsIERpcmVjdG9yeSBub3QgZm91bmQnKSlcclxuICAgICAgfVxyXG4gICAgICAvLyBzaXplIG9mIHppcDY0IGVuZCBvZiBjZW50cmFsXHJcbiAgICAgIC8vIGRpcmVjdG9yeSByZWNvcmQgICAgICAgICAgICAgICAgOCBieXRlc1xyXG4gICAgICAvLyB2ZXJzaW9uIG1hZGUgYnkgICAgICAgICAgICAgICAgIDIgYnl0ZXNcclxuICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdCAgICAgICAyIGJ5dGVzXHJcbiAgICAgIC8vIG51bWJlciBvZiB0aGlzIGRpc2sgICAgICAgICAgICAgNCBieXRlc1xyXG4gICAgICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGVcclxuICAgICAgLy8gc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICA0IGJ5dGVzXHJcbiAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZVxyXG4gICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2sgIDggYnl0ZXNcclxuICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlXHJcbiAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5ICAgICAgICAgICAgICAgOCBieXRlc1xyXG4gICAgICBlb2NkNjRyLmVudHJ5Q291bnQgPSByZWFkVUludDY0TEUoYnVmLCAzMilcclxuICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA4IGJ5dGVzXHJcbiAgICAgIGVvY2Q2NHIuY2RTaXplID0gcmVhZFVJbnQ2NExFKGJ1ZiwgNDApXHJcbiAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsXHJcbiAgICAgIC8vIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG9cclxuICAgICAgLy8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyICAgICAgICA4IGJ5dGVzXHJcbiAgICAgIGVvY2Q2NHIuY2RPZmZzZXQgPSByZWFkVUludDY0TEUoYnVmLCA0OClcclxuICAgICAgLy8gemlwNjQgZXh0ZW5zaWJsZSBkYXRhIHNlY3RvciAgICAodmFyaWFibGUgc2l6ZSlcclxuXHJcbiAgICAgIGNhbGxiYWNrKG51bGwsIGVvY2Q2NHIpXHJcbiAgICB9KVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRFT0NETG9jYXRvciAocmVhZGVyLCBlb2NkT2Zmc2V0LCBjYWxsYmFjaykge1xyXG4gIHZhciBsb2NhdG9yUmVjb3JkU2l6ZSA9IDIwXHJcblxyXG4gIHJlYWRlci5yZWFkKGVvY2RPZmZzZXQgLSBsb2NhdG9yUmVjb3JkU2l6ZSwgZW9jZE9mZnNldCwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XHJcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxyXG5cclxuICAgIGlmIChidWYubGVuZ3RoIDwgbG9jYXRvclJlY29yZFNpemUpIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKFxyXG4gICAgICAgIEUoXHJcbiAgICAgICAgICAnZXhwZWN0ZWQgYXQgbGVhc3QgMjAgYnl0ZXMgZm9yIFppcDY0IEVuZCBPZiBDZW50cmFsIERpcmVjdG9yeSBMb2NhdG9yIGdvdCB7MH0nLFxyXG4gICAgICAgICAgYnVmLmxlbmd0aFxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpciBsb2NhdG9yXHJcbiAgICAvLyBzaWduYXR1cmUgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXMgICgweDA3MDY0YjUwKVxyXG4gICAgaWYgKGJ1Zi5yZWFkVUludDMyTEUoMCkgIT09IDB4MDcwNjRiNTApIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEUoJ1ppcDY0IEVuZCBPZiBDZW50cmFsIERpcmVjdG9yeSBMb2NhdG9yIG5vdCBmb3VuZCcpKVxyXG4gICAgfVxyXG4gICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlXHJcbiAgICAvLyBzdGFydCBvZiB0aGUgemlwNjQgZW5kIG9mXHJcbiAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSAgICAgICAgICAgICAgIDQgYnl0ZXNcclxuICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgemlwNjRcclxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgOCBieXRlc1xyXG4gICAgdmFyIGVvY2Q2NE9mZnNldCA9IHJlYWRVSW50NjRMRShidWYsIDgpXHJcbiAgICAvLyB0b3RhbCBudW1iZXIgb2YgZGlza3MgICAgICAgICAgIDQgYnl0ZXNcclxuICAgIGlmIChidWYucmVhZFVJbnQzMkxFKDE2KSAhPT0gMSkge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soRSgnc3Bhbm5lZCB6aXAgZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSlcclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhudWxsLCBlb2NkNjRPZmZzZXQpXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFIChidWZmZXIsIG9mZnNldCkge1xyXG4gIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCkgKyAoYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KSAqIDB4MTAwMDAwMDAwKVxyXG59XHJcblxyXG5mdW5jdGlvbiBFIChtZXNzYWdlKSB7XHJcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcclxuICByZXR1cm4gbmV3IEVycm9yKFxyXG4gICAgbWVzc2FnZS5yZXBsYWNlKC97KFxcZCspfS9nLCBmdW5jdGlvbiAobWF0Y2gsIHApIHtcclxuICAgICAgdmFyIHIgPSBhcmdzWytwICsgMV1cclxuICAgICAgcmV0dXJuIHIgPT09IHVuZGVmaW5lZCA/IG1hdGNoIDogclxyXG4gICAgfSlcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNwNDM3VG9Vbmljb2RlIChidWZmZXIpIHtcclxuICB2YXIgdGFibGUgPSBbXHJcbiAgICAweDAwMDAsIDB4MjYzQSwgMHgyNjNCLCAweDI2NjUsIDB4MjY2NiwgMHgyNjYzLCAweDI2NjAsIDB4MjAyMiwgMHgyNUQ4LCAweDI1Q0IsIDB4MjVEOSxcclxuICAgIDB4MjY0MiwgMHgyNjQwLCAweDI2NkEsIDB4MjY2QiwgMHgyNjNDLCAweDI1QkEsIDB4MjVDNCwgMHgyMTk1LCAweDIwM0MsIDB4MDBCNiwgMHgwMEE3LFxyXG4gICAgMHgyNUFDLCAweDIxQTgsIDB4MjE5MSwgMHgyMTkzLCAweDIxOTIsIDB4MjE5MCwgMHgyMjFGLCAweDIxOTQsIDB4MjVCMiwgMHgyNUJDLCAweDAwMjAsXHJcbiAgICAweDAwMjEsIDB4MDAyMiwgMHgwMDIzLCAweDAwMjQsIDB4MDAyNSwgMHgwMDI2LCAweDAwMjcsIDB4MDAyOCwgMHgwMDI5LCAweDAwMkEsIDB4MDAyQixcclxuICAgIDB4MDAyQywgMHgwMDJELCAweDAwMkUsIDB4MDAyRiwgMHgwMDMwLCAweDAwMzEsIDB4MDAzMiwgMHgwMDMzLCAweDAwMzQsIDB4MDAzNSwgMHgwMDM2LFxyXG4gICAgMHgwMDM3LCAweDAwMzgsIDB4MDAzOSwgMHgwMDNBLCAweDAwM0IsIDB4MDAzQywgMHgwMDNELCAweDAwM0UsIDB4MDAzRiwgMHgwMDQwLCAweDAwNDEsXHJcbiAgICAweDAwNDIsIDB4MDA0MywgMHgwMDQ0LCAweDAwNDUsIDB4MDA0NiwgMHgwMDQ3LCAweDAwNDgsIDB4MDA0OSwgMHgwMDRBLCAweDAwNEIsIDB4MDA0QyxcclxuICAgIDB4MDA0RCwgMHgwMDRFLCAweDAwNEYsIDB4MDA1MCwgMHgwMDUxLCAweDAwNTIsIDB4MDA1MywgMHgwMDU0LCAweDAwNTUsIDB4MDA1NiwgMHgwMDU3LFxyXG4gICAgMHgwMDU4LCAweDAwNTksIDB4MDA1QSwgMHgwMDVCLCAweDAwNUMsIDB4MDA1RCwgMHgwMDVFLCAweDAwNUYsIDB4MDA2MCwgMHgwMDYxLCAweDAwNjIsXHJcbiAgICAweDAwNjMsIDB4MDA2NCwgMHgwMDY1LCAweDAwNjYsIDB4MDA2NywgMHgwMDY4LCAweDAwNjksIDB4MDA2QSwgMHgwMDZCLCAweDAwNkMsIDB4MDA2RCxcclxuICAgIDB4MDA2RSwgMHgwMDZGLCAweDAwNzAsIDB4MDA3MSwgMHgwMDcyLCAweDAwNzMsIDB4MDA3NCwgMHgwMDc1LCAweDAwNzYsIDB4MDA3NywgMHgwMDc4LFxyXG4gICAgMHgwMDc5LCAweDAwN0EsIDB4MDA3QiwgMHgwMDdDLCAweDAwN0QsIDB4MDA3RSwgMHgyMzAyLCAweDAwQzcsIDB4MDBGQywgMHgwMEU5LCAweDAwRTIsXHJcbiAgICAweDAwRTQsIDB4MDBFMCwgMHgwMEU1LCAweDAwRTcsIDB4MDBFQSwgMHgwMEVCLCAweDAwRTgsIDB4MDBFRiwgMHgwMEVFLCAweDAwRUMsIDB4MDBDNCxcclxuICAgIDB4MDBDNSwgMHgwMEM5LCAweDAwRTYsIDB4MDBDNiwgMHgwMEY0LCAweDAwRjYsIDB4MDBGMiwgMHgwMEZCLCAweDAwRjksIDB4MDBGRiwgMHgwMEQ2LFxyXG4gICAgMHgwMERDLCAweDAwQTIsIDB4MDBBMywgMHgwMEE1LCAweDIwQTcsIDB4MDE5MiwgMHgwMEUxLCAweDAwRUQsIDB4MDBGMywgMHgwMEZBLCAweDAwRjEsXHJcbiAgICAweDAwRDEsIDB4MDBBQSwgMHgwMEJBLCAweDAwQkYsIDB4MjMxMCwgMHgwMEFDLCAweDAwQkQsIDB4MDBCQywgMHgwMEExLCAweDAwQUIsIDB4MDBCQixcclxuICAgIDB4MjU5MSwgMHgyNTkyLCAweDI1OTMsIDB4MjUwMiwgMHgyNTI0LCAweDI1NjEsIDB4MjU2MiwgMHgyNTU2LCAweDI1NTUsIDB4MjU2MywgMHgyNTUxLFxyXG4gICAgMHgyNTU3LCAweDI1NUQsIDB4MjU1QywgMHgyNTVCLCAweDI1MTAsIDB4MjUxNCwgMHgyNTM0LCAweDI1MkMsIDB4MjUxQywgMHgyNTAwLCAweDI1M0MsXHJcbiAgICAweDI1NUUsIDB4MjU1RiwgMHgyNTVBLCAweDI1NTQsIDB4MjU2OSwgMHgyNTY2LCAweDI1NjAsIDB4MjU1MCwgMHgyNTZDLCAweDI1NjcsIDB4MjU2OCxcclxuICAgIDB4MjU2NCwgMHgyNTY1LCAweDI1NTksIDB4MjU1OCwgMHgyNTUyLCAweDI1NTMsIDB4MjU2QiwgMHgyNTZBLCAweDI1MTgsIDB4MjUwQywgMHgyNTg4LFxyXG4gICAgMHgyNTg0LCAweDI1OEMsIDB4MjU5MCwgMHgyNTgwLCAweDAzQjEsIDB4MDBERiwgMHgwMzkzLCAweDAzQzAsIDB4MDNBMywgMHgwM0MzLCAweDAwQjUsXHJcbiAgICAweDAzQzQsIDB4MDNBNiwgMHgwMzk4LCAweDAzQTksIDB4MDNCNCwgMHgyMjFFLCAweDAzQzYsIDB4MDNCNSwgMHgyMjI5LCAweDIyNjEsIDB4MDBCMSxcclxuICAgIDB4MjI2NSwgMHgyMjY0LCAweDIzMjAsIDB4MjMyMSwgMHgwMEY3LCAweDIyNDgsIDB4MDBCMCwgMHgyMjE5LCAweDAwQjcsIDB4MjIxQSwgMHgyMDdGLFxyXG4gICAgMHgwMEIyLCAweDI1QTAsIDB4MDBBMFxyXG4gIF1cclxuXHJcbiAgdmFyIGNvbnZlcnRlZEJ1ZmZlciA9IG5ldyBBcnJheShidWZmZXIubGVuZ3RoKVxyXG4gIHZhciBsZW4gPSBjb252ZXJ0ZWRCdWZmZXIubGVuZ3RoXHJcbiAgdmFyIGlcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGNvbnZlcnRlZEJ1ZmZlcltpXSA9IHRhYmxlW2J1ZmZlcltpXV1cclxuICB9XHJcblxyXG4gIHZhciBNQVhfQ0hVTktfU0laRSA9IDMyNzY3XHJcbiAgdmFyIHN0ciA9ICcnXHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xyXG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29udmVydGVkQnVmZmVyLnNsaWNlKGksIGkgKyBNQVhfQ0hVTktfU0laRSkpXHJcbiAgfVxyXG4gIHJldHVybiBzdHJcclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbnZhciBjcmMzMiA9IHJlcXVpcmUoJ2J1ZmZlci1jcmMzMicpXHJcbnZhciBjcmVhdGVJbmZsYXRlUmF3ID0gcmVxdWlyZSgnemxpYicpLmNyZWF0ZUluZmxhdGVSYXdcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxyXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcclxudmFyIEUgPSBVdGlscy5FXHJcbnZhciByZWFkVUludDY0TEUgPSBVdGlscy5yZWFkVUludDY0TEVcclxudmFyIGNwNDM3VG9Vbmljb2RlID0gVXRpbHMuY3A0MzdUb1VuaWNvZGVcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVxyXG5cclxuZnVuY3Rpb24gWmlwRmlsZSAocmVhZGVyLCBlb2Nkcikge1xyXG4gIHRoaXMuZW50cmllcyA9IFtdXHJcbiAgdGhpcy5lbnRyeUNvdW50ID0gZW9jZHIuZW50cnlDb3VudFxyXG4gIHRoaXMuY29tbWVudCA9IGVvY2RyLmNvbW1lbnRcclxuICB0aGlzLl9jZFNpemUgPSBlb2Nkci5jZFNpemVcclxuICB0aGlzLl9jZE9mZnNldCA9IGVvY2RyLmNkT2Zmc2V0XHJcbiAgdGhpcy5fcmVhZGVyID0gcmVhZGVyXHJcbn1cclxuXHJcblppcEZpbGUucHJvdG90eXBlLnJlYWRFbnRyaWVzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgdmFyIGZpeGVkRmllbGRzU2l6ZSA9IDQ2XHJcbiAgdmFyIHNlbGYgPSB0aGlzXHJcblxyXG4gIGNhbGxiYWNrID0gKGZ1bmN0aW9uIChmbikge1xyXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xyXG4gICAgICBpZiAoY2FsbGVkKSByZXR1cm5cclxuICAgICAgY2FsbGVkID0gdHJ1ZVxyXG4gICAgICBmbihlcnIsIGVudHJpZXMpXHJcbiAgICB9XHJcbiAgfSkoY2FsbGJhY2spXHJcblxyXG4gIHZhciByZWFkU3RyZWFtID0gdGhpcy5fcmVhZGVyLmNyZWF0ZVJlYWRTdHJlYW0oe1xyXG4gICAgc3RhcnQ6IHRoaXMuX2NkT2Zmc2V0LFxyXG4gICAgZW5kOiAodGhpcy5fY2RPZmZzZXQgKyB0aGlzLl9jZFNpemUpXHJcbiAgfSlcclxuICByZWFkU3RyZWFtLm9uKCdlcnJvcicsIGNhbGxiYWNrKVxyXG4gIHJlYWRTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNhbGxiYWNrKFxyXG4gICAgICBzZWxmLmVudHJpZXMubGVuZ3RoID09PSBzZWxmLmVudHJ5Q291bnRcclxuICAgICAgICA/IG51bGxcclxuICAgICAgICA6IEUoJ2V4cGVjdGVkIHswfSBlbnRyaWVzIGdvdCB7MX0nLCBzZWxmLmVudHJ5Q291bnQsIHNlbGYuZW50cmllcy5sZW5ndGgpLFxyXG4gICAgICBzZWxmLmVudHJpZXNcclxuICAgIClcclxuICB9KVxyXG4gIHJlYWRTdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZSlcclxuXHJcbiAgZnVuY3Rpb24gZGVzdHJveUFuZERyYWluIChlcnJvcikge1xyXG4gICAgcmVhZFN0cmVhbS5kZXN0cm95KGVycm9yKVxyXG4gICAgcmVhZFN0cmVhbS5yZWFkKClcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uUmVhZGFibGUgKCkge1xyXG4gICAgd2hpbGUgKHRoaXMucmVhZGFibGVMZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlYWRhYmxlTGVuZ3RoIDwgZml4ZWRGaWVsZHNTaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgIHJldHVybiBkZXN0cm95QW5kRHJhaW4oXHJcbiAgICAgICAgICAgIEUoJ2V4cGVjdGVkIGF0IGxlYXN0IDQ2IGJ5dGVzIGZvciBDZW50cmFsIEZpbGUgSGVhZGVyIGdvdCB7MH0nLCB0aGlzLnJlYWRhYmxlTGVuZ3RoKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBmaXhlZEZpZWxkc0J1ZmZlciA9IHRoaXMucmVhZChmaXhlZEZpZWxkc1NpemUpXHJcbiAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSgpXHJcblxyXG4gICAgICAvLyBjZW50cmFsIGZpbGUgaGVhZGVyIHNpZ25hdHVyZSAgIDQgYnl0ZXMgICgweDAyMDE0YjUwKVxyXG4gICAgICBpZiAoZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQzMkxFKDApICE9PSAweDAyMDE0YjUwKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3lBbmREcmFpbihFKCdpbnZhbGlkZSBDZW50cmFsIEZpbGUgSGVhZGVyIHNpZ25hdHVyZScpKVxyXG4gICAgICB9XHJcbiAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAgICAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICBlbnRyeS52ZXJzaW9uTWFkZUJ5ID0gZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQxNkxFKDQpXHJcbiAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3QgICAgICAgMiBieXRlc1xyXG4gICAgICBlbnRyeS52ZXJzaW9uTmVlZGVkVG9FeHRyYWN0ID0gZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQxNkxFKDYpXHJcbiAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZyAgICAgICAgMiBieXRlc1xyXG4gICAgICBlbnRyeS5nZW5lcmFsUHVycG9zZUJpdEZsYWcgPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDE2TEUoOClcclxuICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kICAgICAgICAgICAgICAyIGJ5dGVzXHJcbiAgICAgIGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kID0gZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQxNkxFKDEwKVxyXG4gICAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWUgICAgICAgICAgICAgIDIgYnl0ZXNcclxuICAgICAgZW50cnkubGFzdE1vZFRpbWUgPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDE2TEUoMTIpXHJcbiAgICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZSAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICBlbnRyeS5sYXN0TW9kRGF0ZSA9IGZpeGVkRmllbGRzQnVmZmVyLnJlYWRVSW50MTZMRSgxNClcclxuICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXHJcbiAgICAgIGVudHJ5LmNyYzMyID0gZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQzMkxFKDE2KVxyXG4gICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcclxuICAgICAgZW50cnkuY29tcHJlc3NlZFNpemUgPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDMyTEUoMjApXHJcbiAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xyXG4gICAgICBlbnRyeS51bmNvbXByZXNzZWRTaXplID0gZml4ZWRGaWVsZHNCdWZmZXIucmVhZFVJbnQzMkxFKDI0KVxyXG4gICAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoICAgICAgICAgICAgICAgIDIgYnl0ZXNcclxuICAgICAgdmFyIG5hbWVMZW5ndGggPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDE2TEUoMjgpXHJcbiAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aCAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICB2YXIgZXh0cmFGaWVsZHNMZW5ndGggPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDE2TEUoMzApXHJcbiAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGggICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICB2YXIgY29tbWVudExlbmd0aCA9IGZpeGVkRmllbGRzQnVmZmVyLnJlYWRVSW50MTZMRSgzMilcclxuICAgICAgLy8gZGlzayBudW1iZXIgc3RhcnQgICAgICAgICAgICAgICAyIGJ5dGVzXHJcbiAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyAgICAgICAgMiBieXRlc1xyXG4gICAgICBlbnRyeS5pbnRlcm5hbEF0dHJpYnV0ZXMgPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDE2TEUoMzYpXHJcbiAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyAgICAgICAgNCBieXRlc1xyXG4gICAgICBlbnRyeS5leHRlcm5hbEF0dHJpYnV0ZXMgPSBmaXhlZEZpZWxkc0J1ZmZlci5yZWFkVUludDMyTEUoMzgpXHJcbiAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXIgNCBieXRlc1xyXG4gICAgICBlbnRyeS5sb2NhbEhlYWRlck9mZnNldCA9IGZpeGVkRmllbGRzQnVmZmVyLnJlYWRVSW50MzJMRSg0MilcclxuXHJcbiAgICAgIHZhciB2YXJpYWJsZUZpZWxkc1NpemUgPSBuYW1lTGVuZ3RoICsgZXh0cmFGaWVsZHNMZW5ndGggKyBjb21tZW50TGVuZ3RoXHJcbiAgICAgIGlmICh0aGlzLnJlYWRhYmxlTGVuZ3RoIDwgdmFyaWFibGVGaWVsZHNTaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgIHJldHVybiBkZXN0cm95QW5kRHJhaW4oXHJcbiAgICAgICAgICAgIEUoXHJcbiAgICAgICAgICAgICAgJ2V4cGVjdGVkIGF0IGxlYXN0IHswfSBieXRlcyBmb3IgdmFyaWFibGUgZmllbGRzIGluIENlbnRyYWwgRmlsZSBIZWFkZXIgZ290IHsxfScsXHJcbiAgICAgICAgICAgICAgdmFyaWFibGVGaWVsZHNTaXplLFxyXG4gICAgICAgICAgICAgIHRoaXMucmVhZGFibGVMZW5ndGhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVuc2hpZnQoZml4ZWRGaWVsZHNCdWZmZXIpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFyaWFibGVGaWVsZHNCdWZmZXIgPSB0aGlzLnJlYWQodmFyaWFibGVGaWVsZHNTaXplKVxyXG5cclxuICAgICAgLy8gZmlsZSBuYW1lICh2YXJpYWJsZSBzaXplKVxyXG4gICAgICBlbnRyeS5uYW1lID0gdmFyaWFibGVGaWVsZHNCdWZmZXIuc2xpY2UoMCwgbmFtZUxlbmd0aClcclxuICAgICAgLy8gZXh0cmEgZmllbGQgKHZhcmlhYmxlIHNpemUpXHJcbiAgICAgIHZhciBleHRyYUZpZWxkc0J1ZmZlciA9IHZhcmlhYmxlRmllbGRzQnVmZmVyLnNsaWNlKFxyXG4gICAgICAgIG5hbWVMZW5ndGgsXHJcbiAgICAgICAgbmFtZUxlbmd0aCArIGV4dHJhRmllbGRzTGVuZ3RoXHJcbiAgICAgIClcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4dHJhRmllbGRzQnVmZmVyLmxlbmd0aCAtIDM7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgdmFyIGhlYWRlcklkID0gZXh0cmFGaWVsZHNCdWZmZXIucmVhZFVJbnQxNkxFKGkpXHJcbiAgICAgICAgdmFyIGRhdGFTaXplID0gZXh0cmFGaWVsZHNCdWZmZXIucmVhZFVJbnQxNkxFKGkgKz0gMilcclxuICAgICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4dHJhRmllbGRzQnVmZmVyLnNsaWNlKGkgKz0gMiwgaSArPSBkYXRhU2l6ZSkpXHJcbiAgICAgICAgZW50cnkuZXh0cmFGaWVsZHMucHVzaCh7IGhlYWRlcklkOiBoZWFkZXJJZCwgZGF0YVNpemU6IGRhdGFTaXplLCBkYXRhOiBkYXRhIH0pXHJcbiAgICAgIH1cclxuICAgICAgLy8gY29tbWVudCAodmFyaWFibGUgc2l6ZSlcclxuICAgICAgZW50cnkuY29tbWVudCA9IHZhcmlhYmxlRmllbGRzQnVmZmVyLnNsaWNlKG5hbWVMZW5ndGggKyBleHRyYUZpZWxkc0xlbmd0aClcclxuXHJcbiAgICAgIC8vIGhhbmRsZSBlbmNvZGluZ1xyXG4gICAgICB2YXIgaXNVVEY4ID0gKGVudHJ5LmdlbmVyYWxQdXJwb3NlQml0RmxhZyAmIDB4ODAwKSA9PT0gMHg4MDBcclxuICAgICAgaWYgKGlzVVRGOCkge1xyXG4gICAgICAgIGVudHJ5Lm5hbWUgPSBlbnRyeS5uYW1lLnRvU3RyaW5nKClcclxuICAgICAgICBlbnRyeS5jb21tZW50ID0gZW50cnkuY29tbWVudC50b1N0cmluZygpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZW50cnkubmFtZSA9IGNwNDM3VG9Vbmljb2RlKGVudHJ5Lm5hbWUpXHJcbiAgICAgICAgZW50cnkuY29tbWVudCA9IGNwNDM3VG9Vbmljb2RlKGVudHJ5LmNvbW1lbnQpXHJcbiAgICAgIH1cclxuICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoL0NvbW1lbnQgRXh0cmEgRmllbGRcclxuICAgICAgO1snbmFtZScsICdjb21tZW50J10uZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICB2YXIgaGVhZGVySWRcclxuICAgICAgICB2YXIgb2xkRGF0YVxyXG4gICAgICAgIGlmIChmaWVsZCA9PT0gJ25hbWUnKSB7XHJcbiAgICAgICAgICBoZWFkZXJJZCA9IDB4NzA3NVxyXG4gICAgICAgICAgb2xkRGF0YSA9IHZhcmlhYmxlRmllbGRzQnVmZmVyLnNsaWNlKDAsIG5hbWVMZW5ndGgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGhlYWRlcklkID0gMHg2Mzc1XHJcbiAgICAgICAgICBvbGREYXRhID0gdmFyaWFibGVGaWVsZHNCdWZmZXIuc2xpY2UobmFtZUxlbmd0aCArIGV4dHJhRmllbGRzTGVuZ3RoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5mb1ppcFVFRnMgPSBlbnRyeS5leHRyYUZpZWxkcy5maWx0ZXIoZnVuY3Rpb24gKGVmKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWYuaGVhZGVySWQgPT09IGhlYWRlcklkXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaW5mb1ppcFVFRnMuZm9yRWFjaChmdW5jdGlvbiAoaW5mb1ppcFVFRikge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBpbmZvWmlwVUVGLmRhdGFcclxuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDYpIHtcclxuICAgICAgICAgICAgdmFyIHZlcnNpb25SZWNvZ25pemVkID0gZGF0YS5yZWFkVUludDgoMCkgPT09IDFcclxuICAgICAgICAgICAgdmFyIGNyY0NoZWNrUGFzc2VkID0gY3JjMzIudW5zaWduZWQob2xkRGF0YSkgPT09IGRhdGEucmVhZFVJbnQzMkxFKDEpXHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBkYXRhLnRvU3RyaW5nKCd1dGY4JywgNSlcclxuICAgICAgICAgICAgaWYgKHZlcnNpb25SZWNvZ25pemVkICYmIGNyY0NoZWNrUGFzc2VkICYmIHN0ci5sZW5ndGggPiAwKSBlbnRyeVtmaWVsZF0gPSBzdHJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gaGFuZGxlIHppcDY0IGZvcm1hdFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgZW50cnkuY29tcHJlc3NlZFNpemUgPT09IDB4ZmZmZmZmZmYgfHxcclxuICAgICAgICBlbnRyeS51bmNvbXByZXNzZWRTaXplID09PSAweGZmZmZmZmZmIHx8XHJcbiAgICAgICAgZW50cnkubG9jYWxIZWFkZXJPZmZzZXQgPT09IDB4ZmZmZmZmZmZcclxuICAgICAgKSB7XHJcbiAgICAgICAgdmFyIHppcDY0RUlFRiA9IGVudHJ5LmV4dHJhRmllbGRzLmZpbHRlcihmdW5jdGlvbiAoZWYpIHtcclxuICAgICAgICAgIHJldHVybiBlZi5oZWFkZXJJZCA9PT0gMHgwMDAxXHJcbiAgICAgICAgfSlbMF1cclxuICAgICAgICBpZiAoemlwNjRFSUVGKSB7XHJcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMFxyXG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsndW5jb21wcmVzc2VkU2l6ZScsICdjb21wcmVzc2VkU2l6ZScsICdsb2NhbEhlYWRlck9mZnNldCddXHJcbiAgICAgICAgICBmb3IgKHZhciBqIGluIGZpZWxkcykge1xyXG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal1cclxuICAgICAgICAgICAgaWYgKGVudHJ5W2ZpZWxkXSA9PT0gMHhmZmZmZmZmZikge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeVtmaWVsZF0gPSByZWFkVUludDY0TEUoemlwNjRFSUVGLmRhdGEsIG9mZnNldClcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzdHJveUFuZERyYWluKFxyXG4gICAgICAgICAgICAgICAgICBFKCdpbnZhbGlkIFppcDY0IEV4dGVuZGVkIEluZm9ybWF0aW9uIEV4dHJhIEZpZWxkOiB7MH0gbm90IGZvdW5kJywgZmllbGQpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBkZXN0cm95QW5kRHJhaW4oRSgnWmlwNjQgRXh0ZW5kZWQgSW5mb3JtYXRpb24gRXh0cmEgRmllbGQgbm90IGZvdW5kJykpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLmVudHJpZXMucHVzaChlbnRyeSlcclxuICAgIH1cclxuICAgIHRoaXMucmVhZCgwKVxyXG4gIH1cclxufVxyXG5cclxuWmlwRmlsZS5wcm90b3R5cGUucmVhZEVudHJ5RGF0YSA9IGZ1bmN0aW9uIChlbnRyeSwgY2hlY2tDcmMsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKGVudHJ5LmVuY3J5cHRlZCkge1xyXG4gICAgY2FsbGJhY2soRSgnZW5jcnlwdGVkIGZpbGVzIGFyZSBub3Qgc3VwcG9ydGVkJykpXHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kICE9PSAwICYmIGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kICE9PSA4KSB7XHJcbiAgICBjYWxsYmFjayhFKCdjb21wcmVzc2lvbiBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCcpKVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgZml4ZWRGaWVsZHNTaXplID0gMzBcclxuICB2YXIgc2VsZiA9IHRoaXNcclxuICB0aGlzLl9yZWFkZXIucmVhZChcclxuICAgIGVudHJ5LmxvY2FsSGVhZGVyT2Zmc2V0LFxyXG4gICAgZW50cnkubG9jYWxIZWFkZXJPZmZzZXQgKyBmaXhlZEZpZWxkc1NpemUsXHJcbiAgICBmdW5jdGlvbiAoZXJyLCBidWYpIHtcclxuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcclxuXHJcbiAgICAgIGlmIChidWYubGVuZ3RoIDwgZml4ZWRGaWVsZHNTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxyXG4gICAgICAgICAgRSgnZXhwZWN0ZWQgYXQgbGVhc3QgMzAgYnl0ZXMgZm9yIExvY2FsIEZpbGUgSGVhZGVyIGdvdCB7MX0nLCBidWYubGVuZ3RoKVxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbG9jYWwgZmlsZSBoZWFkZXIgc2lnbmF0dXJlICAgICA0IGJ5dGVzICAoMHgwNDAzNGI1MClcclxuICAgICAgaWYgKGJ1Zi5yZWFkVUludDMyTEUoMCkgIT09IDB4MDQwMzRiNTApIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soRSgnaW52YWxpZCBMb2NhbCBGaWxlIEhlYWRlciBzaWduYXR1cmUnKSlcclxuICAgICAgfVxyXG4gICAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0ICAgICAgIDIgYnl0ZXNcclxuICAgICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnICAgICAgICAyIGJ5dGVzXHJcbiAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZCAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWUgICAgICAgICAgICAgIDIgYnl0ZXNcclxuICAgICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlICAgICAgICAgICAgICAyIGJ5dGVzXHJcbiAgICAgIC8vIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xyXG4gICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcclxuICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICA0IGJ5dGVzXHJcbiAgICAgIC8vIGZpbGUgbmFtZSBsZW5ndGggICAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICB2YXIgbmFtZUxlbmd0aCA9IGJ1Zi5yZWFkVUludDE2TEUoMjYpXHJcbiAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aCAgICAgICAgICAgICAgMiBieXRlc1xyXG4gICAgICB2YXIgZXh0cmFGaWVsZExlbmd0aCA9IGJ1Zi5yZWFkVUludDE2TEUoMjgpXHJcblxyXG4gICAgICB2YXIgZGF0YVN0YXJ0ID0gZW50cnkubG9jYWxIZWFkZXJPZmZzZXQgKyBmaXhlZEZpZWxkc1NpemUgKyBuYW1lTGVuZ3RoICsgZXh0cmFGaWVsZExlbmd0aFxyXG4gICAgICB2YXIgcmVhZFN0cmVhbSA9IHNlbGYuX3JlYWRlci5jcmVhdGVSZWFkU3RyZWFtKHtcclxuICAgICAgICBzdGFydDogZGF0YVN0YXJ0LFxyXG4gICAgICAgIGVuZDogZGF0YVN0YXJ0ICsgZW50cnkuY29tcHJlc3NlZFNpemVcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHZhciBvdXRTdHJlYW0gPSByZWFkU3RyZWFtXHJcblxyXG4gICAgICBpZiAoZW50cnkuY29tcHJlc3Npb25NZXRob2QgPT09IDgpIHtcclxuICAgICAgICB2YXIgaW5mbGF0ZSA9IGNyZWF0ZUluZmxhdGVSYXcoKVxyXG4gICAgICAgIG91dFN0cmVhbSA9IG91dFN0cmVhbVxyXG4gICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgaW5mbGF0ZS5kZXN0cm95KGVycikgfSlcclxuICAgICAgICAgIC5waXBlKGluZmxhdGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGVja0NyYykge1xyXG4gICAgICAgIHZhciBwYXJ0aWFsQ3JjXHJcbiAgICAgICAgdmFyIGNyY1RyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oe1xyXG4gICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBwYXJ0aWFsQ3JjID0gY3JjMzIoY2h1bmssIHBhcnRpYWxDcmMpXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGZpbmFsQ3JjID0gcGFydGlhbENyYy5yZWFkVUludDMyQkUoMClcclxuICAgICAgICAgICAgY2FsbGJhY2soZmluYWxDcmMgPT09IGVudHJ5LmNyYzMyID8gbnVsbCA6IEUoJ2NvcnJ1cHRlZCBmaWxlOiBjcmMgY2hlY2sgZmFpbHMnKSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIG91dFN0cmVhbSA9IG91dFN0cmVhbVxyXG4gICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgY3JjVHJhbnNmb3JtLmRlc3Ryb3koZXJyKSB9KVxyXG4gICAgICAgICAgLnBpcGUoY3JjVHJhbnNmb3JtKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYWxsYmFjayhudWxsLCBvdXRTdHJlYW0pXHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBFbnRyeSAoKSB7XHJcbiAgdGhpcy5leHRyYUZpZWxkcyA9IFtdXHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVudHJ5LnByb3RvdHlwZSwge1xyXG4gIGVuY3J5cHRlZDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5nZW5lcmFsUHVycG9zZUJpdEZsYWcgJiAweDAwMDEpID09PSAweDAwMDEgfVxyXG4gIH0sXHJcbiAgbGFzdE1vZERhdGVUaW1lOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKFxyXG4gICAgICAgICh0aGlzLmxhc3RNb2REYXRlID4+IDkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcclxuICAgICAgICAodGhpcy5sYXN0TW9kRGF0ZSA+PiA1ICYgMHhmKSAtIDEsIC8vIG1vbnRoXHJcbiAgICAgICAgdGhpcy5sYXN0TW9kRGF0ZSAmIDB4MWYsIC8vIGRheVxyXG4gICAgICAgICh0aGlzLmxhc3RNb2RUaW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJzXHJcbiAgICAgICAgKHRoaXMubGFzdE1vZFRpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVzXHJcbiAgICAgICAgKHRoaXMubGFzdE1vZFRpbWUgJiAweDFmKSAqIDIgLy8gc2Vjb25kc1xyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==